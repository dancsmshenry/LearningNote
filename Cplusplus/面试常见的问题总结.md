## 1、指针和引用的区别

- 指针本质是一个变量（存储的是对象的地址），引用本质是原变量的别名
- 指针可以有多级，引用只能有一级
- 指针可以为空，引用不能为空且需要在定义的时候初始化
- 指针在初始化以后可以改变指向，引用在初始化之后不可以再改变
- 关于sizeof：sizeof(指针)为指针的大小，sizeof(引用)为所指对象的大小



## 2、在 main 执行之前和之后执行的代码有哪些

- main函数执行之前：
  - 初始化静态static变量和global全局变量
  - 为未初始化的global全局变量赋初值
  - 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
- main函数执行之后
  - 全局对象的析构函数



## 3、堆和栈的区别

- 申请方式不同
  - 堆是由使用者申请和释放的
  - 栈是由系统自动分配的
- 申请大小不同
  - 栈顶和栈底都是预先定好的，栈是向栈底拓展，大小固定（默认4M）
  - 堆向高地址拓展，是不连续的内存区域，大小可以灵活调整（一般是1G-4G）
- 申请效率不同
  - 栈由系统分配，速度快，不会有碎片
  - 堆由程序员分配，速度慢，且会有碎片
- 为什么效率不同
  - 操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简 单，并且有专门的指令执行，所以栈的效率比较高也比较快
  - 堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且 获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢



## 4、区分一下指针类型

- ```cpp
  int *p[10];
  int (*p)[10];
  int *p(int);
  int (*p)(int);
  ```

- tips：看的时候，如果没有小括号，就把星号放到左边去看

- `int *p[10]`表示指针数组，是一个数组变量，数组内每个元素都是指向int类型的指针变量，数组大小为10

- `int (*p)[10]`表示数组指针，是一个指针类型的变量，指向的是一个int类型的数组，数组大小为10

- `int *p(int)`是函数声明，函数名是p，参数是int类型，返回值是int*类型

- `int (*p)(int)`是函数指针，该指针指向的函数具有int类型参数，返回值是int类型



## 5、new 和 delete 的实现原理

- new 的实现：
  - 如果是简单类型，就直接调用 operator new 分配内存
  - 首先调用名为 operator new 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象
  - 接下来运行该类型的一个构造函数，用指定初始化构造对象
  - 最后返回指向新分配并构造后的的对象的指针
- delete 的实现：
  - 首先对指针指向的对象运行适当的析构函数
  - 然后通过调用名为 operator delete 的标准库函数释放该对象所用内存



## 6、new/delete 与 malloc/free 的异同

- 相同点：

  - 都是用于内存的动态申请和释放

- 不同点：

  - 前者是C++运算符（不支持重载），后者是C/C++语言标准库函数（支持覆盖）

  - 前者不需要头文件，后者需要 stdlib.h 头文件

  - new 自动计算要分配的空间大小，malloc 需要手工计算

  - new 是类型安全的（好像是有内部的异常机制），malloc 不是

    - ```cpp
      int *p = new float[2]; //编译错误
      int *p = (int*)malloc(2 * sizeof(double));//编译无错误
      ```

  - malloc 和 free 返回的是 void 类型指针（所以要进行类型转换），new 和 delete 返回的是具体类型指针

  - malloc 和 free 仅仅分配或回收空间，不调用析构或构造函数



## 7、宏定义和函数的区别

- 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值
- 宏定义的参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型
- 宏是在预处理时完成替换的，等价于直接插入代码，执行较快；函数调用在运行时需要跳转到具体调用的函数



## 8、宏定义和 typedef 的区别

- 宏用于定义常量以及书写复杂的内容， typedef 主要用于定义类型别名

- 宏发生在预处理阶段， typedef 是编译的一部分

- 宏不检查类型，typedef会检查数据类型

- 宏不是语句，不在最后加分号， typedef 是语句，要加分号标识结束

- 宏没有作用域的限制， typedef 有自己的作用域

- 巨坑：

  - ```cpp
    #define INTPTR1 int*
    
    typedef int* INTPTR2;
    
    INTPTR1 p1, p2;//声明一个指针变量p1和一个整型变量p2
    
    INTPTR2 p3, p4;//声明两个指针变量p3、p4
    ```



## 9、宏定义和 const 的区别

- 宏定义是在编译的预处理阶段起作用，const 是在编译、运行的时候起作用
- 宏定义只做替换，不做类型检查和计算，const 常量有数据类型，编译器可以对其进行类型安全检查
- 宏定义不需要分配内存空间，只是替换掉，const 定义的变量只是值不能改变，但要分配内存空间
- 宏定义是将宏名称进行替换，在内存中会产生多分相同的备份，const 在程序运行中只有一份备份， 且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表



## 10、指针常量和常量指针的区别

- 指针常量是一个指针，解释为指向一个常量的指针，即指向一个只读变量。也就是后面所指明的 int const 和 const int ，都是一个常量，可以写作int const *p或const int *p
- 常量指针，解释为一个不能改变指向的指针（有点像引用是吧）。指针是常量，所以必须初始化，且初始化过后它的值就不能再改变了，即不能中途改变指向，写作 int* const p
- 所以区别重点还是要看星号的位置XD



## 11、在 cpp 中 struct 和 class 的区别

- 相同点：
  - 两者都有成员函数、区分公有和私有部分
  - 可以任意取代
- 不同点：
  - 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
  - class默认是private继承，而struct模式是public继承



## 12、struct 在 c 和 cpp 中的区别

- 在 C 中， struct 是用户自定义数据类型（UDT）；在 Cpp 中，struct 是抽象数据类型（ADT），支持成员函数的定义，能继承，能实现多态
- 在 C 中  struct 是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数
- 在 Cpp 中，struct 增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为 public （为了与 C 兼容）



## 13、浅拷贝和深拷贝的区别

- 浅拷贝
  - 只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误
- 深拷贝
  - 贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的



## 14、=default、=delete、mutable 和 explicit 关键字的用法

- explicit

  - 用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方法进行类型转换
  - 只能用于类内部的构造函数声明上，而不能用在类外部的函数定义上
  - 只能用于单个参数的构造函数上
  - 被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换

- mutable

  - 背景：如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成 const 的
  - 但有些时候，我们需要在 const 函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 mutable 来修饰，并且放在函数后后面关键字位置
  - 即如果该变量被 mutable 修饰，那么即使是在被 const 修饰的成员函数里面，该变量也可以被修改

- =default，=delete（cpp11以后才有的）

  - 背景：如果你自行定义了一个构造函数，编译器不会再给你提供默认构造函数；或者你不想要使用某个函数

  - 而如果你在函数后面加上 =default ，就可以重新获得并使用 default 版本的构造/析构函数

    - ```cpp
      class Foo{
          private:
          	int _i;
          
          public:
          	Foo(i):_i(i){}
          	Foo() = default;//表示使用编译器默认提供的版本（因为有了参数构造函数，编译器是不会提供那个默认构造的函数的）
          	
          	~Foo() = default;
          	void func1() = default;//一般的函数没有默认版本，所以不能用
          	void func2() = delete;//禁止使用编译器默认生成的函数，可以用于任何函数
          	//也可以禁止使用某函数
      };
      ```



## 15、什么时候会调用拷贝构造函数

- 用类的一个实例化对象去初始化另一个对象
- 类对象作为函数的参数且并非引用传递的时候
- 函数的返回值是函数体内局部对象的类的对象时，此时虽然发生 NRV 优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数
  - 在linux gcc下不会发生拷贝构造函数调用，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数
  - 不过我记得gcc关闭优化后，还是会调用拷贝构造函数



## 16、static 的用法和用法

-  隐藏（static 函数，static 变量均可）
  - 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性
- 保持变量内容的持久
  - 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化
  - 共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围
- 默认初始化为0
  - 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00
- 将类对象的类成员声明为 static
  - 在类中的**static 成员变量**属于整个类所拥有，对类的所有对象只有一份拷贝
  - 在类中的**static 成员函数**属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量
  - 在类中的**static 成员函数**只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内
  - **static 成员函数**属于类不属于对象，所以没有 this 指针，不能访问非 static 的类成员，只能访问 static 修饰的类成员
  - 在模块内的**static 全局变量**可以被模块内所用函数访问，但不能被模块外其它函数访问
  - **static 类对象**必须在类内声明，在类外进行初始化（static修饰的变量先于对象存在，如果是在类内初始化，会导致每个对象都包含该静态成员）
  - **static成员函数**不能被virtual修饰

