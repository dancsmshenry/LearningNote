## 1、指针和引用的区别

- 指针本质是一个变量（存储的是对象的地址），引用本质是原变量的别名
- 指针可以有多级，引用只能有一级
- 指针可以为空，引用不能为空且需要在定义的时候初始化
- 指针在初始化以后可以改变指向，引用在初始化之后不可以再改变
- 关于sizeof：sizeof(指针)为指针的大小，sizeof(引用)为所指对象的大小



## 2、在 main 执行之前和之后执行的代码有哪些

- main函数执行之前：
  - 初始化静态static变量和global全局变量
  - 为未初始化的global全局变量赋初值
  - 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
- main函数执行之后
  - 全局对象的析构函数



## 3、堆和栈的区别

- 申请方式不同
  - 堆是由使用者申请和释放的
  - 栈是由系统自动分配的
- 申请大小不同
  - 栈顶和栈底都是预先定好的，栈是向栈底拓展，大小固定（默认4M）
  - 堆向高地址拓展，是不连续的内存区域，大小可以灵活调整（一般是1G-4G）
- 申请效率不同
  - 栈由系统分配，速度快，不会有碎片
  - 堆由程序员分配，速度慢，且会有碎片
- 为什么效率不同
  - 操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简 单，并且有专门的指令执行，所以栈的效率比较高也比较快
  - 堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且 获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢



## 4、区分一下指针类型

- ```cpp
  int *p[10];
  int (*p)[10];
  int *p(int);
  int (*p)(int);
  const int* p1;
  int* const p2;
  const int * const p3;
  ```
  
- `int *p[10]`表示指针数组，是一个数组变量，数组内每个元素都是指向int类型的指针变量，数组大小为10

- `int (*p)[10]`表示数组指针，是一个指针类型的变量，指向的是一个int类型的数组，数组大小为10

- `int *p(int)`是函数声明，函数名是p，参数是int类型，返回值是int*类型

- `int (*p)(int)`是函数指针，该指针指向的函数具有int类型参数，返回值是int类型

- `const int* p1`是一个指向整形常量的指针，它所指向的值不能修改

- `int* const p2`是一个指向整形变量的常量指针，该指针不可以改变指向，但是其指向的量可以被修改

- `const int* const p3`是一个指向整型常量的常量指针，不能再指向别的变量，指向的值也不能修改

- tips：

  - 看的时候，如果没有小括号，就把星号放到左边去看
  - 观察 const ， const 右边是类型，那该值（可以理解为是指针指向的值，也可以就是这个值）就是常量；如果是指针变量，那指针本身就是常量



## 5、new 和 delete 的实现原理

- new 的实现：
  - 如果是简单类型，就直接调用 operator new 分配内存
  - 首先调用名为 operator new 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象
  - 接下来运行该类型的一个构造函数，用指定初始化构造对象
  - 最后返回指向新分配并构造后的的对象的指针
- delete 的实现：
  - 首先对指针指向的对象运行适当的析构函数
  - 然后通过调用名为 operator delete 的标准库函数释放该对象所用内存



## 6、new/delete 与 malloc/free 的异同

- 相同点：

  - 都是用于内存的动态申请和释放

- 不同点：

  - 前者是C++运算符（不支持重载），后者是C/C++语言标准库函数（支持覆盖）

  - 前者不需要头文件，后者需要 stdlib.h 头文件

  - new 自动计算要分配的空间大小，malloc 需要手工计算

  - new 是类型安全的（好像是有内部的异常机制），malloc 不是

    - ```cpp
      int *p = new float[2]; //编译错误
      int *p = (int*)malloc(2 * sizeof(double));//编译无错误
      ```

  - malloc 和 free 返回的是 void 类型指针（所以要进行类型转换），new 和 delete 返回的是具体类型指针

  - malloc 和 free 仅仅分配或回收空间，不调用析构或构造函数



## 7、宏定义和函数的区别

- 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值
- 宏定义的参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型
- 宏是在预处理时完成替换的，等价于直接插入代码，执行较快；函数调用在运行时需要跳转到具体调用的函数



## 8、宏定义和 typedef 的区别

- 宏用于定义常量以及书写复杂的内容， typedef 主要用于定义类型别名

- 宏发生在预处理阶段， typedef 是编译的一部分

- 宏不检查类型，typedef会检查数据类型

- 宏不是语句，不在最后加分号， typedef 是语句，要加分号标识结束

- 宏没有作用域的限制， typedef 有自己的作用域

- 巨坑：

  - ```cpp
    #define INTPTR1 int*
    
    typedef int* INTPTR2;
    
    INTPTR1 p1, p2;//声明一个指针变量p1和一个整型变量p2
    
    INTPTR2 p3, p4;//声明两个指针变量p3、p4
    ```



## 9、宏定义和 const 的区别

- 宏定义是在编译的预处理阶段起作用，const 是在编译、运行的时候起作用
- 宏定义只做替换，不做类型检查和计算，const 常量有数据类型，编译器可以对其进行类型安全检查
- 宏定义不需要分配内存空间，只是替换掉，const 定义的变量只是值不能改变，但要分配内存空间
- 宏定义是将宏名称进行替换，在内存中会产生多分相同的备份，const 在程序运行中只有一份备份， 且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表



## 10、指针常量和常量指针的区别

- 指针常量是一个指针，解释为指向一个常量的指针，即指向一个只读变量。也就是后面所指明的 int const 和 const int ，都是一个常量，可以写作int const *p或const int *p
- 常量指针，解释为一个不能改变指向的指针（有点像引用是吧）。指针是常量，所以必须初始化，且初始化过后它的值就不能再改变了，即不能中途改变指向，写作 int* const p
- 所以区别重点还是要看星号的位置XD



## 11、在 cpp 中 struct 和 class 的区别

- 相同点：
  - 两者都有成员函数、区分公有和私有部分
  - 可以任意取代
- 不同点：
  - 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
  - class默认是private继承，而struct模式是public继承



## 12、struct 在 c 和 cpp 中的区别

- 在 C 中， struct 是用户自定义数据类型（UDT）；在 Cpp 中，struct 是抽象数据类型（ADT），支持成员函数的定义，能继承，能实现多态
- 在 C 中  struct 是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数
- 在 Cpp 中，struct 增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为 public （为了与 C 兼容）



## 13、浅拷贝和深拷贝的区别

- 浅拷贝
  - 只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误
- 深拷贝
  - 贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的



## 14、=default、=delete、mutable 和 explicit 关键字的用法

- explicit

  - 用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方法进行类型转换
  - 只能用于类内部的构造函数声明上，而不能用在类外部的函数定义上
  - 只能用于单个参数的构造函数上
  - 被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换

- mutable

  - 背景：如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成 const 的
  - 但有些时候，我们需要在 const 函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 mutable 来修饰，并且放在函数后后面关键字位置
  - 即如果该变量被 mutable 修饰，那么即使是在被 const 修饰的成员函数里面，该变量也可以被修改

- =default，=delete（cpp11以后才有的）

  - 背景：如果你自行定义了一个构造函数，编译器不会再给你提供默认构造函数；或者你不想要使用某个函数

  - 而如果你在函数后面加上 =default ，就可以重新获得并使用 default 版本的构造/析构函数

    - ```cpp
      class Foo{
          private:
          	int _i;
          
          public:
          	Foo(i):_i(i){}
          	Foo() = default;//表示使用编译器默认提供的版本（因为有了参数构造函数，编译器是不会提供那个默认构造的函数的）
          	
          	~Foo() = default;
          	void func1() = default;//一般的函数没有默认版本，所以不能用
          	void func2() = delete;//禁止使用编译器默认生成的函数，可以用于任何函数
          	//也可以禁止使用某函数
      };
      ```



## 15、什么时候会调用拷贝构造函数

- 用类的一个实例化对象去初始化另一个对象
- 类对象作为函数的参数且并非引用传递的时候
- 函数的返回值是函数体内局部对象的类的对象时，此时虽然发生 NRV 优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数
  - 在linux gcc下不会发生拷贝构造函数调用，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数
  - 不过我记得gcc关闭优化后，还是会调用拷贝构造函数



## 16、static 的用法和用法

-  隐藏（static 函数，static 变量均可）
  - 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性
- 保持变量内容的持久
  - 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化
  - 共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围
- 默认初始化为0
  - 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00
- 将类对象的类成员声明为 static
  - 在类中的**static 成员变量**属于整个类所拥有，对类的所有对象只有一份拷贝
  - 在类中的**static 成员函数**属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量
  - 在类中的**static 成员函数**只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内
  - **static 成员函数**属于类不属于对象，所以没有 this 指针，不能访问非 static 的类成员，只能访问 static 修饰的类成员
  - 在模块内的**static 全局变量**可以被模块内所用函数访问，但不能被模块外其它函数访问
  - **static 类对象**必须在类内声明，在类外进行初始化（static修饰的变量先于对象存在，如果是在类内初始化，会导致每个对象都包含该静态成员）
  - **static成员函数**不能被virtual修饰



## 17、左值引用和右值引用的区别

- 无论左值引用还是右值引用，其返回的结果都是左值
- 左值引用的对象是变量，右值引用的对象是常量



## 19、Cpp 中内存分配情况

- 分别是堆，栈，自由存储区，全局/静态存储区，常量存储区和代码区

- 栈

  - 在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放
  - 栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限

- 堆

  - 就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new 就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收（操作系统不回收的话那就是内存泄漏了）

- 自由存储区

  - 是C++中通过new和delete动态分配和释放对象的抽象概念
  - 需要注意的是，自由存储区和堆比较像，但不等价

- 全局/静态存储区

  - 全局变量和静态变量被分配到同一块内存中
  - 在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定 义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0

- 常量存储区

  - 挖坑：在 c 语言中，局部的 const 设定的变量是存放在栈里面的，全局的 const 才是放在常量存储区的

    - ```c
      #include <stdio.h>
      
      const char a = 'a';//无法运行，因为全局的const变量是存放在常量存储区的
      
      int main(){
          // const char a = 'a';//可以运行，局部是在栈里面的
          printf("%c\n", a);
      
          char *b = &a;
          *b = 'A';
          printf("%c\n", a);
      
          return 0;
      }
      ```

  - 存放的是常量，不允许修改

- 代码区

  - 存放函数体的二进制代码



## 20、重载、重写和重定义的区别

- 重载，是指同一访问区内被声明的几个具有不同参数列表的同名函数
- 重写，派生类中重新定义父类中除了函数体外完全相同的虚函数
  - 被重写的函数不能是 static ，一定要是虚函数，且其他部分也一定要相同
  - 重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的
- 重定义（隐藏），派生类重新定义父类中相同名字的非 virtual 函数
  - 参数列表，返回类型都可以不同



## 21、Cpp 的四种强制转换

- static_cast
  - 明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换 （派⽣类指针->基类指针）安全，下⾏转换（基类指针->派⽣类指针） 不安全，所以主要执⾏⾮多态的转换操作
- dynamic_cast
  - 专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全 的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题
- const_cast
  - 专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符
- reinterpret_cast
  - 不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解释，依赖具体的平台，可移植性差
  - 可以将整形转换为指针，也可以把指针转换为数组；可以在指针和引⽤ 之间进⾏肆⽆忌惮的转换



## 22、析构函数为什么写为虚函数

- 是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调⽤基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏
- 如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构 函数，成功释放内存
- 说白了，就是为了解决多态造成的一个问题（指针使用不当导致内存泄漏）



## 23、Cpp 面向对象的三大特性

- 封装
  - 就是把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让信任的类或者对象操作，对不可信的进⾏信 息隐藏。⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。在⼀个对象内部，某些代码或某些数据 可以是私有的，不能被外界访问。通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部 分意外的改变或错误的使⽤了对象的私有部
  - 不想让外部的代码随意修改对象的属性
- 继承
  - 是指可以让某个类型的对象获得另⼀个类型的对象的属性的⽅法。它⽀持按级分类的概念。继承是指这样⼀种能 ⼒：它可以使⽤现有类的所有功能，并在⽆需᯿新编写原来的类的情况下对这些功能进⾏扩展。通过继承创建的新 类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”、“⽗类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要 实现继承，可以通过“继承”和“组合”来实现
  - 继承的两种：
    - 实现继承：实现继承是指直接使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒（普通继承）
    - 接⼝继承：接⼝继承是指仅使⽤属性和⽅法的名称、但是⼦类必需提供实现的能⼒（纯虚函数）
- 多态
  - 父类指针指向子类
  - 向不同对象发送同一个信息，不同对象在接收时会产生不同的行为
  - 一个接口，多个实现（用 java 的 interface 就很好理解）
  - 多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函 数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在 运⾏时才确定，这就属于晚绑定



## 24、多态是如何实现的



## 25、NULL 和 nullptr 的区别

- 在 c 语言中只有 NULL ，用来表示空指针

  - ```c
    #define NULL ((void*)0)
    ```

- 而在 cpp 中，因为 cpp 是强类型语言， void* 是不能隐式转换成其他类型

  - 所以，cpp引入0来表示空指针

  - ```cpp
    #ifdef __cplusplus
    #define NULL 0
    #else
    #define NULL ((void *)0)
    #endif
    ```

- 但是null会造成二义性（参考https://blog.csdn.net/qq_18108083/article/details/84346655）

- 所以cpp11中引入nullptr，来代表空指针

- 总结：

  - NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用



## 26、switch 的底层实现



## 27、vector 的用法

- ```c++
  向量
  vector<int> a(10)//初始化10个元素为0
  vector<int> a(10, 1)//初始化10个元素，都为1
  vector<int> b(a)//把向量a复制到向量b
  vectot<int> b(a.begin(), a.begin + 3)//把向量a复制到向量b(但只复制前三个)
  vector<int> b(c, c + 7)//把数组c的前七个复制到b中
  
  a.back();//返回a的最后一个元素
  a.front();//返回a的第一个元素
  a.size();//返回a的大小
  a.empty();//判断a是否为空
  a.push_back();//把元素放到向量的最后一个位置
  a.pop_back();//把最后一个元素删除
  a.swap(b);//a和b中的元素交换
  a.begin();//是指指针，用于指向向量开始的地方，所以要回到原值需要*
  a.end();//同理，是指向向量最后的位置
  a[i];//返回a的第i元素,当且仅当a存在
  ```

- ```cpp
  vector<int> a(10)//初始化10个元素为0
  vector<int> a(10, 1)//初始化10个元素，都为1
  vector<int> b(a)//把向量a复制到向量b
  vectot<int> b(a.begin(), a.begin + 3)//把向量a复制到向量b(但只复制前三个)
  vector<int> b(c, c + 7)//把数组c的前七个复制到b中
  
  a.back();//返回a的最后一个元素
  a.front();//返回a的第一个元素
  a.size();//返回a的大小
  a.empty();//判断a是否为空
  a.push_back();//把元素放到向量的最后一个位置
  a.pop_back();//把最后一个元素删除
  a.swap(b);//a和b中的元素交换
  a.begin();//是指指针，用于指向向量开始的地方，所以要回到原值需要*
  a.end();//同理，是指向向量最后的位置
  a[i];//返回a的第i元素,当且仅当a存在
  vector<vector<int>> P(m + 1, vector<int>(n + 1, 0));//二维数组初始化
  ```



## 28、string 的用法

- ```cpp
  字符串
  string a = “asehf”;//初始化
  string b(a);//以a来初始化b
  a.size();//返回a的长度
  a.length();//同上
  string b = a.substr(初始位置（包括）, 末位置（不包括）);//截取a的字符串的部分
  a.empty();//判断是否为空
  a.clear();//清空字符串
  a.c_str();//返回字符串所在字符数组的起始地址
  ```



## 29、queue 的用法

- ```cpp
  queue<int> q1;//初始化
  q1.push();//将元素接到队列末
  q1.pop();//将第一个元素弹出队列，但是不会返回元素值
  q1.front();//队列第一个元素
  q1.back();//队列最后一个元素
  q1.size();//队列大小
  q1.empty();//判断是否为空
  ```



## 30、set 的用法

- ```cpp
  集合
  begin()     　　 ,返回set容器的第一个元素
  
  end() 　　　　 ,返回set容器的最后一个元素
  
  clear()   　　     ,删除set容器中的所有的元素
  
  empty() 　　　,判断set容器是否为空
  
  max_size() 　 ,返回set容器可能包含的元素最大个数
  
  size() 　　　　 ,返回当前set容器中的元素个数
  
  rbegin　　　　 ,返回的值和end()相同
  
  rend()　　　　 ,返回的值和rbegin()相同
      
  count();//查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。
  ```



## 31、deque 的用法

- ```cpp
  双向队列
  size()
  empty()
  clear()
  front()/back()
  push_back()/pop_back()
  push_front()/pop_front()
  begin()/end()
  ```



## 32、stack 的用法

- ```cpp
  栈
  size();
  empty();
  push();  向栈顶插入一个元素
  top();  返回栈顶元素
  pop();  弹出栈顶元素
  ```



## 33、priority queue 的用法

- ```cpp
  优先队列
  //就大的优先出列，小的最后出列，所以元素放入后会自动排序，把大的先放在上面
  size()
  empty()
  push()  插入一个元素
  top()  返回堆顶元素
  pop()  弹出堆顶元素
  ```



## 34、pair 的用法

- ```cpp
  对
  pair<int, int> p1;//初始化对
  pair<int, int> p1（2147483646， 2147483645）;//初始化对并赋值
  pair<int, int> p2(p1)//用p1初始化p2
  //pair类型之间可以互比大小，按照字典序比较
  p1.first//返回第一个值
  p1.second//返回第二个值
  ```



## 35、unordered_set 的用法

- 基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，**无自动排序功能**。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用`hash`函数对`key`进行映射到不同区域进行保存



## 36、常用的库函数

- ```cpp
  stoi(要转的字符串， 起始位置， 多少进制)//将字符串转换为n进制
  to_string (要转变的数字) //将数字转化为字符串
  substr函数(截取字符串中的某一段)
  pow(x, y)x的y次方
  fabs()绝对值
  memcpy(f1, f2, n)//把f2中的n个字符复制到f1中
  memset(数组名，数组值，要初始化的数组的大小)//数组初始化
  ```



## 37、函数重载的条件

- 感觉哈，参数列表才是决定函数重载的关键
  - 即如果两个函数，名字相同，参数列表相同，唯独返回值不同，是不可以被重载的（想象一下double和int作为两个返回值，这两个都是可以相互转换的，那如果重载了，又如何区分呢？）



## 38、构造函数里面为什么不能调用虚函数



## 39、虚函数为什么不能和缺省参数一起调用
