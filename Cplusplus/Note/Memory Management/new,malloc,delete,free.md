## new 和 delete 的实现原理

- new 的实现：
  - 如果是简单类型，就直接调用 operator new 分配内存
  - 首先调用名为 operator new 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象
  - 接下来运行该类型的一个构造函数，用指定初始化构造对象
  - 最后返回指向新分配并构造后的的对象的指针
- delete 的实现：
  - 首先对指针指向的对象运行适当的析构函数
  - 然后通过调用名为 operator delete 的标准库函数释放该对象所用内存





## new/delete 与 malloc/free 的异同

- 相同点：

  - 都是用于内存的动态申请和释放

- 不同点：

  - 前者是C++运算符（不支持重载），后者是C/C++语言标准库函数（支持覆盖）

  - 前者不需要头文件，后者需要 stdlib.h 头文件

  - new 自动计算要分配的空间大小，malloc 需要手工计算

  - new 是类型安全的（好像是有内部的异常机制），malloc 不是

    - ```cpp
      int *p = new float[2]; //编译错误
      int *p = (int*)malloc(2 * sizeof(double));//编译无错误
      ```

  - malloc 和 free 返回的是 void 类型指针（所以要进行类型转换），new 和 delete 返回的是具体类型指针

  - malloc 和 free 仅仅分配或回收空间，不调用析构或构造函数





# 有了malloc为什么还需要new





# 多次delete

- 经过一次delete之后，指针就变成了悬空指针或者野指针，也就是说它执行的地方是随机的
- 所以如果再一次delete的话，就可能删除了其他进程的重要数据，使得其他进程codedown
- 我认为吧，为了防止意外发生，最好还是在指针被delete之后让他指向nullptr，防止使用者乱用.....



# free如何知道要free多大的空间

- malloc函数的实现是以块分配内存，在被分配的块中包括两部分。第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量；第二部分中存储实际用户数据。而使用malloc分配内存返回的是第二部分用户数据的地址。而块的两个部分在内存中的存储取决有编译器的实现，一般有两种情况，第一种是最常见的，即元数据和用户数据是连续的，存储在连续空间位置。第二种是两部分分开存储。
- 所以如果申请一段数组，访问array[-1]也是可以的