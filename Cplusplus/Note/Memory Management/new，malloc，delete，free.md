# new 和 delete 的实现

- new 的实现：
  - 首先调用名为 operator new 的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象
  - 接下来运行该类型的一个构造函数，用指定初始化构造对象
  - 最后返回指向新分配并构造后的的对象的指针
  - PS：如果是简单类型，就直接调用 operator new 分配内存
- delete 的实现：
  - 首先对指针指向的对象运行适当的析构函数
  - 然后通过调用名为 operator delete 的标准库函数释放该对象所用内存





# new/delete 与 malloc/free 的异同

相同点：

- 都是用于内存的动态申请和释放



不同点：

- 前者是C++运算符（不支持重载），后者是C/C++语言标准库函数（支持覆盖）

- 前者不需要头文件，后者需要 stdlib.h 头文件

- new 自动计算要分配的空间大小，malloc 需要手工计算

- new 是类型安全的（好像是有内部的异常机制），malloc 不是

  - ```cpp
    int *p = new float[2]; //编译错误
    int *p = (int*)malloc(2 * sizeof(double));//编译无错误
    ```

- malloc 和 free 返回的是 void 类型指针（所以要进行类型转换），new 和 delete 返回的是具体类型指针

- malloc 和 free 仅仅分配或回收空间，不调用析构或构造函数（所以要手动构造和析构）

- new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指 对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用

- new是封装了malloc，直接free不会出错（但是这只是释放了内存，没有析构对象）





# 为什么要new和free

- 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数
- 而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc/free
- 所以new/delete是必不可少的





# 多次delete

- 经过一次delete之后，指针就变成了悬空指针或者野指针，也就是说它执行的地方是随机的
- 所以如果再一次delete的话，就可能删除了其他进程的重要数据，使得其他进程codedown
- 我认为吧，为了防止意外发生，最好还是在指针被delete之后让他指向nullptr，防止使用者乱用.....





# free如何知道要free多大的空间

- malloc函数的实现是以块分配内存，在被分配的块中包括两部分。第一部分中存储含有报头的元数据，它其中包含有分配块的大小信息，是一个常量；第二部分中存储实际用户数据。而使用malloc分配内存返回的是第二部分用户数据的地址。而块的两个部分在内存中的存储取决有编译器的实现，一般有两种情况，第一种是最常见的，即元数据和用户数据是连续的，存储在连续空间位置。第二种是两部分分开存储。
- 所以如果申请一段数组，访问array[-1]也是可以的





# free后的内存是返还给操作系统吗

- 不是，被free回收的内存首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回
- 这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc 也会尝试对小块内存进行合并，避免过多的内存碎片







# delete和delete[]的区别

- delete只会调用一次析构函数
- delete[]会调用数组中的每个元素的析构函数
- PS：
  - 其实如果是普通的数组或者是单个变量，都是可以用delete的（为了规范才用[]）（而且我怀疑其实普通的数组和类对象的数组是不一样的构造的...）
  - 但是如果是类对象的数组的话，就不能用delete了，因为只会触发一次析构