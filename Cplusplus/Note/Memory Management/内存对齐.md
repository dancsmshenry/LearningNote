- 定义：现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐



- 尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度



- 如果没有内存对齐的话，那么cpu每次读数据会很麻烦；所以内存对齐的本质是提高内存的读取效率（因为每次都是4个字节或者8个字节的读）
- 没有考虑内存对齐的时候，有些内存是“空着”的，也无法利用，这时候对于一些内存极小的设备来说，就必须要争取利用每一块可能的内存，避免空间浪费



- #pragma pack(n)可以改变对齐系数



规则

- 结构体第一个成员的偏移量为0，以后每个成员相对于结构体首地址的offset都是该成员大小与有效对齐值中较小哪个的整数值，如果有需要编译器会在成员之间加上填充字节
- 结构体的总大小为 有效对齐值的整数倍，如有需要编译器会在最末一个成员之后加上填充字节

规则

- 结构体变量的起始地址能够被其最宽的成员大小整除
- 结构体每个成员相对于起始地址的偏移能够背其自身大小整除，如果不能则在前一个成员后面补充字节
- 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节



- 我的理解
- 如果加在一起小于等于 最大的那个变量大小的字节，就当作该变量个数的字节
- 从上到下这样依次判断



原因：

- 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
- 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问