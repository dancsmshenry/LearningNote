### 2.4 const

- const表示变量是不能改变
- 常量必须要初始化的
- 对于const常量，编译器将在编译过程中把用到该变量的地方都替换成对应的值
- 默认情况下，const对象被设定为仅在文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量







### 2.4.1 const的引用

- 可以把引用绑定到const对象上，就像绑定到其他对象上，即对常量的引用
- 对常量的引用不能被用作修改它绑定的对象
- 原理：const的引用的本质其实是把给到的值生成一个const的临时变量，然后把引用 引用到这个临时变量，这就是为什么不能通过const引用来改变被引用对象



初始化和对const的引用

- 引用的类型必须与其所引用对象的类型一致，但有两个例外：
  - 第一种，初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
- 常量引用能够使用任意表达式作为初始值，是因为编译器先复制一个相同的初始值（临时值， 是常量），接着让常量引用绑定该常量
- 所以，是不能用常量引用来修改被指向的值的



对const的引用可能引用一个并非const的对象

- 必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量未作限定
- 所以，常量引用既可以绑定常量，也可以绑定非常量，但共同点就是不能通过这个引用修改被引用的对象



有关const和引用的总结：

- const引用可以引用非const和const的对象
- 但是，不能通过const引用来修改被引用的对象
  - 原理：因为编译器先复制一个相同的初始值（临时值， 是常量），接着让常量引用绑定该常量











### 2.4.2 指针和const

- 指向常量的指针不能用于改变其所指对象的值
- 要想存放常量对象的地址，只能使用指向常量的指针
- 允许令一个指向常量的指针指向一个非常量对象（但是该指针还是不能修改对象的值）



const指针

- 允许指针本身定为常量，常量指针必须初始化
- 把*放在const关键字之前表明指针是一个常量，即不变的是指针本身的值，而不是指向的那个值
- 有关指针和const的，最行之有效的方法就是从右往左读
  - int *const pr = & p;从右往左读，发现是一个const对象，紧接着发现是一个int *指针，就明白是一个常量指针
  - const int* p2 = &ci;从右往左读，发现是一个指针，紧接着发现const，就明白是一个指针指向了一个常量
- 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型



### 2.4.3 顶层const

- 顶层const：表示指针本身就是一个常量
  - 一般化：顶层const可以表示任意的对象是常量
- 底层const：表示指针所指的对象是一个常量
- 用于声明引用的const都是底层const
- 当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层的const资格
  - 比如说一个int*的，不能指向一个const类型的对象