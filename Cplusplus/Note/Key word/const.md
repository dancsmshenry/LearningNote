# const

- const表示变量是不能改变
- 常量必须要初始化的
- 对于const常量，编译器将在编译过程中把用到该变量的地方都替换成对应的值
  - 可以类比define，它是在预编译的时候换的；这是在编译的时候换的

- 默认情况下，const对象被设定为仅在文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量





# const的引用

- 可以把引用绑定到const对象上，就像绑定到其他对象上，即对常量的引用
- 对常量的引用不能被用作修改它绑定的对象
  - 实现原理：const的引用的本质其实是把给到的值生成一个const的临时变量，然后把引用 引用到这个临时变量
  - 这就是为什么不能通过const引用来改变被引用对象




初始化和对const的引用

- 引用的类型必须与其所引用对象的类型一致，但有两个例外：
  - 第一种，初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
- 常量引用能够使用任意表达式作为初始值，是因为编译器先复制一个相同的初始值（临时值， 是常量），接着让常量引用绑定该常量
- 所以，是不能用常量引用来修改被指向的值的



对const的引用可能引用一个并非const的对象

- 常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量未作限定
- 所以，常量引用既可以绑定常量，也可以绑定非常量，但共同点就是不能通过这个引用修改被引用的对象



总结

- 事实：**因为编译器先复制一个相同的初始值（临时值， 是常量），接着让常量引用绑定该常量**

  - 所以，const引用可以引用非const和const的对象

  - 所以，不能通过const引用来修改被引用的对象
  - 所以，常量引用可以使用任何表达式作为初值





# const的作用

- 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了



- 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为 const



- 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值
- 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数（mutable）
- 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”
- const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员
- 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员
- 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。



- const类型变量可以通过类型转换符const_cast将const类型转换为非const类型
- const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化



- 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响
- 但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的
  - 所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来







# 顶层const和底层const

- 顶层const：表示指针本身就是一个常量（int *const p1）
  - int *const pr = & p;从右往左读，发现是一个const对象，紧接着发现是一个int *指针，就明白是一个常量指针
  - 理解：对象先接触到的是const，所以对象必然是一个const（但此时还不知道是啥对象），再往前看，发现是一个int*，所以指针本身就是一个const
  - 一般化：顶层const可以表示任意的对象是常量
  - 常量指针必须初始化
  - 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型
  - 允许令一个指向常量的指针指向一个非常量对象（但是该指针还是不能修改对象的值）




- 底层const：表示指针所指的对象是一个常量（int const * p1）
  - const int* p2 = &ci;从右往左读，发现是一个指针，紧接着发现const，就明白是一个指针指向了一个常量
  - 理解：对象先接触到*，表示对象是一个指针，而后接触到const，所以是一个指向const int的指针
  - 用于声明引用的const都是底层const
  - 要想存放常量对象的地址，只能使用指向常量的指针
  - 指向常量的指针不能用于改变其所指对象的值（因为是常量）



- 当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层的const资格
  - 比如说一个int*的，不能指向一个const类型的对象







# const全局变量

- cpp和c中的const全局变量都是放在常量区的，因此一定是不可以修改的（所以都是运行的）
- 但是C语言中const全局变量默认是外部链接的，即可以跨文件使用，在一个文件里`const int a = 10`，在另一个文件中可以直接`extern const int a`声明一下即可使用。（多文件编译）
- CPP则默认是内部链接，即作用域限定在本文件内，如果非要跨文件使用则在定义的时候就要用`extern`声明一下来提升作用域。即定义的时候就是`extern const int a = 10`，使用的时候还要声明`extern const int a`（即多文件编译）







# const局部变量

### 在c中

- 实际上，在c里面，const的值还是可以改变的，本质上还是一个变量，只是不可以做为左值存在，也就是不法对该变量进行直接赋值修改该变量（即此时的const变量还是在栈区里面的）

- ```cpp
  #include <stdio.h>
  
  int main() {
      const int i = 1;
      int *p = &i;
      *p = 1022;
      printf("%d\n",i); // 1022
  }
  ```

- ~~所以，由于c这里的是一个伪常量，所以不能用来初始化数据~~（经过我的实验，发现局部变量的const也是可以用来初始化数组的）

- ```cpp
  #include <stdio.h>
  
  int main() {
      const int i1 = 11;
      int m[i1];
  }
  ```





### 在cpp中

- 当碰到用const修饰的变量时，cpp编译器是直接将变量的值和变量的符号对应起来一起存到符号表，所以编译器不会为其分配内存空间

- 每次使用的时候都要去符号表里面去查找

- 但如果遇到要求const变量的地址的时候，这时候还是会为其分配地址（所以如果要操控指针去修改const的变量，其实会复制一个单独的变量出来）

- ```cpp
  void test(){
        const int m_B = 20;
        int *p = (int *) &m_B;
        //int tmp = m_B; int *p = (int *)&tmp;//	相当于这样
        *p = 100;
  }
  ```

- ```cpp
  int main()
  {
      const int i = 0;
      int *j = (int *)&i;
      *j = 1;
      printf("%d,%d", i, *j);
  }
  //	如果是cpp的话，输出的是0,1
  //	如果是c的话，输出得是1,1
  ```

- 

- 总结：在编译的时候如果前面有extern和取地址符 & 时，会为变量分配存储空间



看到的一种理解（无法证明对错）

- 一般的const局部变量（直接用常量初始化的）是不分配内存的，即直接放到符号表中，因此是没办法修改的。
- 但是如果用变量初始化const局部变量的话，即`const int a = b`，这时候不管b是基本数据类型还是自定义数据类型，都会分配内存，即可以通过指针间接修改（cpp的const变量，如果要用指针修改的话，那么就必须要用指针强转，而由此，实际上得到的是一个从符号表复制的来的数据）



- cpp为了兼容c语言，所以给了这个const变量提供地址，但是c语言本身提供的const还是可以被修改，而c++为了严谨就不能修改





# 参考

- https://blog.csdn.net/qq_31858735/article/details/103009281
- https://blog.csdn.net/weixin_36251052/article/details/117074828