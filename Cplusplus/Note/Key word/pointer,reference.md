# pointer

## 指针和引用的区别

- 本质：
  - 指针本质是一个变量（存储的是对象的地址）
  - 引用本质是原变量的别名，和原变量是同一个东西

- 指针可以有多级（存在指向指针的指针），引用只能有一级（不存在引用的引用）
- 声明和初始化
  - 引用声明时必须初始化（引用不能为空），同时初始化后不可以改变指向
  - 指针声明和初始化可以分离（指针可以为空，nullptr，NULL），初始化后可以改变指向
  - PS：变量可以被引用多次，但是引用只能作为一个变量的引用

- 关于sizeof
  - sizeof(指针)为指针的大小
  - sizeof(引用)为所指对象的大小

- 应用上
  - 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以





## 指针和数组的区别

- 数组在内存中是连续存放的，开辟一块连续的内存空间
- 大小
  - p为指针得到的是一个指针变量的字节数
  - p为数组得到的是数组的大小（容量*步长）

- 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用
  - 所以下标访问符其实是一个语法糖，本质上是数组首地址加上里面的值，所以在一些代码里面可以看到-1的下标
  - 而且指针每移动一个单位，实际跨越的内存间隔是指针类型的长度

- 在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率








## 区分指针类型

- ```cpp
  int* p[10];
  //表示指针数组，是一个数组变量，数组内每个元素都是指向int类型的指针变量，数组大小为10
  int (*p)[10];
  //表示数组指针，是一个指针类型的变量，指向的是一个int类型的数组，数组大小为10
  int* p(int);
  //是函数声明，函数名是p，参数是int类型，返回值是int*类型
  int (*p)(int);
  //是函数指针，该指针指向的函数具有int类型参数，返回值是int类型
  const int* p1;
  //是一个指向整形常量的指针，它所指向的值不能修改
  int* const p2;
  //是一个指向整形变量的常量指针，该指针不可以改变指向，但是其指向的量可以被修改
  const int * const p3;
  //是一个指向整型常量的常量指针，不能再指向别的变量，指向的值也不能修改
  ```
  
- 心得：

  - 对于星号和小括号：如果没有小括号，就把星号放到左边；否则如果星号和括号一起，那就是一个指针变量
  - 对于const和星号：从右往左看，依次结合（**区别常量指针和指针常量**）
    - 比如const int* p1;，首先p1是一个整型指针，其次看到const，就表明该指针指向一个const变量
    - 比如int* const p2;，首先p2是一个const类型，其次看到int* ，就表明该指针是一个const的类型
    - 指针常量：是一个指针，解释为指向一个常量的指针，即指向一个只读变量。也就是后面所指明的 int const 和 const int ，都是一个常量，可以写作int const *p或const int *p
    - 常量指针：解释为一个不能改变指向的指针（有点像引用是吧）。指针是常量，所以必须初始化，且初始化过后它的值就不能再改变了，即不能中途改变指向，写作 int* const p



## 指针的相关操作

- ```cpp
  *p++; //	是先取p的值，然后操作完成后，p指针+1
  
  (*p)++; //	是先取p的值，然后p的值+1
  
  *++p; //	是给p指针+1， 然后访问新指针指向的值
  ```







## 野指针

定义

- 访问一个已被销毁或者访问受限的内存区域的指针，不能判断是否为NULL来避免（一般是未经初始化的指针）



产生的原因

- 指针定义时未被初始化（未被初始化的话，会随机指向一个区域，因为任何指针变量的默认值都是随机的，除了static修饰的指针）
- 指针被释放的时候没有置空（没有置空，也会指向随机区域的）
- 指针操作朝野变量作用域（例：返回了指向栈内存的指针或引用，栈的内存在函数结束后会被释放）



危害

- 指针指向的内容无效了，而指针没有被指控，解引用一个非空的无效指针是一个未被定义的行为
- 可能指向一个没用的空间，这时系统不会报错，就相当于掩盖了你的程序错误
- 可能指向一个正在使用的空间，而且这个空间被其他程序使用，导致程序运行出错
- 可能指向不可访问（操作系统不允许访问的敏感地址，例：内核空间），造成触发段错误
- ps：由于栈是反复使用，使用完不擦除的，所以本次在栈上分配到的变量的默认值是上次这个栈空间被使用时余留下来的值
- 背景：内存越界型的错误调试难度通常较高，因为程序通常不再错误发生时崩溃，而是在使用本被覆盖的内存时以一定概率崩溃，通常已经离真正发生错误的地方很远
- ps：用户态进程拿到的指针都是虚拟地址，野指针只会崩溃自己这个进程，不会崩溃别的程序



解决办法

- 初始化指针的时候将其置为nullptr
- 释放指针的时候将其置为nullptr







## 悬垂指针

定义

- 指向已经被释放的自由区内存的指针







# reference

## 引用传参和值传参

### 引用传参的优点

- 在函数内部可以对此参数进行修改
- 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）
  - 类对象一般都是用指针传递的
  - 对栈空间比较敏感的时候用引用

- 在内存中不产生被返回值的副本





### 引用传参的缺点

- 不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁（需要返回局部变量的时候要用指针）
- 不能返回函数内部new分配的内存的引用（例如：被函数返回的引用只是作为一 个 临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释 放，造成memory leak）
- 可以返回类成员的引用，但是最好是const（例如：因为如果其他对象可以获得该属性的非常量的引用，那 么对该属性的单纯赋值就会破坏业务规则的完整性）





### 引用传参的特点

- **被调参数的形式参数也作为局部变量在栈中开辟了内存空间**，但这时存放的是由主调函数放进来的实参变量的地址（可以参考后面的汇编）
- 被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实际变量（根据别名找到主调函数中的本体）
- 所以本质上和传递指针是一样的，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用





## 传参原则

- 如果数据对象很小，如内置数据类型或者小型结构，则按照值传递
- 如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针
- 如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的 时间和空间
- 如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）





## 值传递

- 值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）

- 特点：被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）
- 对于指针传递，本质上是值传递，所传递的是一个地址值
  - 所以函数里面的指针的地址，和原来指针的地址是不一样的
  - 只是它们都指向同一块内存，即它们都存入了相同的地址，但是它们各自本身的地址不同
  - 缺点：容易产生错误且程序的阅读性较差





## 指针传参和引用传参的区别

- 对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量

  - 因为它就相当于别名，能直接修改对象

- 对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量

  - 因为指针传递本质是值传递，可以通过指针取修改别人的值，但是修改不了原来指针中放的地址
  - 所以如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用

- ```cpp
  void func(int** p) {
      *p = new int(10000);
  }
  
  int main() {
      int *p = new int(2);
      func(&p);
      cout << *p << endl;
  }//这样才能改变指针的指向
  
  void func(int* p) {
      p = new int(11111);
  }
  
  int main() {
      int *p = new int(2);
      func(p);
      cout << *p << endl;
  }//这样是改变不了指针的指向的
  ```







## 从编译的角度看引用

- 背景：因时间有限，来不及把汇编系统的学习一遍，所以只能出此下策，以证明引用的本质就是指针，即实际上引用还是要占用部分内存的，即引用只是cpp的一个语法糖，方便用户更加好的使用指针



- ```cpp
  int main() {
  	int i = 23847;
  	int &ky = i; // g++ -S -o test_ref.s test.cpp   
  	// int *kx = &i; // g++ -S -o test_pointer_ref.s test.cpp
  }
  ```

- ```assembly
  	.file	"test.cpp"
  	.text
  	.def	__main;	.scl	2;	.type	32;	.endef
  	.globl	main
  	.def	main;	.scl	2;	.type	32;	.endef
  	.seh_proc	main
  main:
  .LFB0:
  	pushq	%rbp
  	.seh_pushreg	%rbp
  	movq	%rsp, %rbp
  	.seh_setframe	%rbp, 0
  	subq	$48, %rsp
  	.seh_stackalloc	48
  	.seh_endprologue
  	call	__main
  	movl	$23847, -12(%rbp)
  	leaq	-12(%rbp), %rax
  	movq	%rax, -8(%rbp)
  	movl	$0, %eax
  	addq	$48, %rsp
  	popq	%rbp
  	ret
  	.seh_endproc
  	.ident	"GCC: (tdm64-1) 10.3.0"
  ```

- 上述是只有引用的代码得到的汇编代码



- ```cpp
  int main() {
  	int i = 23847;
  	int &ky = i; // g++ -S -o test_ref.s test.cpp   
  	int *kx = &i; // g++ -S -o test_pointer_ref.s test.cpp
  }
  ```

- ```assembly
  	.file	"test.cpp"
  	.text
  	.def	__main;	.scl	2;	.type	32;	.endef
  	.globl	main
  	.def	main;	.scl	2;	.type	32;	.endef
  	.seh_proc	main
  main:
  .LFB0:
  	pushq	%rbp
  	.seh_pushreg	%rbp
  	movq	%rsp, %rbp
  	.seh_setframe	%rbp, 0
  	subq	$64, %rsp
  	.seh_stackalloc	64
  	.seh_endprologue
  	call	__main
  	movl	$23847, -20(%rbp)
  	leaq	-20(%rbp), %rax
  	movq	%rax, -8(%rbp)
  	leaq	-20(%rbp), %rax
  	movq	%rax, -16(%rbp)
  	movl	$0, %eax
  	addq	$64, %rsp
  	popq	%rbp
  	ret
  	.seh_endproc
  	.ident	"GCC: (tdm64-1) 10.3.0"
  ```



简述

- 可以很明显的看到的是，本质上多出的代码（即指针部分的）和引用部分的代码几乎一模一样，只是地址不同而已
- 所以可以证明引用的本质就是指针，语法糖罢了





## 从符号表的角度看引用

- 程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址
- 指针变量在符号表上对应的地址值为指针变量的地址值
- 引用在符号表上对应的地址值为引用对象的地址值
- 符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改







## 引用的优点

- 少一次判空

  - ```cpp
    #include <stddef.h>
    
    void f(int & x, int i)
    {
        x = i;
    }
    
    void g(int * p, int i)
    {
        if (p == NULL) {
            return;
        }
        *p = i;
    }
    ```

- 指针降维（提高代码的可读性）

  - ```cpp
    #include <stdio.h>
    #include <string.h>
    
    void cmp_and_swap_ref(char * & p1, char * & p2)
    {
        if (strcmp(p1, p2) > 0) {
            char * t = p1;
            p1 = p2;
            p2 = t;
        }
    }
    
    void cmp_and_swap_ptr(char ** p1, char ** p2)
    {
        if (strcmp(*p1, *p2) > 0) {
            char * t = *p1;
            *p1 = *p2;
            *p2 = t;
        }
    }
    
    int main()
    {
        char c1[] = "xyz";
        char c2[] = "abc";
    
        char * p1 = c1;
        char * p2 = c2;
        
        cmp_and_swap_ref(p1, p2);
        // cmp_and_swap_ptr(&p1, &p2);
    
        printf("%s\n%s\n", p1, p2);
    }
    ```





## 坑点

- 在类对象中，引用的大小相当于一个指针的大小（所以在我的64位系统中，大小为8）
- 所以我一直觉得引用就类似语法糖..





# 指针的引用

- ```cpp
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      void flatten(TreeNode*& root) {
          if (!root) return ;
          root = new TreeNode(111);// 这种修改是不会修改到原来的树的，说明这种修改，只是将当前的指针指向这个新的节点（无论上面是*还是*&）
          // 我的理解：因为即使传入的是指针的引用，即我们在flatten中用的是传入时的同一个指针，但这种写法依然改变的是当前指针的指向，却没有改变原来地址上存储的数据（换句话说，lc可能是根据具体的数据，而不是间接的通过指针去t）
  
          *root = *std::move(new TreeNode(111));
          //  而这种写法，改变的就是所指向地址存储的数据，所以才会牵一发而动全身
  
          cout << root -> val << endl;
      }
  };
  ```





有关指针和指针的引用

- int *a// 表示传入的是一个指针，即和原指针都指向同一个value，不过这里的指针和原指针是区分开来的

- int * &a; //表示传入的是一个指针的引用，可以理解为就是把原指针给传入了，所以如果在函数里面修改了指向，那么原指针也会被修改
- int** a;// 表示传入的是一个指针，这个指针指向的是一个指向int的指针





# 参考

- https://www.zhihu.com/question/512123383/answer/2316997922
- https://blog.csdn.net/qq_34988341/article/details/106452518