# 作用

没有类的情况

- 隐藏
  - 所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
- 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
  - 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区
  - 在静态数据区，内存中所有的字节默认值都是0x00
- 对于函数内定义的静态变量
  - 始终存在，只进行一次初始化（如果函数不被调用，那么静态变量就不会被调用）
  - 其作用范围与局部变量相同
  - 函数退出后仍然存在，但不能使用

- 保持变量内容的持久
  - 存储在静态数据区的变量会在程序刚开始运行时就完成初始化




有类的情况

- static成员变量：
  - 只与类关联，不与类的对象关联（对类的所有对象只有一份拷贝）
  - 定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static
    - static修饰的变量先于对象存在，如果是在类内初始化，会导致每个对象都包含该静态成员
  - 可以被非static成员函数任意访问
  - 生命周期和整个类一致
- static成员函数：
  - 不具有this指针，无法访问类对象的非static成员变量和非static成员函数，因而只能访问类的static成员变量
  - 不能被声明为const、virtual和volatile
  - 可以被非static成员函数任意访问（只可被类内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；不能被模块外其它函数访问）
- 静态变量不占用类的内存空间





# 静态和非静态的区别

静态成员变量和非静态成员变量

- 生命周期
  - 静态成员变量一直存在
  - 普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束
- 共享方式
  - 静态成员变量是全类共享
  - 普通成员变量是每个对象独享
- 定义位置
  - 普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区
- 初始化位置：普通成员变量在类中初始化；静态成员变量在类外初始化；
- 默认实参：可以使用静态成员变量作为默认实参



静态全局函数和非静态全局函数

- 静态全局函数，作用域只在本源文件中生效；非静态全局函数，作用域却可以在其他的文件中生效







# 静态变量初始化

### 位置

- **静态局部变量和全局变量（包括全局静态变量）一样，数据都存放在全局区域**，所以在主程序之前，编译器已经为其分配好了内存



### 初始化时间

- **在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化**
  - 所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收
  - 所以，在C里面，静态变量初始化不能等于函数的返回值、变量等需要"编译计算"的变量（必须得是常量，即必须得是const类型）
- **在C++中，初始化是在执行相关代码后才会进行初始化**
  - 主要是C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存
  - ~~所以C++标准定为全局或静态对象是有首次用到时才会进行构造~~，并通过atexit()来管理（实操后发现，静态变量的初始化是在main函数执行之前才初始化的）
  - 并且发现，是c++的局部静态变量是在首次使用的时候才会构造（而如果是main函数中的static，那么必定会被使用构造；而其他函数，如果没被使用，就不会被构造）
  - 所以cpp里面，静态变量初始化可以等于函数的返回值，变量等



在静态方法里面创建静态变量，那这个静态变量一开始会初始化吗

- 答不会，参考线程安全的懒汉模式



静态变量是如何实现只被初始化一次的

- 反汇编后发现，是有一个标志用来记录该局部静态变量是否初始化过，而这个标记可以同时保存8个静态变量的初始状态（有点像上锁的意思，同时也保证在多线程的情况下始终只有一个静态变量）
- 通常这个标志出现在最先定义的局部静态变量附近
- 如果已初始化了，就跳过







# 举例

- ```cpp
  #include <iostream>
  #include <cstdio>
  #include <string>
  
  using namespace std;
  
  template <typename T>
  class A
  {
  public:
      static T a1;
  };
  
  template <>
  int A<int>::a1 = 1; //这里前面一定要加上template<>才能运行
  
  int main()
  {
      A<int> a2;
  }
  ```
  
- ```cpp
  #include <iostream>
  
  using namespace std;
  
  template <typename T>
  class Test
  {
  public:
      static int a;
  };
  
  template <>
  int Test<int>::a = 1;
  template <>
  int Test<char>::a = 2;
  int main()
  {
      cout << Test<int>::a << endl; // 1
      cout << Test<char>::a << endl;// 2
      Test<int> obj1, obj2;
      cout << obj1.a << endl; // 1
      cout << obj2.a << endl; // 1
      obj1.a = 10;
      cout << obj1.a << endl; // 10
      cout << obj2.a << endl; // 10
  
      cout << &obj1.a << endl; // 0x601070
      cout << &obj2.a << endl; // 0x601070
  
      Test<char> b1;
      cout << "b1::" << &b1.a << endl; // b1::0x7ff649019014
  
      return 0;
  }
  ```
  
- 事实证明，对于每个静态变量，每个模板类都会为其单独的创建一个静态变量



# 类的静态函数调用

- ```cpp
  #include <iostream>
  
  class B {
  public:
      static void tt() {
          std::cout << "static void tt()" << std::endl;
      }
  };
  
  int main() {
      B::tt();// 必须要用：：来调用
      B.tt(); // error,c
  }
  ```



# 在 c 语言里面的 static

首先在 .h 文件中一般是有 static 函数和变量的定义

然后，static 带来的，其实应该是编译单元之间的隔离性：

- 这里的编译单元说的应该是单个 .c 文件，而换个角度来说就是每个 .c 文件中定义的单个变量，即使将他们合并编译成一个二进制文件，但他们的这个共同名字的变量，都是不能通用的
- 所以隔离性，是指每个 .c 文件之间的



# 参考

- https://www.cnblogs.com/xuxm2007/p/4652944.html
- https://www.cnblogs.com/yilang/p/12106236.html