## 1、指针和引用的区别

- 指针本质是一个变量（存储的是对象的地址），引用本质是原变量的别名
- 指针可以有多级，引用只能有一级
- 指针可以为空，引用不能为空且需要在定义的时候初始化
- 指针在初始化以后可以改变指向，引用在初始化之后不可以再改变
- 关于sizeof：sizeof(指针)为指针的大小，sizeof(引用)为所指对象的大小

## 2、区分一下指针类型

- ```cpp
  int *p[10];
  int (*p)[10];
  int *p(int);
  int (*p)(int);
  const int* p1;
  int* const p2;
  const int * const p3;
  ```

- `int *p[10]`表示指针数组，是一个数组变量，数组内每个元素都是指向int类型的指针变量，数组大小为10

- `int (*p)[10]`表示数组指针，是一个指针类型的变量，指向的是一个int类型的数组，数组大小为10

- `int *p(int)`是函数声明，函数名是p，参数是int类型，返回值是int*类型

- `int (*p)(int)`是函数指针，该指针指向的函数具有int类型参数，返回值是int类型

- `const int* p1`是一个指向整形常量的指针，它所指向的值不能修改

- `int* const p2`是一个指向整形变量的常量指针，该指针不可以改变指向，但是其指向的量可以被修改

- `const int* const p3`是一个指向整型常量的常量指针，不能再指向别的变量，指向的值也不能修改

- tips：

  - 看的时候，如果没有小括号，就把星号放到左边去看
  - 观察 const ， const 右边是类型，那该值（可以理解为是指针指向的值，也可以就是这个值）就是常量；如果是指针变量，那指针本身就是常量



## 8、左值引用和右值引用的区别

- 无论左值引用还是右值引用，其返回的结果都是左值
- 左值引用的对象是变量，右值引用的对象是常量





## 4、指针常量和常量指针的区别

- 指针常量是一个指针，解释为指向一个常量的指针，即指向一个只读变量。也就是后面所指明的 int const 和 const int ，都是一个常量，可以写作int const *p或const int *p
- 常量指针，解释为一个不能改变指向的指针（有点像引用是吧）。指针是常量，所以必须初始化，且初始化过后它的值就不能再改变了，即不能中途改变指向，写作 int* const p
- 所以区别重点还是要看星号的位置XD

- - 

## 6、野指针

野指针的定义

- 野指针：访问一个已被销毁或者访问受限的内存区域的指针，不能判断是否为NULL来避免（一般是未经初始化的指针）
- 悬垂指针：指向已经被释放的自由区内存的指针



野指针产生的原因

- 指针定义时未被初始化（未被初始化的话，会随机指向一个区域，因为任何指针变量的默认值都是随机的，除了static修饰的指针）
- 指针被释放的时候没有置空（没有置空，也会指向随机区域的）
- 指针操作朝野变量作用域（例：返回了指向栈内存的指针或引用，栈的内存在函数结束后会被释放）



野指针的危害

- 指针指向的内容无效了，而指针没有被指控，解引用一个非空的无效指针是一个未被定义的行为
- 可能指向一个没用的空间，这时系统不会报错，就相当于掩盖了你的程序错误
- 可能指向一个正在使用的空间，而且这个空间被其他程序使用，导致程序运行出错
- 可能指向不可访问（操作系统不允许访问的敏感地址，例：内核空间），造成触发段错误
- ps：由于栈是反复使用，使用完不擦除的，所以本次在栈上分配到的变量的默认值是上次这个栈空间被使用时余留下来的值
- 背景：内存越界型的错误调试难度通常较高，因为程序通常不再错误发生时崩溃，而是在使用本被覆盖的内存时以一定概率崩溃，通常已经离真正发生错误的地方很远
- ps：用户态进程拿到的指针都是虚拟地址，野指针智慧崩溃自己，不会崩溃别的程序



解决办法

- 初始化指针的时候将其置为nullptr
- 释放指针的时候将其置为nullptr
- ps：在cpp里面不要写NULL，参考modern effective cpp；在c里面写**NULL**

- 

https://blog.csdn.net/qq_34988341/article/details/106452518