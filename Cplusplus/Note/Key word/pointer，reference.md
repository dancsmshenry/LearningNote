# 指针和引用的区别

- 本质：
  - 指针本质是一个变量（存储的是对象的地址）
  - 引用本质是原变量的别名，和原变量是同一个东西

- 指针可以有多级（存在指向指针的指针），引用只能有一级（不存在引用的引用）
- 声明和初始化
  - 引用声明时必须初始化（引用不能为空），同时初始化后不可以改变指向
  - 指针声明和初始化可以分离（指针可以为空，nullptr，NULL），初始化后可以改变指向
  - PS：变量可以被引用多次，但是引用只能作为一个变量的引用

- 关于sizeof
  - sizeof(指针)为指针的大小
  - sizeof(引用)为所指对象的大小

- 应用上
  - 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以





# 数组和指针的区别

- 数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数 组大小：sizeof(数组名)/sizeof(数组元素数据类型)；
- 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节 数，而不是p 所指的内存容量
- 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式 中的数组元素引用转换为指针加偏移量的引用
- 在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过 去是数组的首地址而不是整个数组，能够提高效率
- 在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素 的地址是固定的，指针的原地址就不是固定的






# 区分指针类型

- ```cpp
  int* p[10];
  //表示指针数组，是一个数组变量，数组内每个元素都是指向int类型的指针变量，数组大小为10
  int (*p)[10];
  //表示数组指针，是一个指针类型的变量，指向的是一个int类型的数组，数组大小为10
  int* p(int);
  //是函数声明，函数名是p，参数是int类型，返回值是int*类型
  int (*p)(int);
  //是函数指针，该指针指向的函数具有int类型参数，返回值是int类型
  const int* p1;
  //是一个指向整形常量的指针，它所指向的值不能修改
  int* const p2;
  //是一个指向整形变量的常量指针，该指针不可以改变指向，但是其指向的量可以被修改
  const int * const p3;
  //是一个指向整型常量的常量指针，不能再指向别的变量，指向的值也不能修改
  ```
  
- 心得：

  - 对于星号和小括号：如果没有小括号，就把星号放到左边；否则如果星号和括号一起，那就是一个指针变量
  - 对于const和星号：从右往左看，依次结合（**区别常量指针和指针常量**）
    - 比如const int* p1;，首先p1是一个整型指针，其次看到const，就表明该指针指向一个const变量
    - 比如int* const p2;，首先p2是一个const类型，其次看到int* ，就表明该指针是一个const的类型
    - 指针常量：是一个指针，解释为指向一个常量的指针，即指向一个只读变量。也就是后面所指明的 int const 和 const int ，都是一个常量，可以写作int const *p或const int *p
    - 常量指针：解释为一个不能改变指向的指针（有点像引用是吧）。指针是常量，所以必须初始化，且初始化过后它的值就不能再改变了，即不能中途改变指向，写作 int* const p





# 指针和引用的使用规范

- 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏
- 而返回局部变量的引用是没有意义的 对栈空间大小比较敏感（比如递归）的时候使用引用
- 使用引用传递不需要创建临时变量，开销要更小；类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式





# 指针的移动

- 指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运 算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险
- 指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转换成10进制计算，计算结果除以类型长度得结果





# 野指针

定义

- 访问一个已被销毁或者访问受限的内存区域的指针，不能判断是否为NULL来避免（一般是未经初始化的指针）



产生的原因

- 指针定义时未被初始化（未被初始化的话，会随机指向一个区域，因为任何指针变量的默认值都是随机的，除了static修饰的指针）
- 指针被释放的时候没有置空（没有置空，也会指向随机区域的）
- 指针操作朝野变量作用域（例：返回了指向栈内存的指针或引用，栈的内存在函数结束后会被释放）



危害

- 指针指向的内容无效了，而指针没有被指控，解引用一个非空的无效指针是一个未被定义的行为
- 可能指向一个没用的空间，这时系统不会报错，就相当于掩盖了你的程序错误
- 可能指向一个正在使用的空间，而且这个空间被其他程序使用，导致程序运行出错
- 可能指向不可访问（操作系统不允许访问的敏感地址，例：内核空间），造成触发段错误
- ps：由于栈是反复使用，使用完不擦除的，所以本次在栈上分配到的变量的默认值是上次这个栈空间被使用时余留下来的值
- 背景：内存越界型的错误调试难度通常较高，因为程序通常不再错误发生时崩溃，而是在使用本被覆盖的内存时以一定概率崩溃，通常已经离真正发生错误的地方很远
- ps：用户态进程拿到的指针都是虚拟地址，野指针只会崩溃自己，不会崩溃别的程序



解决办法

- 初始化指针的时候将其置为nullptr
- 释放指针的时候将其置为nullptr
- ps：在cpp里面不要写NULL，参考modern effective cpp；在c里面写**NULL**

- https://blog.csdn.net/qq_34988341/article/details/106452518





# 悬垂指针

定义

- 指向已经被释放的自由区内存的指针







# 引用传参和值传参

### 引用传参的优点

- 在函数内部可以对此参数进行修改
- 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）
- 在内存中不产生被返回值的副本





### 引用传参的缺点

- 不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁
- 不能返回函数内部new分配的内存的引用（例如：被函数返回的引用只是作为一 个 临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释 放，造成memory leak）
- 可以返回类成员的引用，但是最好是const（例如：因为如果其他对象可以获得该属性的非常量的引用，那 么对该属性的单纯赋值就会破坏业务规则的完整性）





### 引用传参的特点

- **被调参数的形式参数也作为局部变量在栈中开辟了内存空间**，但这时存放的是由主调函数放进来的实参变量的地址
- 被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实际变量（根据别名找到主调函数中的本体）





### 传递引用和传递指针是一样的

- 这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中 对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作





### 使用指针会降低代码的可读性

- 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配 存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差





### 传参原则

- 如果数据对象很小，如内置数据类型或者小型结构，则按照值传递
- 如果数据对象是数组，则使用指针（唯一的选择），并且指针声明为指向const的指针
- 如果数据对象是较大的结构，则使用const指针或者引用，已提高程序的效率。这样可以节省结构所需的 时间和空间
- 如果数据对象是类对象，则使用const引用（传递类对象参数的标准方式是按照引用传递）





### 值传递

- 指针传递本质上是值传递，所传递的是一个地址值（所以函数里面的指针的地址，和原来指针的地址是不一样的；只是它们都指向同一块内存罢了）
- 被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值





### 指针传递

- 本质是值传递，传递的是一个地址值
- 值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主 调函数传递进来的实参值，从而形成了实参的一个副本（替身）
- 值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参 变量的值（形参指针变了，实参指针不会变）





### 引用和指针都是在栈上开辟了空间的

-  引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的 是由主调函数放进来的实参变量的地址
- 被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实 参变量（根据别名找到主调函数中的本体）
- 因此，被调函数对形参的任何操作都会影响主调函数中的实参变量





### 引用传递和指针传递是不同的

- 虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引 用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量

- 而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量

- 如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用

- ```cpp
  void func(int** p) {
      *p = new int(10000);
  }
  
  int main() {
      int *p = new int(2);
      func(&p);
      cout << *p << endl;
  }//这样才能改变指针的指向
  
  void func(int* p) {
      p = new int(11111);
  }
  
  int main() {
      int *p = new int(2);
      func(p);
      cout << *p << endl;
  }//这样是改变不了指针的指向的
  ```





### 从编译的角度来说

- 程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址
- 指针变量在符号表上对应的地址值为指针变量的地址值
- 而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）
- 符号表生成之后不能修改，因此指针可以改变其之下给你的对象（指针变量中的值可以修改），而引用对象不可修改





# 从汇编的角度看引用

- ```cpp
  9: int x = 1;
  00401048 mov dword ptr [ebp-4],1
  10: int &b = x;
  0040104F lea eax,[ebp-4]
  00401052 mov dword ptr [ebp-8],eax
  ```

- x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低

- lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器

- mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址

- ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样 的吗？所以从汇编层次来看，的确引用是通过指针来实现的