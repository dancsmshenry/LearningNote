# 背景

- 为什么cpp中会出现类型转化







# static_cast

- 明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换 （派⽣类指针->基类指针）安全，下⾏转换（基类指针->派⽣类指针） 不安全，所以主要执⾏⾮多态的转换操作
- 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，也不能用于不同类型的引用之间的转化，这些事风险比较高的转换
- 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安 全的 
- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人 员来保证
- 把空指针转换成目标类型的空指针 
- 把任何类型的表达式转换成void类型
- PS：static_cast不能转换掉const或volatile，或者 __unaligned属性
- 比起c语言中的强制转换好在哪里
  - 更加安全
  - 更加直接明显，能够一眼看出是什么类型转换成什么类型








# dynamic_cast

- 专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全 的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题
- 有类型检查，基类转向派生类比较安全，但是派生类转向基类则不安全
- 如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用
- dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换 是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的 指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一 个派生类对象） 
- dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换 
- 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的 
- 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全
- 如果下行转换不安全的话，其会返回空指针，这样在进行操作的时候可以预先判断







# reinterpret_cast

- 不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解释，依赖具体的平台，可移植性差

- 可以将整形转换为指针，也可以把指针转换为数组；可以在指针和引⽤ 之间进⾏肆⽆忌惮的转换

- ```cpp
  reinterpret_cast<type-id>;
  //type-id必须是一个指针、引用、算术类型、函数指针或者成员指针，用于类型之间进行强制转换
  ```







# const_cast

- 专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符
- 用来修饰类型的const或volatile属性
- 常量指针被转化成非常量的指针，并且仍然指向原来的对象
- 常量引用被转换成非常量的引用，并且仍然指向原来的对象 
- const_cast一般用于修改底指针。如const char *p形式







# 参考

https://zhuanlan.zhihu.com/p/368267441