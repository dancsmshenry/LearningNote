# 重载

- 重载，是指同一访问区内被声明的几个具有不同参数列表的同名函数

- 感觉哈，参数列表才是决定函数重载的关键
  - 即如果两个函数，名字相同，参数列表相同，唯独返回值不同，是不可以被重载的（想象一下double和int作为两个返回值，这两个都是可以相互转换的，那如果重载了，又如何区分呢？）
  
- 定义：指在同一范围定义中的同名成员函数才存在重载关系

- 特点：
  - 函数名相同，参数类型和数目有所不同
  - 不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数
  - 重载和函数成员是否是虚函数无关（就是说不能因为它是virtual函数，就可以函数名，参数类型和数目都相同）
  - 总结，只要参数类型或参数个数不同，就可以达到一般程度的重载；即不可以用返回值来区别
  
- 函数的重载有很多种情况的

- ```cpp
  void test(int i) {
      cout << "int test in one" << endl;
  }
  
  void test(int i, int) { // 这也算一种c
      cout << "int test in two" << endl;
  }
  
  void test(double i) {
      cout << "double test" << endl;
  }
  
  class A {
      void test(int i) const {} //const才可以用 可以看作是 void test(A *this, int i) {}
      void test(int i) {} // 非const才能用 void test(const A *this, int i) {}
      
      void test1(int i) & {} // 左值才能用
      void test1(int i) && {} // 右值才能用
      
      void test2(int i) {} // 只有i不是const的时候调用
      void test2(const int i) {} // i为const的时候调用
      // PS：如果只有其中一个的话，那么无论i是不是const都会调用
  };
  ```
  
- 






# 重写

- 也叫做覆盖，override
- 定义：是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数
- 参数个数、参数类型、返回值类型都要和基类的虚函数相同

- 重写，派生类中重新定义父类中除了函数体外完全相同的虚函数
  - 被重写的函数不能是 static ，一定要是虚函数，且其他部分也一定要相同
  - 重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的





# 重定义

- 也叫做隐藏，指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数

- 重定义（隐藏），派生类重新定义父类中相同名字的非 virtual 函数
  - 参数列表，返回类型都可以不同
  
- 举例

  - 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一 个类中

  - ```cpp
    //父类
    class A
    {
    public:
        virtual void fun(int a)
        {
            cout << "A中的fun函数" << endl;
        }
    };
    //子类
    class B : public A
    {
    public:
        //隐藏父类的fun函数
        virtual void fun(char *a)
        {
            cout << "A中的fun函数" << endl;
        }
    };
    int main()
    {
        B b;
        b.fun(2);    //报错，调用的是B中的fun函数，参数类型不对
        b.A::fun(2); //调用A中fun函数
        return 0;
    }
    ```

  - 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数

  - ```cpp
    //父类
    class A
    {
    public:
        void fun(int a)
        {
            cout << "A中的fun函数" << endl;
        }
    };
    //子类
    class B : public A
    {
    public:
        //隐藏父类的fun函数
        void fun(int a)
        {
            cout << "B中的fun函数" << endl;
        }
    };
    int main()
    {
        B b;
        b.fun(2);    //调用的是B中的fun函数
        b.A::fun(2); //调用A中fun函数
        return 0;
    }
    ```

  - 

