# 重载

- 定义：指在同一范围定义中的同名成员函数才存在重载关系（同一访问区内被声明的几个具有不同参数列表的同名函数）

- 特点：
  - 函数名相同，参数类型和数目有所不同
  - 不会出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数（想象一下double和int作为两个返回值，这两个都是可以相互转换的，那如果重载了，又如何区分呢？）
  - 重载和函数成员是否是虚函数无关（虚函数没有重载，只有重写；如果重新写一个的话和虚函数一样的，会报错；但是如果两个都虚函数的话，就可以重载）
  - 总结，只要参数类型或参数个数不同，就可以达到一般程度的重载（深一点的需要const和&）；不可以用返回值来区别
  - 注意，如果有重载了的函数，比如说比原来多了一个参数，但是这个参数又有默认值，这时就会重载失败（不用就可以，用的话就会过不了编译）
  
- ```cpp
  void test(int i) {
      cout << "int test in one" << endl;
  }
  
  void test(int i, int) { // 这也算一种重载，后面放的int要加上但是不用
      cout << "int test in two" << endl;
  }
  
  void test(double i) {
      cout << "double test" << endl;
  }
  
  class A {
      void test(int i) const {} //const才可以用 可以看作是 void test(A *this, int i) {}
      void test(int i) {} // 非const才能用 void test(const A *this, int i) {}
      
      void test1(int i) & {} // 左值才能用
      void test1(int i) && {} // 右值才能用
      
      void test2(int i) {} // 只有i不是const的时候调用
      void test2(const int i) {} // i为const的时候调用
      // PS：如果只有其中一个的话，那么无论i是不是const都会调用当前的函数
  };
  ```






# 重写

- 又叫做覆盖（override），是指在派生类中覆盖基类中的同名函数虚函数
- 参数个数、参数类型、返回值类型都要和基类的虚函数相同
- 派生类中重新定义父类中除了函数体外完全相同的virutal函数
  - 被重写的函数不能是 static ，一定要是虚函数，且其他部分也一定要相同
  - 重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的





# 重定义

- 又叫做隐藏，指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数

- 派生类重新定义父类中相同名字的非 virtual 函数
  - 参数列表，返回类型都可以不同，只要名字相同
  
- 举例

  - 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中

  - ```cpp
    //父类
    class A
    {
    public:
        virtual void fun(int a)
        {
            cout << "A中的fun函数" << endl;
        }
    };
    //子类
    class B : public A
    {
    public:
        //隐藏父类的fun函数
        virtual void fun(char *a)
        {
            cout << "A中的fun函数" << endl;
        }
    };
    int main()
    {
        B b;
        b.fun(2);    //报错，调用的是B中的fun函数，参数类型不对
        b.A::fun(2); //调用A中fun函数
        return 0;
    }
    ```

  - 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数

  - ```cpp
    //父类
    class A
    {
    public:
        void fun(int a)
        {
            cout << "A中的fun函数" << endl;
        }
    };
    //子类
    class B : public A
    {
    public:
        //隐藏父类的fun函数
        void fun(int a)
        {
            cout << "B中的fun函数" << endl;
        }
    };
    int main()
    {
        B b;
        b.fun(2);    //调用的是B中的fun函数
        b.A::fun(2); //调用A中fun函数
        return 0;
    }
    ```
