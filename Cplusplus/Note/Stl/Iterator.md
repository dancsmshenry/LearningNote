# STL中迭代器失效的情况有哪些

以vector为例： 插入元素： 1、尾后插入：size < capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时， 所有迭代器均失效（需要重新分配空间）。 2、中间插入：中间插入：size < capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size ==  capacity时，所有迭代器均失效



删除元素： 尾后删除：只有尾迭代失效。 中间删除：删除位置之后所有迭代失效。 deque 和 vector 的情况类似,  而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;  map/set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);  unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效





# 有了指针为什么还要迭代器

- 迭代器不是指针，是类模板，表现的像指针，他是模拟了指针的一些功能，重载了指针的一些操作
- 返回的也是对象的引用
- Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果
- 背景：编程中会用到各种各样的容器，这些容器的底层实现不同，所以它们进行遍历的方法也是不同的，这不利于代码的重用
- 范围上：指针也是迭代器的一种
- 功能上：迭代器有着比指针更细的划分并对应能力不同的功能（迭代器重载了很多的运算符）
- 行为上：迭代器用法上更加统一良好（不怕越界，可以使用begin和end）





# 迭代器的注意事项

- for each容器的时候是基于迭代器的，如果一边遍历一遍insert元素的话，就可能造成容器扩容，间接导致失效
- 例如unordered_set在添加元素的时候，如果容量达到上限的话，就会使得迭代器失效



https://zhuanlan.zhihu.com/p/352606819