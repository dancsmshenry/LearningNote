# 成员函数指针

先看一个demo

- ```cpp
  #include <iostream>
  #include <string.h>
  
  struct Foo { 
    Foo() =default;
  
    void just_for_test() {  }
  
    char buffer[32];
  };
  
  int main(int argc, char const* argv[]) {
  
    std::cout << sizeof(&main) << std::endl;               // 普通函数指针
    std::cout << sizeof(int*) << std::endl;                // int* 类型指针
    std::cout << sizeof(Foo*) << std::endl;                // Foo* 指针
    std::cout << sizeof(&Foo::just_for_test) << std::endl; // 成员函数指针
  }
  
  /*
  8
  8
  8
  16
  */
  ```

- 发现成员函数的指针大小为16字节



分析

- cout有关于void* 重载的版本，理论上说应该是要调用那个版本的函数的，但是没有调用到，说明函数指针void(Foo::* )()是无法转换为void*的

- ```cpp
  // 证明一下
  int main(int argc, char const* argv[]) {
    std::cout<<std::boolalpha;
    std::cout<< std::is_pointer<decltype(&Foo::just_for_test)>::value << std::endl;
  }
  // false
  ```

- 更加验证了所提供的成员函数指针不是传统的指针类型

- 为什么函数指针不是传统意义上的指针

  - 试想一个情景，有三个类，其中基类是`Base_1`、`Base_2`，子类`Derived`多继承`Base_1`、`Base_2`，那么当子类 `Derived` 对象调用基类的成员函数时，编译器怎么判断这个成员函数是属于哪个基类的呢，`Base_1` or `Base_2`？
  - 还有一个背景，就是成员函数的调用，不仅仅要知道成员对象的地址，还要知道成员函数对象的地址，从而让this指针指向
  - 所以，cpp的解决办法就是，封装一遍函数指针，即所谓的“函数指针”包含了两个部分，第一个部分是会转换成合适的函数指针类型，指向了