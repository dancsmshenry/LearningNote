# 移动构造函数

- 移动构造函数的参数是一个右值或者将亡值的引用
- 也就是说只用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数
- move语句将一个左值变为将亡值





# 有哪几种构造函数

- 默认构造函数
- 初始化构造函数（带参数的）
- 拷贝构造函数
- 移动构造函数（move和右值引用，也叫做转移构造函数）
- 委托构造函数（就是在参数列表里面调用别的构造函数.........）
- 转换构造函数（形参时一个其他类型的变量）



# 拷贝构造函数的参数为什么必须用引用

- 如果不是引用，是值传参的话，那就会陷入递归的情况





# 一个派生类构造函数的执行顺序

- 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）
- 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）
- 类类型的成员对象的构造函数（按照初始化顺序）
- 派生类自己的构造函数





# 为什么构造函数不能作为虚函数

- 角度1：
  - 背景：虚函数的存在是因为编译期间没法确定具体调用对象，才会有虚函数，虚函数表这么个东西
  - c++在编译期间就能确定你要创建的对象的具体类型，而这个具体类型包含了什么，继承了什么在编译期间也是明确的，所以要构造什么也都是明确的，根本没必要存在虚构造函数
- 角度2：
  - 构造函数的一个作用就是将虚函数指针指向虚函数表，因此在指向虚函数表之前，虚函数的功能是不存在的
- 角度3：
  - 虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误





# 构造函数里面可以调用虚函数吗

- 可以在构造函数中调用虚函数，只是不符合预期目标（https://blog.csdn.net/songchuwang1868/article/details/96481853），即虚函数在构造函数里面“不起作用”
- 可以这样理解：在构造函数里面，调用的函数都是静态绑定的，就不会走虚函数表





# 什么时候调用拷贝构造函数

- 用类的一个实例化对象去初始化另一个对象的时候
- 函数的参数是类的对象时（非引用传递） （类对象作为函数的参数且并非引用传递的时候）
- 函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优 化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数
  - g++下不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不 会发生拷贝构造函数（不过我记得gcc关闭优化后，还是会调用拷贝构造函数）
  - 即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式 都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式 则不发生拷贝构造函数



# 拷贝构造函数调用的时机

- 函数以值传参的形式时
- 函数以值形式作为返回值时（返回局部对象时）
- 以已有的class构造对象时



# 构造函数的调用顺序

- 先调用父类的，再调用成员类的，最后调用自己的

- ```cpp
  #include <iostream>
  #include <vector>
  #include <stack>
  #include <deque>
  
  class Test {
  public:
      Test() {std::cout << "Test" << std::endl;}
      ~Test() {std::cout << "~Test" << std::endl;}
      Test(const Test &p) {std::cout << "Test copy" << std::endl;}
      Test(const Test &&p) {std::cout << "Test move" << std::endl;}
      Test(int age) {std::cout << "Test age" << std::endl;}
  };
  
  class A{
  public:
      A() {std::cout << "A()" << std::endl;}
      ~A() {std::cout << "~A()" << std::endl;}
  };
  
  class C{
  public:
      C() {std::cout << "C()" << std::endl;}
      ~C() {std::cout << "~C()" << std::endl;}
  };
  
  class B: public A{
  public:
      C c1;
      B() {std::cout << "B()" << std::endl;}
      ~B() {std::cout << "~B()" << std::endl;}
  };
  
  int main() {
      B b1;
  }
  ```