# 类成员初始化

- 赋值初始化：通过函数体内进行赋值初始化
- 列表初始化：在冒号后使用初始化列表初始化
- 区别：
  - 列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)
  - 那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行





# 一个派生类构造函数的执行顺序

- 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）
- 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）
- 类类型的成员对象的构造函数（按照初始化顺序）
- 派生类自己的构造函数





# 类如何实现只能静态分配和只能动态分配

- 背景：
  - 静态创建：静态建立一个类对象，就是由编译器为对象在栈空间中分配内存
  - 动态创建：A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。 这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象
- 前者：把new和delete运算符重载为privated属性（只有使用new运算符，对象才会被创建在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，即把new运算符设为私有）
- 后者：把构造、析构函数设为protected属性，再用子类动态创建





# 继承下对象的转换

- 向上类型转换
  - 将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向 上类型转换是安全的
- 向下类型转换
  - 将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一 个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动 态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换
  - 因为父子类的结构不一样，可能子类有多个虚函数指针，强转导致数据出错





# 空类会提供的函数

- 析构函数
- 拷贝构造函数
- 缺省构造函数
- 赋值运算符





# 如何阻止类被拷贝

- 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用
- 但是，类的成员函数和friend函数还是可以调用private函数，并且如果这个private函数只声明不定义，则会产生链接错误
- 针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成 private，那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作





# 如何阻止类被实例化

- 将类定义为抽象基类或者将构造函数声明为private





# 如何设计一个类计算子类的个数

- 为类设计一个static静态变量count作为计数器
- 类定义结束后初始化count
- 对于默认构造函数，拷贝构造函数，复制构造函数，在进行上述函数时进行count+1操作
- 在析构函数中对count进行-1





# 为什么析构函数要是虚函数

- 如果是父类指针指向子类对象的话，实际上会发生指针偏移的情况，也就是说父类指针会指向子类中属于父类的那一部分
- 对于一般的非虚函数，我们都是静态绑定的，即编译的时候就知道要调用谁，即如果是父类指针指向子类对象，那么析构的时候默认调用的就是父类的析构函数
- 而对于虚函数，我们是执行的时候才知道到底要执行谁的（即动态绑定）；同时如果父类的析构函数是虚函数，那么子类的也都是虚函数
- 所以即使我们是一个父类指针，只要析构是虚函数，那么就会动态绑定到正确的对象上面
- 所以析构函数如果不是虚函数，就会导致析构不完全
- 角度2：
  - 是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调⽤基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏
  - 如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构函数，成功释放内存
  - 说白了，就是为了解决多态造成的一个问题（指针使用不当导致内存泄漏）





# 为什么构造函数不能作为虚函数

- 角度1：
  - 背景：虚函数的存在是因为编译期间没法确定具体调用对象，才会有虚函数，虚函数表这么个东西
  - c++在编译期间就能确定你要创建的对象的具体类型，而这个具体类型包含了什么，继承了什么在编译期间也是明确的，所以要构造什么也都是明确的，根本没必要存在虚构造函数
- 角度2：
  - 构造函数的一个作用就是将虚函数指针指向虚函数表，因此在指向虚函数表之前，虚函数的功能是不存在的
- 角度3：
  - 虚函数需要依赖对象中指向类的虚函数表的指针，而这个指针是在构造函数中初始化的(这个工作是编译器做的，对程序员来说是透明的)，如果构造函数是虚函数的话，那么在调用构造函数的时候，而此时虚函数表指针并未初始化完成，这就会引起错误





# 构造函数里面可以调用虚函数吗

- 可以在构造函数中调用虚函数，只是不符合预期目标（https://blog.csdn.net/songchuwang1868/article/details/96481853），即虚函数在构造函数里面“不起作用”
- 可以这样理解：在构造函数里面，调用的函数都是静态绑定的，就不会走虚函数表





# 什么时候会调用拷贝构造函数

- 用类的一个实例化对象去初始化另一个对象
- 类对象作为函数的参数且并非引用传递的时候
- 函数的返回值是函数体内局部对象的类的对象时，此时虽然发生 NRV 优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数
  - 在linux gcc下不会发生拷贝构造函数调用，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数
  - 不过我记得gcc关闭优化后，还是会调用拷贝构造函数





# 什么时候调用拷贝构造函数

- 用类的一个实例化对象去初始化另一个对象的时候
- 函数的参数是类的对象时（非引用传递） 
- 函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优 化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数
  - g++下不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不 会发生拷贝构造函数
  - 即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式 都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式 则不发生拷贝构造函数。





# 虚函数为什么不能和缺省参数一起调用

# 多态是如何实现的

- 多态是面向对象的一个基本属性，包括静态多态（编译阶段）和动态多态（运行阶段），静态多态主要是指函数参数不同产生的多态性，是在编译阶段可以识别的一种多态机制，而运行时多态则主要用于基类指针指向派生类对象时，可以通过基类指针直接调用派生类的对象函数，当然这种多态是通过虚函数实现的
- 多态分为静态多态（函数重载）和动态多态（虚函数指针）

# 对虚函数表的理解

- 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什 么。 所以必须定义而非声明。

- 多态只能适用于虚函数

  - 即如果有一个父类的指针指向子类，然后调用两个类都有的那个同名的虚函数，那么这就叫做多态，就会发生调用子类函数的情况
  - 但是，如果是调用两个类都有的同名的一个函数（非虚函数），那么会直接调用到父类的那个函数那里

- 对于一个多态的小bug

  - 如果父类的virtual函数设为了private的话，那就无法使用多态了（代码测验过）

- 能说一下虚继承的底层实现吗？或者多态（虚函数表）的底层实现也可以

- A继承自父类B和C，如果使用B的指针ptr1和C的指针ptr2同时指向一个A对象，则ptr1和ptr2的地址是否一致？

- B是父类，派生出A，B中有虚函数f并被A重写，使用B的指针指向A对象，则： 若B的构造函数中调用f则调用A的f还是B的f以及为什么； 如果B中有成员函数g，g中调用了f，而B的构造函数调用了g，则是调用了谁的f以及为什么

- 如何解释下列代码

  - ```cpp
    class A{
        public:
            A(){}
            A(A &a){cout << "A &a" << endl;}
            A(const A &a){cout << "const A &a" << endl;}
    };
    
    int main(){
        const A a;
        A a1(a);//调用A(const A &a){cout << "const A &a" << endl;}
        
        A a;
        A a2(a);//调用A(A &a){cout << "A &a" << endl;}
    }
    ```

  - 是否可以参照侯捷之前说的，如果两个函数const版本和非const版本同时存在，const只能调用const的版本，非const版本只能调用非const的版本呢？