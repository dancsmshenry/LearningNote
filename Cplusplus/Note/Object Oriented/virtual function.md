# 虚函数为什么慢

- 和虚函数表有些许关系
- 虚函数其实最主要的性能开销在于它阻碍了编译器内联函数和各种函数级别的优化，导致性能开销较大
- 在普通函数中log(10)会被优化掉，它就只会被计算一次，而如果使用虚函数，log(10)不会被编译器优化，它就会被计算多次
- 如果代码中使用了更多的虚函数，编译器能优化的代码就越少，性能就越低
- 简而言之，就是虚函数阻止了编译器对函数的优化





# 对虚函数表的理解

- 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什 么。 所以必须定义而非声明。

- 多态只能适用于虚函数

  - 即如果有一个父类的指针指向子类，然后调用两个类都有的那个同名的虚函数，那么这就叫做多态，就会发生调用子类函数的情况
  - 但是，如果是调用两个类都有的同名的一个函数（非虚函数），那么会直接调用到父类的那个函数那里

- 对于一个多态的小bug

  - 如果父类的virtual函数设为了private的话，那就无法使用多态了（代码测验过）

- 能说一下虚继承的底层实现吗？或者多态（虚函数表）的底层实现也可以

- A继承自父类B和C，如果使用B的指针ptr1和C的指针ptr2同时指向一个A对象，则ptr1和ptr2的地址是否一致？

- B是父类，派生出A，B中有虚函数f并被A重写，使用B的指针指向A对象，则： 若B的构造函数中调用f则调用A的f还是B的f以及为什么； 如果B中有成员函数g，g中调用了f，而B的构造函数调用了g，则是调用了谁的f以及为什么

- 如何解释下列代码

  - ```cpp
    class A{
        public:
            A(){}
            A(A &a){cout << "A &a" << endl;}
            A(const A &a){cout << "const A &a" << endl;}
    };
    
    int main(){
        const A a;
        A a1(a);//调用A(const A &a){cout << "const A &a" << endl;}
        
        A a;
        A a2(a);//调用A(A &a){cout << "A &a" << endl;}
    }
    ```

  - 是否可以参照侯捷之前说的，如果两个函数const版本和非const版本同时存在，const只能调用const的版本，非const版本只能调用非const的版本呢？





# 虚函数为什么不能和缺省参数一起调用





# 虚函数实现原理





# 模板和虚函数

- 在模板类中可以使用虚函数，也可以继承模板类通过虚函数实现多态
- 但是模板成员函数不可以是虚函数
  - 因为在实例化模板类时，需要创建virtual table
  - 在模板类被实例化完成之前不能确定函数模板会被实例化出多少个
  - 因为虚函数必须要知道有多少个实例化出来的例子，方便存储函数的地址，而模板成员函数是不知道有多少个实例化出来的例子的，所以模板就不支持虚函数