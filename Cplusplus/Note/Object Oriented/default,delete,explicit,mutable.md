# mutable

- 背景：如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成 const 的
- 但有些时候，我们需要在 const 函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 mutable 来修饰，并且放在函数后后面关键字位置
- 即如果该变量被 mutable 修饰，那么即使是在被 const 修饰的成员函数里面，该变量也可以被修改







# explicit

- 背景：
  - C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指 不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换
  - 隐式转换：父子类的转换，基本数据类型的转换

- 用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方法进行类型转换
- 只能用于类内部的构造函数声明上，而不能用在类外部的函数定义上
- 只能用于单个参数的构造函数上
- 被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换
- 应用：
  - 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制
  - 可以将构造函数声明为explicit加以制止隐式转换
  - 所以explicit主要是针对一个参数的构造函数






# =default、=delete

- 背景：如果你自行定义了一个构造函数，编译器不会再给你提供默认构造函数；或者你不想要使用某个函数

- 而如果你在函数后面加上 =default ，就可以重新获得并使用 default 版本的构造/析构函数

  - ```cpp
    class Foo{
        private:
        	int _i;
        
        public:
        	Foo(i):_i(i){}
        	Foo() = default;//表示使用编译器默认提供的版本（因为有了参数构造函数，编译器是不会提供那个默认构造的函数的）
        	
        	~Foo() = default;
        	void func1() = default;//一般的函数没有默认版本，所以不能用
        	void func2() = delete;//禁止使用编译器默认生成的函数，可以用于任何函数
        	//也可以禁止使用某函数
    };
    ```