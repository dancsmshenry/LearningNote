# 如何禁止程序自动生成拷贝构造函数

- 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情 况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用
- 类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，则会产生一 个连接错误
- 针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成 private,那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生 类将阻止编译器执行相关的操作



# 如何阻止一个类被实例化

- 将类定义为抽象基类或者将构造函数声明为private
- 不允许类外部创建类对象，只能在类内部创建对象



# 如何设计一个类计算子类的个数

- 为类设计一个static静态变量count作为计数器
- 类定义结束后初始化count
- 在构造函数中对count进行+1
- 设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作
- 设计复制构造函数，在进行复制函数中对count+1操作
- 在析构函数中对count进行-1



# 析构函数为什么要是虚函数

- 首先
- 父类指针调用子类虚函数（多态），先是调整this指针的位置，再查虚函数表的
- 其次
- 父类指针指向子类对象，实际上会发生指针偏移的情况，即父类指针是指向子类中属于父类的那一部分
- 接着
- 如果不是虚函数，则是静态绑定，





- 为什么构造函数不能作为虚函数



- 多态只能适用于虚函数

  - 即如果有一个父类的指针指向子类，然后调用两个类都有的那个同名的虚函数，那么这就叫做多态，就会发生调用子类函数的情况
  - 但是，如果是调用两个类都有的同名的一个函数（非虚函数），那么会直接调用到父类的那个函数那里

- 对于一个多态的小bug

  - 如果父类的virtual函数设为了private的话，那就无法使用多态了（代码测验过）

- 能说一下虚继承的底层实现吗？或者多态（虚函数表）的底层实现也可以



- A继承自父类B和C，如果使用B的指针ptr1和C的指针ptr2同时指向一个A对象，则ptr1和ptr2的地址是否一致？

- B是父类，派生出A，B中有虚函数f并被A重写，使用B的指针指向A对象，则： 若B的构造函数中调用f则调用A的f还是B的f以及为什么； 如果B中有成员函数g，g中调用了f，而B的构造函数调用了g，则是调用了谁的f以及为什么

- 如何解释下列代码

  - ```cpp
    class A{
        public:
            A(){}
            A(A &a){cout << "A &a" << endl;}
            A(const A &a){cout << "const A &a" << endl;}
    };
    
    int main(){
        const A a;
        A a1(a);//调用A(const A &a){cout << "const A &a" << endl;}
        
        A a;
        A a2(a);//调用A(A &a){cout << "A &a" << endl;}
    }
    ```

  - 是否可以参照侯捷之前说的，如果两个函数const版本和非const版本同时存在，const只能调用const的版本，非const版本只能调用非const的版本呢？



# 面向对象

## 1、多态是如何实现的

- 多态是面向对象的一个基本属性，包括静态多态（编译阶段）和动态多态（运行阶段），静态多态主要是指函数参数不同产生的多态性，是在编译阶段可以识别的一种多态机制，而运行时多态则主要用于基类指针指向派生类对象时，可以通过基类指针直接调用派生类的对象函数，当然这种多态是通过虚函数实现的

## 2、构造函数什么不是虚函数，可以在里面调用虚函数吗

- 虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中，若构造函数声明为虚函数，那么该对象还未创建，没有内存空间，更没有虚函数表地址用来调用虚函数
- 构造函数的一个作用就是记录虚函数表，而未调用构造函数之前，虚函数表和虚函数的功能是不存在的
- 可以在构造函数中调用虚函数，只是不符合预期目标（https://blog.csdn.net/songchuwang1868/article/details/96481853），即虚函数在构造函数里面“不起作用”

## 8、析构函数为什么写为虚函数

- 是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调⽤基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏
- 如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构函数，成功释放内存
- 说白了，就是为了解决多态造成的一个问题（指针使用不当导致内存泄漏）

## 3、什么时候会调用拷贝构造函数

- 用类的一个实例化对象去初始化另一个对象
- 类对象作为函数的参数且并非引用传递的时候
- 函数的返回值是函数体内局部对象的类的对象时，此时虽然发生 NRV 优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数
  - 在linux gcc下不会发生拷贝构造函数调用，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数
  - 不过我记得gcc关闭优化后，还是会调用拷贝构造函数

## 4、=default、=delete、mutable 和 explicit 关键字的用法

- explicit

  - 用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方法进行类型转换
  - 只能用于类内部的构造函数声明上，而不能用在类外部的函数定义上
  - 只能用于单个参数的构造函数上
  - 被 explicit 修饰的构造函数的类，不能发生相应的隐式类型转换

- mutable

  - 背景：如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成 const 的
  - 但有些时候，我们需要在 const 函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被 mutable 来修饰，并且放在函数后后面关键字位置
  - 即如果该变量被 mutable 修饰，那么即使是在被 const 修饰的成员函数里面，该变量也可以被修改

- =default，=delete（cpp11以后才有的）

  - 背景：如果你自行定义了一个构造函数，编译器不会再给你提供默认构造函数；或者你不想要使用某个函数

  - 而如果你在函数后面加上 =default ，就可以重新获得并使用 default 版本的构造/析构函数

    - ```cpp
      class Foo{
          private:
          	int _i;
          
          public:
          	Foo(i):_i(i){}
          	Foo() = default;//表示使用编译器默认提供的版本（因为有了参数构造函数，编译器是不会提供那个默认构造的函数的）
          	
          	~Foo() = default;
          	void func1() = default;//一般的函数没有默认版本，所以不能用
          	void func2() = delete;//禁止使用编译器默认生成的函数，可以用于任何函数
          	//也可以禁止使用某函数
      };
      ```

## 5、Cpp 面向对象的三大特性

- 封装
  - 就是把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让信任的类或者对象操作，对不可信的进⾏信 息隐藏。⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。在⼀个对象内部，某些代码或某些数据 可以是私有的，不能被外界访问。通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部 分意外的改变或错误的使⽤了对象的私有部
  - 不想让外部的代码随意修改对象的属性
- 继承
  - 是指可以让某个类型的对象获得另⼀个类型的对象的属性的⽅法。它⽀持按级分类的概念。继承是指这样⼀种能 ⼒：它可以使⽤现有类的所有功能，并在⽆需᯿新编写原来的类的情况下对这些功能进⾏扩展。通过继承创建的新 类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”、“⽗类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要 实现继承，可以通过“继承”和“组合”来实现
  - 继承的两种：
    - 实现继承：实现继承是指直接使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒（普通继承）
    - 接⼝继承：接⼝继承是指仅使⽤属性和⽅法的名称、但是⼦类必需提供实现的能⼒（纯虚函数）
- 多态
  - 父类指针指向子类
  - 向不同对象发送同一个信息，不同对象在接收时会产生不同的行为
  - 一个接口，多个实现（用 java 的 interface 就很好理解）
  - 多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函 数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在 运⾏时才确定，这就属于晚绑定

## 7、虚函数为什么不能和缺省参数一起调用

## 9、在 cpp 中 struct 和 class 的区别

- 相同点：
  - 两者都有成员函数、区分公有和私有部分
  - 可以任意取代
- 不同点：
  - 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
  - class默认是private继承，而struct模式是public继承

## 10、struct 在 c 和 cpp 中的区别

- 在 C 中， struct 是用户自定义数据类型（UDT）；在 Cpp 中，struct 是抽象数据类型（ADT），支持成员函数的定义，能继承，能实现多态
- 在 C 中  struct 是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数
- 在 Cpp 中，struct 增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为 public （为了与 C 兼容）

11、对虚函数表的理解