# 类成员初始化

- 赋值初始化：通过函数体内进行赋值初始化
- 列表初始化：在冒号后使用初始化列表初始化
- 区别：
  - 列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)
  - 那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行



# 构造和析构的顺序



# 类如何实现只能静态分配和只能动态分配

- 背景：
  - 静态创建：静态建立一个类对象，就是由编译器为对象在栈空间中分配内存
  - 动态创建：A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。 这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象
- 前者：把new和delete运算符重载为privated属性（只有使用new运算符，对象才会被创建在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，即把new运算符设为私有）
- 后者：把构造、析构函数设为protected属性，再用子类动态创建



# 继承下对象的转换

- 向上类型转换
  - 将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的
- 向下类型转换
  - 将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一 个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动 态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换
  - 因为父子类的结构不一样，可能子类有多个虚函数指针，强转导致数据出错



# 空类会提供的函数

- 析构函数
- 拷贝构造函数
- 缺省构造函数
- 赋值运算符



# 如何阻止类被拷贝

- 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用
- 但是，类的成员函数和friend函数还是可以调用private函数，并且如果这个private函数只声明不定义，则会产生链接错误
- 针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成 private，那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作



# 如何阻止类被实例化

- 将类定义为抽象基类或者将构造函数声明为private



# 如何阻止类被继承

### 方法一

- ```cpp
  class B;
  //设计一个不能被继承的类
  class A
  {
         friend B;
  private:
         A() {}
  };
  class B :virtual public A
  {
  public:
         B() {}
  };
  ```

- 我们可以声明一个辅助的类A，把类A的构造函数声明为私有的，并使得B是A的友元类，且B虚继承A。让B是A的友元类的目的在于能够让B访问A的私有构造函数，这样继承自A的B才可以被实例化

- 假设现在有一个类D继承B，在D初始化的时候会先调用B类的构造函数，但是由于B虚继承A，所以为了防止产生二义性，D必须先调用A的构造函数，由于A的构造函数是私有的不可访问，所以会产生错误，继承会失败



### 方法二

- ```cpp
  class CParent
  {
  private:
      CParent(int v){m_v = v;}
      ~CParent(){}
  
      int m_v;
      static CParent * m_instance;
  public:
      static CParent * getInstance(int v);
  };
  
  CParent *CParent::getInstance(int v)
  {
      return new CParent(v);
  }
  ```

- 相当于写一个单例模式吧



### 方法三

- final修饰符，cpp11得到的





# 如何设计一个类计算子类的个数

- 为类设计一个static静态变量count作为计数器
- 类定义结束后初始化count
- 对于默认构造函数，拷贝构造函数，复制构造函数，在进行上述函数时进行count+1操作
- 在析构函数中对count进行-1