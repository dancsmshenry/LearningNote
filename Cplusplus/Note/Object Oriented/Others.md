# 类成员初始化

- 赋值初始化：通过函数体内进行赋值初始化
- 列表初始化：在冒号后使用初始化列表初始化
- 区别：
  - 列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式)
  - 那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行
- 有几种情况是必须要用列表初始化的（后续补一下），同时，列表初始化的顺序是按照数据在类中定义的顺序从而进行初始化的



# 构造和析构的顺序



# 类如何实现只能静态分配和只能动态分配

- 背景：
  - 静态创建：静态建立一个类对象，就是由编译器为对象在栈空间中分配内存
  - 动态创建：A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。 这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象
- 前者：把new和delete运算符重载为privated属性（只有使用new运算符，对象才会被创建在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，即把new运算符设为私有）
- 后者：把构造、析构函数设为protected属性，再用子类动态创建



# 继承下对象的转换

- 向上类型转换
  - 将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的
- 向下类型转换
  - 将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一 个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动 态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换
  - 因为父子类的结构不一样，可能子类有多个虚函数指针，强转导致数据出错



# 空类会提供的函数

- 析构函数
- 拷贝构造函数
- 缺省构造函数
- 赋值运算符



# 如何阻止类被拷贝

- 为了阻止编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置成private，防止被调用
- 但是，类的成员函数和friend函数还是可以调用private函数，并且如果这个private函数只声明不定义，则会产生链接错误
- 针对上述两种情况，我们可以定一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置成 private，那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关的操作



# 如何阻止类被实例化

- 将类定义为抽象基类或者将构造函数声明为private



# 如何阻止类被继承

### 方法一

- ```cpp
  class B;
  //设计一个不能被继承的类
  class A
  {
         friend B;
  private:
         A() {}
  };
  class B :virtual public A
  {
  public:
         B() {}
  };
  ```

- 我们可以声明一个辅助的类A，把类A的构造函数声明为私有的，并使得B是A的友元类，且B虚继承A。让B是A的友元类的目的在于能够让B访问A的私有构造函数，这样继承自A的B才可以被实例化

- 假设现在有一个类D继承B，在D初始化的时候会先调用B类的构造函数，但是由于B虚继承A，所以为了防止产生二义性，D必须先调用A的构造函数，由于A的构造函数是私有的不可访问，所以会产生错误，继承会失败



### 方法二

- ```cpp
  class CParent
  {
  private:
      CParent(int v){m_v = v;}
      ~CParent(){}
  
      int m_v;
      static CParent * m_instance;
  public:
      static CParent * getInstance(int v);
  };
  
  CParent *CParent::getInstance(int v)
  {
      return new CParent(v);
  }
  ```

- 相当于写一个单例模式吧



### 方法三

- final修饰符，cpp11得到的





# 如何设计一个类计算子类的个数

- 为类设计一个static静态变量count作为计数器
- 类定义结束后初始化count
- 对于默认构造函数，拷贝构造函数，复制构造函数，在进行上述函数时进行count+1操作
- 在析构函数中对count进行-1





# 成员函数是如何调用的

- 一个引子

- ```cpp
  #include <iostream>
  
  class A {
  public:
      void test() {
          std::cout << "hello" << std::endl;
          //std::cout << i << " " << std::endl;
      }
      int i{};
  };
  
  int main() {
      A *a1 = nullptr;
      a1 -> test();
  }
  ```

- 如果注释掉了i的那一行，代码可以运行吗

- 可以的，为什么

- 先了解一下成员函数是如何调用的，成员函数的调用本质上会加上一个对象的指针进去的，即this指针

- 换句话说，如果函数里面没有触及这个this指针，那么即使this为nullpr，也是可以运行的

- 吐槽一下：这个面试题有点老了....







# trivial函数，standard-layout和POD

背景

- ```cpp
  class A
  {
  public:
      // ...
      A() {}          // 定义一个空的默认构造函数
      A() = default;  // 主动让编译器生成默认构造函数
      // ...
  };
  ```

- 这两种构造函数有何区别



trivial type的定义

- 没有虚函数或虚基类
- 由编译器生成默认的特殊成员函数，包括默认构造函数、拷贝构造函数、移动构造函数、赋值运算符、移动赋值运算符和析构函数
- 数据成员同样需要满足上述两个条件



Standard Layout的定义

- 没有虚函数或虚基类

- 所有非静态数据成员都具有相同的访问说明符（`public` / `protected` / `private`）

- 在继承体系中最多只有一个类中有非静态数据成员。

- 子类中的第一个非静态成员的类型与其基类不同（具体的原因可以参考下面的博文）
  - 因为在cpp的标准里面，如果基类没有任何数据成员，基类应不占用空间，所以允许派生类的第一个成员与基类共享同一地址空间
  
  - 如果派生类的第一个成员和基类的类型相同，而cpp标准要求相同的类型不同的对象的地址必须有所区分，所以编译器就会为基类分派一个字节的地址空间
  
  - ```cpp
    #include <iostream>
    #pragma  pack(1)
    
    struct A
    {
    };
    
    struct B : A
    {
    	// A a; // 这样写大小为6
    	int i;
    	A a; // 这样写大小为5
    };
    
    struct C
    {
    };
    
    struct D : A
    {
    	C c;
    	int i;
    };
    
    int main()
    {
    	B b;
    	A &a1 = b;
    	// &b == &a1 == &b.a - 1
    	std::cout << &b << std::endl;
    	std::cout << &a1 << std::endl;
    	std::cout << &b.a << std::endl;
    	std::cout << sizeof(B) << std::endl;
    	std::cout << "-------------" << std::endl;
    
    	D d;
    	A &a2 = d;
    	// &d == &a2 == &d.c
    	std::cout << &d << std::endl;
    	std::cout << &a2 << std::endl;
    	std::cout << &d.c << std::endl;
    	std::cout << sizeof(D) << std::endl;
    }
    ```
  
  - 这就直接导致的结果是，同样是一个空类加上一个int，不同的排列方法会导致大小的不同
  
  - 探讨对象B的内存布局
  
  - 如果是先A a;，再int i;，那么编译器为了区分B和A，对象布局就是第一层用一个字节表示对象B，第二层用一个字节来区分表示对象A，第三层用四个字节表示对象int i，这样一共就用了6个字节
  
  - 而如果是先int i;，再A a;，那么编译器就不需要去区分B和A了，则对象布局时第一层用四个字节表示int i；，这里顺带也会用来表示对象B，然后第二层用一个字节表示对象A a，这样一共就用了5个字节
  
  - 而这里为什么对象D同样是把空类放到最前面，但是大小却依然是5，是因为对象C和对象D没有父子关系，即使再同一个地址编译器也能够区分
  
- 总结：一切都是因为cpp的标准说，相同类型的不同对象的地址必须不同，编译器为了实现，就为那个不同的对象分配一个字节的地址空间



plain old data的定义

- 代表一个对象是一个普通类型；Old 代表一个对象可以与 C 语言兼容
- 可以使用字节赋值，比如用 `memset`、`memcpy` 对 POD 类型对象进行赋值操作。
- 与 C 语言内存布局兼容，POD 类型的数据可以使用 C 函数进行操作且是安全的。
- 保证了静态初始化的安全有效



# 关于虚指针的问题

- ```cpp
  #include <algorithm>
  #include <iostream>
  #include <vector>
  
  class C {
  public:
      C() {std::cout << "c" << std::endl;}
      virtual ~C() {std::cout << "~C" << std::endl;} 
  };
  
  class D:public C {
  public:
      D() {std::cout << "d" << std::endl;}
      virtual ~D() {std::cout << "~d" << std::endl;}
  };
  
  int main() {
      C* d = new D();
      d -> ~C();
      std::cout << "----" << std::endl;
      delete d;
  }
  
  /*
  c
  d
  ~d
  ~C
  ----
  ~C
  */
  ```

- 为什么通过父指针调用父函数的析构函数，会造成指针的移动（后面delete都不会调用d的析构函数了...）



参考

- https://zhuanlan.zhihu.com/p/479755982