# 背景

### 常见寄存器

+ `%rax` 通常用于存储函数的返回值，同时也用于乘法和除法指令
  + 在乘法 `imul` 指令中，两个64位的乘积超过64位时，高位存储在 `%rdx` 中
  + 在除法指令 `idiv` 中，被除数是超过64位时，高位存储在 `%rdx` 中

+ `%rsp` 是栈指针寄存器，指向的是栈顶元素（rsp低32位就是esp）
  + 可以用 `pushq` 和 `popq` 指令将数据存入栈中或是从栈中取出
  + 分配空间：将栈指针减小适当的量可以分配空间
  + 释放空间： 将栈指针增大适当的量可以释放空间
  + 当前正在执行的过程的帧总是在栈顶

+ `%rbp` 是栈帧指针寄存器，用于标识当前栈帧的起始位置（rbp低32位就是erp）
+ `%rdi， %rsi， %rdx， %rcx， %r8， %r9` 用来存储函数调用的前6个参数
  + 当 x86-64 函数调用的参数大于6时，超出的部分就会在栈上分配空间，这部分称为函数调用的栈帧（`stack frame`）






### Caller Save 与 Callee Save

- 通用寄存器分为  Caller Save 和  Callee Save 两个类型，即发生函数调用时寄存器的值是由”调用者保存“ 还是由 ”被调用者保存“
- 当发生函数调用时，子函数内通常也会使用到通用寄存器，那么这些寄存器中之前保存的调用者（父函数）的值就会被覆盖
- 为了避免数据覆盖而导致从子函数返回时寄存器中的数据不可恢复，CPU 体系结构中就规定了通用寄存器的保存方式



- **`Caller Save`**  寄存器：在进行子函数调用前，就需要由调用者提前保存好这些寄存器的值，保存方法通常是把寄存器的值压入栈中，调用者保存完成后，在被调用者（子函数）中就可以随意覆盖这些寄存器的值了。这类寄存器有：`%r10，%r11`（eax，ecx，edx，esp）

- **`Callee Save`**：在函数调用时，调用者就不必保存这些寄存器的值而直接进行子函数调用，进入子函数后，子函数在覆盖这些寄存器之前，需要先保存这些寄存器的值，即这些寄存器的值是由被调用者来保存和恢复的。这类寄存器有：`%rbx， %rbp， %r12， %r13， %r14， %r15`（ebx，ebp，esi，edi）



- 其他的通用寄存比如上面介绍的 `%rax`，`%rsp` 无须保存，还有一些专门用来发生函数调用时的寄存器，专门用来保存函数参数的







# 函数调用

需要执行的操作：

+ 父函数将调用参数从后向前压栈，即`arg1`在低地址，`argn`在高地址（**数据从右到左压栈**）

+ 把返回地址当做子函数的栈帧的一部分（**把返回地址压栈**）

+ 跳转到子函数起始地址执行 ，即`%rip`设置为子函数的起始地址（**跳转到子函数起始地址**）

+ 子函数将父函数栈帧起始地址`%rbp` 压栈 （**把父函数的rbp压栈**）

+ 将 `%rbp` 的值设置为当前 `%rsp` 的值，即将 `%rbp` 指向子函数栈帧的起始地址（**调整栈帧**）

  ```asm
    		call func
    		// call的作用：
    		// 将父函数的返回地址入栈
    		// 跳转到子函数，将调用函数的%rbp保存在当前的栈帧中（子函数为被调用函数）
    		// 相当于上述操作的第二步和第三步
  
    func:
          pushq rbp         // 将调用函数的栈帧起始地址压入栈（保留旧栈帧）
        	moveq rsp rbp     // 使得rbp指向当前被调用函数的栈帧起始地址
  ```



- 下图是发生函数调用时的栈帧：

- ![ ](image\stack_frame.png)







# 函数返回

需要执行的操作：

+ 恢复栈的结果到函数调用之前的状态（**把子函数的内容弹出，同时调整栈帧位置**）
+ 跳转到调用函数的返回地址处继续执行（**将子函数的结果给到返回地址**）



- 由于在调用子函数时已经保存了父函数的返回地址和父的栈帧起始地址，那么只需要恢复即可：

```asm
    moveq %rbp， %rsp   // 使得 %rsp 和 %rbp 指向一处：子函数的栈帧起始地址 
    popq  %rbp         // 调用函数的栈帧起始地址地址，并且%rsp上移一个位置，指向返回地址
    ret				   // 从当前%rsp指向的位置弹出数据，并且跳转到此数据表示的地址处，即返回父函数
```

-  `ret` 指令的作用

  + 使得`%rsp`再上移动一个位置，使得`%rsp`指向父函数的栈帧的结尾处，即保存了父函数的返回地址

  + 会弹出栈中的数据，返回主函数




- 返回时候的栈帧如下

![ ](image\stack_frame_2.png)







# 为什么c/cpp中函数压栈是从右到左

- 对于含有固定参数的函数来说，从左到右还是从右到左都是正确的
- 但对于不变参数来说就不行
  - 比如说printf是依靠format来判断可变参数的数量的，如果是从左到右，先进去的是format，后进去的是可变参数，那想要知道可变参数数量就必须要知道format，但要知道format就必须要让栈帧减去参数数量大小的空间，就会陷入循环
  - 所以必须要从右到左
- 这种方式便于支持类似于 printf(“%d, %d”, i, j) 这样的使用变长参数的函数调用







# 代码验证

- ```cpp
  #include <iostream>
  using namespace std;
  int f(int n)
  {
      cout << n << endl;
      return n;
  }
  void func(int param1， int param2)
  {
      int var1 = param1;
      int var2 = param2;
      printf("var1=%d，var2=%d"， f(var1)， f(var2)); //如果将printf换为cout进行输出，输出结果则刚好相反
  }
  int main(int argc， char *argv[])
  {
      func(1， 2);
      return 0;
  }
  //输出结果
  // 2
  // 1
  // var1=1，var2=2
  ```





# 进行函数调用，栈怎么动态分配，和CPU寄存器怎么联动，数据怎么同步到内存





# 参考

- https://blog.csdn.net/qq_44824574/article/details/123463635
- https://zhuanlan.zhihu.com/p/27339191
- https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html
- 阿秀的笔记
- learningnote
- CSAPP
- 堆栈平衡