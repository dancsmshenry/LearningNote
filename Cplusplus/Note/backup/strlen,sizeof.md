# strlen

- 它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符'\0'为止，然后返回计数器值

- 无论是char*还是char[]，他都可以获取到具体数据的长度

- 而他的原理就和第一点说的，碰到\0后就停下来，并记录此时的长度（**长度不包含'\0'**）

- 所以`char s1[] = "123456\07";`，它返回的就是7

- ```cpp
      std::cout << sizeof("a") << std::endl; // 2（会包含后面的\n）
      std::cout << strlen("a") << std::endl; // 1（只会包含字符）
  ```







# sizeof

- 是一个运算符，不是函数（是在编译过程中处理，也可能是运行时处理：柔性数组）

- 实际上是获取了数据在内存中所占用的存储空间，以字节为单位来计数

- 是在编译的时候就确定大小了的，所以动态分配的大小是无法测量的（就是说new和malloc之类的动态分配内存）

- ```cpp
  int *a = new int[11111];
  std::cout << sizeof(a) << std::endl;
  // 此时得到的只能是该指针的大小
  
  std::cout << sizeof("aa") << std::endl; // 长度为3（说明sizeof会把后面的\0g）
  ```







# strlen和sizeof的区别

定义

- sizeof是运算符，不是函数，结果在编译时得到而非运行中获得
- strlen是字符处理的库函数



参数

- sizeof参数可以是任何数据类型或者数据（sizeof参数不退化）
- strlen的参数只能是字符指针且结尾为’\0‘的字符串



- sizeof值是在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小

- ```cpp
  sizeof("abcdefg") // 值为8，末尾有一个结束符\0也被计算在内
  
  strlen("abcdefg") //值为7，末尾的\0不计算在内
  ```