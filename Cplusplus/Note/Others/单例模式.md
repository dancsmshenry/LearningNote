# 懒汉模式

- 直到用到的时候才会被创建出来

- ```cpp
  class single {
  private:
      single() = default;
      single(const single& s) = default;
      static single* s1;
  
  public:
      static single* getsingle() {
          if (s1 == nullptr) {
              s1 = new single();
          }
          return s1;
      }
  };
  
  single* single::s1 = nullptr;
  /**
  线程不安全，因为：
  1、线程A进入函数getsingle执行判断语句，这句执行后就挂起了，这时线程A已经认为s1为nullptr，但是线程A还没有创建single对象
  
  2、又有一个线程B进入函数getsingle执行判断语句，此时同样认为s1变量为nullptr，因为A没有创建getsingle对象。线程B继续执行，创建了一个getsingle对象
  
  3 稍后，线程A接着执行，也创建了一个新的single对象
  
  4 创建了两个对象！
  **/
  ```

- ```cpp
  class single {
  private:
      single() = default;
      single(const single& s) = default;
      single& operator=(const single&) = default;
  
  public:
      static single& getsingle() {
          static single s1;
          return s1;
      }
  };
  //线程安全的，effective cpp里面给的例子（）
  ```





# 饿汉模式

- 一开始就创造出来了

- ```cpp
  class Singleton
  {
  private:
  	static Singleton instance;
  private:
  	Singleton();
  	~Singleton();
  	Singleton(const Singleton&);
  	Singleton& operator=(const Singleton&);
  public:
  	static Singleton& getInstance() {
  		return instance;
  	}
  }
  
  // initialize defaultly
  Singleton Singleton::instance;
  //线程安全的
  ```

- 问题：

  - 由于在main函数之前初始化，所以没有线程安全的问题。但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。也即，static Singleton instance;和static Singleton& getInstance()二者的初始化顺序不确定，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例



- 参考：https://zhuanlan.zhihu.com/p/37469260







# 工程类

## 1、c与cpp接口间互相调用

- https://blog.csdn.net/lincoln_2012/article/details/50801080

- 



- `int (&b)[10] = a;`是什么？`int a[10];`又是什么？（mark:https://blog.csdn.net/qq_34988341/article/details/106452518）

- 

- 在群里面看到的代码：

  - ```cpp
    static char_type* copy(char_type* dst, const char_type* src, size_t n){//拷贝的过程要注意内存重叠的问题
        assert(src + n <= dst || dst + n <= src);
        char_type* r = dst;
        for (; n != 0; -- n, ++ dst, ++ src){
            *dst = *src;
        }
        
        return r;
    }
    ```

  - 内存拷贝的四种情况：

  - 第一种：dst  空格空格  src

  - 第二种：src 空格空格 dst

  - 第三种：dst src（src的有一部分是和dst重合的），那么，此时从前往后复制的时候，也不会影响

  - 第四种：src dst（dst的有一部分是和src重合的），那么，此时从前往后复制，就会把src后面的一部分给覆盖掉，导致两个内存的内容不同

  - 参考c的库函数memmove()





## 13、c和cpp的区别

## 14、cpp从源代码到可只想文件的过程





## 10、规范定义一个MAX宏

- ```cpp
  //加上括号，避免展开出错
  #define MAX(A, B) ((A)>(B)? (A):(B))
  
  //避免自增问题，如MAX(i++,j++）
  #define MAX(A, B) ({	\
  	int a = A; 	\
  	int b = B;	\
  	a > b ? a : b;	\
  })
  
  // 兼容不同数据类型，且不用显式指定类型
  #define MAX(A, B) ({	\
  	typeof(A) a = A; 	\
  	typeof(B) b = B;	\
  	(void) (&a == &b);	\
  	a > b ? a : b;		\
  })
  ```

- 