# 头文件<>和""的区别

- #include<>：编译器直接从系统类库目录里查找头文件： 
- \#include""：默认从项目当前目录查找头文件，所谓项目当前目录，就是项目工程文件（.vcxproj）所在的目录。如果在项目当前目录下查找失败，再从**项目配置的头文件引用目录**查找头文件，所谓项目配置的引用目录，就是我们在项目工程中设置的头文件引用目录。如果项目配置的头文件引用目录中仍然查找失败，再从**系统类库目录**里查找头文件



# 如何防止头文件被重复引用

- ```cpp
  #ifndef __INCvxWorksh  /*防止该头文件被重复引用*/
  #define __INCvxWorksh
  
  #ifdef __cplusplus    //__cplusplus是cpp中自定义的一个宏
  extern "C" {          //告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的
  #endif
  
      /**** some declaration or so *****/  
  
  #ifdef __cplusplus
  }
  #endif
  
  #endif /* __INCvxWorksh */
  ```



# 模板类为什么都放在h文件中

- 原因1：
  - 模板定义很特殊。由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，它一 直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多 重定义
  - 所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义
- 原因2：
  - 在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查 找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时 就傻眼了，因为模板仅在需要的时候才会实例化出来。
  - 所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待 连接器能够将符号的地址决议出来 
  - 然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中 就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了



# 其他

- java里面没有全局变量，好像是过程式语言中才有吗？？但是python也有啊