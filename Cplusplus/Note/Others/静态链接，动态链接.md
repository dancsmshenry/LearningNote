# 背景

- 在C语言中，我们知道要生成可执行文件，要经历预编译、编译、汇编、链接，在链接过程中，静态链接和动态链接就出现了区别
- 首先将代码预编译，这个过程主要是处理一些#号定义的命令或语句（如宏、#include、预编译指令#ifdef等），生成*.i文件
- 在对代码进行编译，这个过程主要是进行词法分析、语法分析和语义分析等，生成*.s的汇编文件
- 接着对代码进行汇编，这个过程比较简单，就是将对应的汇编指令翻译成机器指令，生成可重定位的二进制目标文件



# 静态链接

出现的原因

- 在我们的实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，但是每个源文件都是独立编译的，即每个* .c文件会形成一个* .o文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序。这个链接的过程就是静态链接



- 把要链接的内容结合到了生成的可执行文件中，即使把原来的静态库删除掉也不影响程序的执行
- 静态库可以在任何目录下，只要你第一次链接的时候，用绝对路径去链接即可
- 是一组例程，外部函数和变量，它们在编译时在调用者中解析，并由编译器，链接器或绑定器复制到目标应用程序中，从而生成目标文件和一个可执行文件
- 在编译的时候会锁定到程序中（缺点就是代码被锁定到最终的可执行文件中，如果没有重新编译就无法修改）
- 程序中的每个文件都必须在编译时拥有它自己的库文件副本
- 优点是运行时的执行速度。因为它的目标代码（二进制）已经包含在可执行文件中，所以对多个函数的调用可以比动态库的代码更快地处理，而动态库的代码需要从可执行文件之外的文件中调用



优缺点

- 缺点
  - 浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本（以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本）
  - 更新困难（每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序）
- 优点
  - 在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快





- 静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主 要完成以下两个任务：
  - 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号 引用与一个符号定义关联起来
  - 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使 得它们指向这个内存位置
- 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库 中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 
- 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个 目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 
- 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序 
- 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西， 在执行的时候运行速度快。
- 静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到 可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库







# 动态链接

出现的背景

- 解决空间浪费和更新困难的问题





- 在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快

- 没有把要链接的内容放进去，而是在执行的过程中，再去找要链接的内容，生成的可执行文件中并没有要链接的内容，所以如果把原来的动态库删除掉，可执行程序就不能执行了
- 动态链接生成的可执行文件要比静态链接生成的文件要小一些
- 动态库一般都会在/usr/lib目录下
- 只包括库的地址，在运行时链接库
- 可以修改动态库而无需重新编译
- 编译时只需要制作库文件的一个副本
- 缺点是更容易破坏（如果动态库损坏，则可执行文件可能不再起作用。但是，静态库是不可触及的，因为它存在于可执行文件中）
- 优点是多个正在运行的应用程序可以使用相同的库，而无需每个应用程序拥有自己的副本



- 动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。



如何重定位的

- 前面我们讲过静态链接时地址的重定位，那我们现在就在想动态链接的地址又是如何重定位的呢？虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行



- 背景：
  - 当静态库更新时那么整个程序都要重新进行链接
  - 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源
- 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系 统上它们被称为 DLL。它具有以下特点：
  - 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中
  - 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享
- 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形 成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 
- 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副 本，而是这多个程序在执行时共享同一份副本； 
- 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运 行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。 
- 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。
- 动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。 所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点 是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果 其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行





# 比较

- 静态链接库执行速度比动态链接库更快（执行过程不需要找链接的内容）
- 动态链接库更节省内存（未写入要链接的内容）



# 模板的链接

- 不管模板内部的实现调用了什么依赖库，模板生成的代码本身是静态链接的，因为模板的目标代码都是当时编译器即时生成的
  - 所以我们平时用的string或是iostream都是静态链接的（因为cout这些都是模板）
  - 但是这些头文件所依赖的内容可能存在于libstdc++(libc++或者其它)当中，这一部分是动态链接的
- 而像stdio等头文件中，大部分东西都是C里面的标准IO之类的东西，这些东西存在于libc当中，即是动态链接





# 参考

- https://blog.csdn.net/kang___xi/article/details/80210717
- https://blog.csdn.net/wddpfx/article/details/115326921
- https://blog.csdn.net/freestyle4568world/article/details/49817799
- https://blog.csdn.net/kang___xi/article/details/79571137