# 预编译

## 定义

- 读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。包括宏定义替换、条件编译指令、头文件包含指令、特殊符号。预编译程序所完成的基本上是对源程序的“替代”工作。经过此种替代，生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件
  - .i预处理后的c文件，.ii预处理后的C++文件




## 操作

- 删除所有的#define，展开所有的宏定义
- 处理所有的条件预编译指令，如：“#if”、“#endif”、“#ifdef”、“#elif”和“#else”
- 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件的话也会递归的替换
  - 把头文件的定义都加入到它所产生的输出文件中，以供编译程序处理

- 删除所有的注释，如：“//”和“/**/”
- 保留所有的#pragma编译器指令
  - 因为编译器需要用到他们，如：#pragma once，是为了防止有文件被重复引用

- 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号







# 编译

## 定义

- 把预编译之后生成的xxx.i或xxx.ii文件，通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码，如.s文件
- PS：那些在代码里面没有定义的符号（比如函数或是变量），会在这一步发生报错
  - 进一步思考，为什么我们引用其他模块的变量不会在编译的过程中出错，是因为，我们提前告知了编译器，我们写的是函数的声明（所以有可能函数的定义是在别的文件中），或是说这个变量是被声明在了其他文件，并且也在当前文件中告知了




## 操作

- 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号
- 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树
- 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
- 优化：源代码级别的一个优化过程
- 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示
- 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等（优化包括软件或者硬件层面的优化）







# 汇编

## 定义

- 把汇编语言代码翻译成目标机器指令的过程
- 对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件
  - 目标文件应该分为：可重定位文件（linux下是.obj文件，windows下是.o文件），库文件（分为动态库和静态库，并且不同平台的库文件也会有所不同，比如说linux比较常见的so库就是动态库的后缀）
- 目标文件中所存放的也就是与源程序等效的目标的机器语言代码
- 举例说，生成的.o文件，以机器码的形式包含了编译单元里所有的函数和数据、导出符号表、未解决符号表、地址重定向表等



## 操作

- 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成







# 链接

## 定义

- 将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够装入操作系统执行的统一整体



## 内部链接

- 如果一个名称（函数，变量）对当前的编译单元（.cpp）来说是局部的，在链接的时候其他的编译单元无法链接到它且不会与其它编译单元(.cpp)中的同样的名称相冲突
  - 例如：static函数（用static修饰的物品本来就无法给当前文件以外的文件使用，而普通的函数默认默认是extern的），inline函数（这也就解释了弱符号的意思，即当两个编译单元都有一个相同名字的普通函数时，给其中的一个改为inline就不会出现问题）等
  - 所以有的内联函数要写在头文件里面，因为inline函数是内部连接的，即如果使用的时候没有把它include进来，就用不了（放在cpp文件中，后续会因为是内部链接而找找不到该函数）
  - 所以，模板的声明和定义都要写在一起

- c语言的全局const变量默认是外部链接，而cpp的全局const变量默认是内部链接



## 外部链接

- 如果一个名称对编译单元(.cpp)来说不是局部的，而在链接的时候其他的编译单元可以访问它，也就是说它可以和别的编译单元交互。 例如变量就是外部链接， 全局变量





# 目标文件

- 可执行目标文件：可以直接在内存中执行
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；





# 从编译的角度来看.h文件

- 我们一般都是将库的.h文件放入自己的程序中，然后经过预编译编译汇编，再将库的可执行文件和当前程序得到的可执行文件进行链接
- 当然，因为我们将类对象的定义都放入了.h文件中，后续相应的.cpp文件也要include相应的.h文件
- 所以，.h文件更像是一个接口或是一个黑盒，可以理解为先让当前程序只需要对黑盒提供的接口进行操作，具体的实现延迟到后续的链接部分







# 参考

- 《csapp》编译链接一章
- 《程序员的自我修养》
- https://blog.csdn.net/isscollege/article/details/73851795