# background

- 平台原因（移植原因）：
  - 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
  - 所以一些跨端的代码中，必须要相应的字节对齐，才能够正常的对数据进行存取
  - 有些`CPU`可以访问任意地址上的任意数据，而有些`CPU`只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了
- 性能原因：
  - 原因在于：为了访问未对齐的内存，处理器需要作两次内存访问（比如说一个未对齐的int分别占据了数据位置的3456的位置，那么取数据的时候就必须先取0-3之间的数据，把012的数据丢弃，然后再取4-7之间的数据，然后把7位置的给丢弃）；而对齐的内存访问仅需要一次访问
  - 所以就牺牲一些内存空间，换取**高效的读取速度**，即空间换时间
  - `CPU`每次寻址都是要消费时间的，并且`CPU` 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能



- 从硬件的角度来考虑内存对齐
  - https://yangwang.hk/?p=773
  - https://zhuanlan.zhihu.com/p/83449008
  - 文章里面说了，其实硬件并非不能够访问未对齐的内存，只是因为，为了能够访问未对齐的内存，造成硬件上的损耗，这样太不值得了







# 定义

- 内存存取粒度：处理器以双字节，四字节，8字节，16字节甚至32字节为单位来存取内存
  - 在32位编译环境下默认**4字节对齐**，在64位编译环境下默认**8字节对齐**

- 内存对齐：现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是在实际情况中，在访问特定类型变量的时候经常在特定的内存地址访问，所以这就需要把各种类型数据按照一定的规则在空间上排列，而不是按照顺序一个接一个的排放，这种就称为内存对齐
- 内存对齐是指首地址对齐，而不是说每个变量大小对齐







# 规则

## 规则1：结构体的总大小是最大对齐值的整数倍

- 对齐值：默认的对齐数与当前该成员大小中的较小值
- 选择的是各个对齐值中的最大值

- 因此，在需要的时候会加上padding



## 规则2：结构体的第一个成员放在偏移量为0的地址处

- 即第一个成员变量放到地址为0开头处



## 规则3：其他成员都存放在对齐数整数倍的地址处

- 因此会在需要的时候加上padding
- 二级结论：如果pack的对齐数n大于所有的数据，那么这个n会被退化为相应的字节对齐数（比如说上面的8字节对齐和16字节对齐的结果完全是一样的）



## 示例

- ```cpp
  #include <iostream>
  // #pragma pack(1) // 17个字节 
  //	l1 8个字节 l2 1个字节 i1,i2共8个字节
  
  // #pragma pack(2) // 18个字节 
  //	l1 8个字节 l2 1个字节（因为i1要对齐，所以加上1个字节的padding） i1,i2共8个字节
  
  // #pragma pack(4) // 20个字节 
  //	l1 8个字节 l2 1个字节（因为i1要对齐，所以加上3个字节的padding） i1,i2共8个字节
  
  // #pragma pack(8) // 24个字节
  //	l1 8个字节 l2 1个字节 （因为i1要对齐，所以加上3个字节的padding）
  //	i1 4个字节 i2 4个字节（最后补上padding 4个字节，使得整个结构体的大小为对齐值的整数倍）
  
  // #pragma pack(16) // 24个字节
  //	l1 8个字节 l2 1个字节 （因为i1要对齐，所以加上3个字节的padding）
  //	i1 4个字节 i2 4个字节（最后补上padding 4个字节，使得整个结构体的大小为对齐值的整数倍）
  
  struct s1 {
      long long l1;
      char l2;
      int i1, i2;
  };
  
  int main() {
      std::cout << "sizeof(s1) = " << sizeof(s1) << " " << std::endl;
  }
  ```



- ```cpp
  class c1 {
  public:
  	char a[17];
  }; // 17
  
  class c2 {
  public:
  	char s[17];
  	int i1;
  	double d1;
  	int i2;
  }; // 17 + 3(padding，因为i1需要在对齐数开始的地址存放，最近的对齐数是20) + 4 + 8 + 4 + 4(padding，因为总大小要是最大对齐值的整数倍，而此时的最大对齐值为8，最近的对齐数是40)
  ```







# 语法

## 获得结构成员的字节偏移量

- ```cpp
  #include <iostream>
  #include <stddef.h>
  using namespace std;
  struct S {
   int x;
   char y;
   int z;
   double a;
  };
  
  int main() {
   //	使用头文件中的，offsetof宏
   cout << offsetof(S, x) << endl; // 0
   cout << offsetof(S, y) << endl; // 4
   cout << offsetof(S, z) << endl; // 8
   cout << offsetof(S, a) << endl; // 12
   return 0;
  }
  ```



## 重置字节对齐

- ```cpp
  #pragma pack(n) // 编译器将按照n个字节对齐
  
  #pragma pack(push) // push存放要对齐的数字大小
  #pragma pack(4) // 比如说按4字节对齐
  #pragma pack(1) // 比如说按1字节进行对齐
  
  #pragma pack() // 恢复先前的pack设置，取消设置的字节对齐方式
  #pragma pack(pop) // 和上面一句是等价的
  
  //	只能取值为1 2 4 8 16
  //	偏移量要是n和当前变量大小中较小值的整数倍
  //	整体大小要是n和最大变量大小中较小值的整数倍
  ```



## 取消结构体字节对齐

- ```cpp
  typedef struct
  {
      double x;
      double y;
  } __attribute__((packed)) position_t;
  
  //	在结构体定义的最后或者前面加上这一串，可以避免结构体发生字节对齐的情况
  struct __attribute__((__packed__)) sdshdr8
  {
      uint8_t len;         /* 数据⻓度 */
      uint8_t alloc;       /* 去掉头和null结束符，有效⻓度+数据⻓度*/
      unsigned char flags; /* 3 lsb of type, 5 unused bits，⼩端*/
      //变⻓数据
      char buf[];
  }
  ```
