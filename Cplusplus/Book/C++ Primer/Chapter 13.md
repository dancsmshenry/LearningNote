# 第13章 拷贝控制

## 13.1 拷贝、赋值与销毁

- 一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁：

  - 拷贝构造函数
  - 拷贝赋值运算符
  - 移动构造函数
  - 移动赋值运算符
  - 析构函数

- 拷贝构造函数

  - 定义：一个构造函数的第一个参数时自身类型的引用，且任何额外参数都有默认值

    - 为什么是引用：如果是传值的话，因为一般的拷贝都是值传递，那这个值传递有会调用拷贝构造，会无限递归下去
    - 拷贝构造函数是系统会自动提供

  - 合成拷贝构造函数

    - 每个成员的类型决定了它如何拷贝，对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝

  - 拷贝初始化

    - 当直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择我们提供的参数最匹配的构造函数
    - 当拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中（如果有需要的话会进行类型转换）
    - ps：原来，在最开始的初始化的时候=调用的是拷贝初始化而不是重载的=，而后面的重新赋值才写的是operator=；而直接用已有的对象来初始化，比如A a(a1)，调用的就是拷贝构造函数
    - 拷贝初始化在下列情况下也会发生：
      - 将一个对象作为实参传递给一个非引用类型的形参（函数传参）
      - 从一个返回类型为非引用类型的函数返回一个对象（函数返回值）
      - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（花括号初始化）

  - 参数和返回值

    - 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化；当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果

  - 拷贝初始化的限制

    - 防止隐式调用拷贝构造函数explicit，即如果函数有explicit的话，就无法隐式调用了

  - 编辑器可以绕过拷贝构造函数

    - 编辑器的优化，可以跳过拷贝构造函数

    - ```cpp
      string null_book = "999-999";//拷贝初始化
      string null_book("999-999");//编译器略过了拷贝构造函数
      ```

- 拷贝赋值运算符

  - 如果类未定义自己的拷贝赋值运算符，编辑器会为它合成一个
  - 重载赋值运算符
    - 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成
    - 重载运算符的参数表示运算符的运算对象
    - 赋值运算符通常返回一个指向其左侧运算对象的引用
  - 合成拷贝赋值运算符
    - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符

- 析构函数

  - 作用：释放对象使用的资源，并销毁对象的非static数据成员
  - 特征：是一个类的成员函数，名字由波浪号类名构成，没有返回值，也不接受参数
  - 析构函数完成什么工作
    - 首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁
    - 析构函数释放对象在生存期分配的所有资源
    - 成员销毁时发生什么完全依赖于成员的类型，销毁类类型的成员需要执行成员自己的析构函数
    - 隐式销毁一个内置指针类型的成员不会delete它所指向的对象！！
  - 什么时候会调用析构函数
    - 变量在离开其作用域时被销毁
    - 当一个对象被销毁时，其成员被销毁
    - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
    - 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
    - 对于临时对象，当创建它的完整表达式结束时被销毁
    - tips：当指向一个对象的引用或指针离开作用域时，析构函数不会执行
  - 合成析构函数
    - 当一个类未定义自己的析构函数，编译器会为它定义一个合成析构函数
    - 成员是在析构函数体之后隐含的析构阶段被销毁的（在整个对象销毁过程之中，析构函数作为成员销毁步骤之外的另一部分而进行的）

- 三/五法则

  - 拷贝构造函数、拷贝赋值运算符和析构函数（三），移动构造函数，移动赋值运算符（五）
  - 需要析构函数的类也需要拷贝和赋值操作
    - 我的理解：你需要自己去析构对象，就表明编译器默认的析构你是用不了的，有些操作是要自己去释放的，那也就代表着拷贝对象和赋值对象也是一样需要人工操作的。可以参考：深拷贝和浅拷贝
    - 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数
  - 需要拷贝操作的类也需要赋值操作，反之亦然
    - 接上：有些类只需要拷贝或赋值操作，不需要析构函数（书上有例子）
    - 我的理解：拷贝一般用在对象的初始化上，那你既然都要重写一个用对象来初始化，就也会发生说对象赋值的情况，所以拷贝操作和赋值操作都是必须的

- 使用=default

  - 可以通过将拷贝控制成员定义为=default来显式要求编辑器生成合成的版本
  - 只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）

- 阻止拷贝

  - 定义删除的函数
    - 可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来组织拷贝
    - 删除的函数是这样一种函数：虽然声明了它们，但是不能以任何方式使用它们
    - 在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的
    - =delete必须出现在函数的第一次声明的时候；可以对任何函数指定=delete
  - 析构函数不能是删除的成员
    - 如果一个类由某些成员的类型删除了析构函数，就无法定义该类的变量或临时对象（对一个类的析构函数也是同理）
    - tips：对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针
  - 合成的拷贝控制成员可能是删除的
    - 总结：如果一个类有数据成员是不能默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的
    - 本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的
  - private拷贝控制
    - 在新版本之前都是把函数设为private来阻止操作的，而为了防止友元函数和成员函数访问，就把该函数设为private并且不定义
    - 总结：希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将他们声明为private

<br/>

<br/>

## 13.2 拷贝控制和资源管理

- 通常，管理类外资源的类必须定义拷贝控制成员

  - 一旦与一个类需要析构函数，那么它几乎肯定也要一个拷贝构造函数和一个拷贝赋值运算符

- 行为像值的类

  - 简述：拷贝、析构、拷贝复制运算符（注意深拷贝和浅拷贝的区别）

  - ```cpp
    //类值拷贝赋值运算符
    HasPtr& HasPtr::operator=(const HasPtr &rhs){
        auto newp = new string(*rhs.ps);//拷贝底层string
        delete ps;//释放原来的内存
        ps = newp;//从右侧运算对象拷贝数据到本对象
        i= rhs.i;
        return *this;//返回原对象
    }
    ```

  - 赋值运算符的几点：

    - 如果将一个对象赋予它自身，赋值运算符必须能正确工作
    - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

- 定义行为像指针的类

  - 注意：拷贝的应该是指针的指向
  - 所以，令一个类展现类似指针的行为的最好方法就是使用shared_ptr来管理类中的资源
  - 引用计数的工作原理：
  - 除了初始化对象之外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态，当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
  - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享
  - 析构函数递减计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
  - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户，拷贝赋值运算符就必须销毁状态

- 定义一个使用引用计数的类

<br/>

<br/>

## 13.3 交换操作

- 为了减少不必要的内存分配，所以要手写swap

- 编写我们自己的swap函数

  - 与拷贝控制成员不同，swap并不是必要的，但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段
  - 与传统的创建临时对象temp来实现swap，不如直接就交换其内部的数据就可以了

- swap函数应该调用swap，而不是std::swap

  - 这里涉及using的问题
  - 如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本

- 在赋值运算符中使用swap

  - 通过swap实现拷贝

  - ```cpp
    HasPtr& HasPtr::operator=(HasPtr rhs){
        swap(*this, rhs);
        return *this;//关键就是这里是以值传递rhs的，所以出了作用域后就会被销毁
    }
    ```

  - 使用拷贝和交换的赋值运算自动就是异常安全的，且能正确处理自赋值

<br/>

<br/>

## 13.4 拷贝控制示例

- 本节主要演示的是如何细心的根据两个类的关系，设计两个函数的接口

- ```cpp
  class Message{
      friend class Folder;//方便Folder访问其私有的属性
      public:
      	explicit Message(const std::string& str = ""):contents(str){}
          Message(const Message&);//拷贝构造函数
      	Message& operator=(const Message&);//拷贝赋值运算符
      	~Message();//析构函数
      	//从给定Folder集合中添加/删除本Message
      	void save(Folder&);
      	void remove(Folder&);
      private:
      	std::string contents;//实际消息文本
      	std::set<Folder*> folders;//包含本Message的Folder
      	//拷贝构造函数、拷贝赋值运算符和析构函数所使用的工具函数
      	void add_to_Folders(const Message&);//将本Message添加到指向参数的Folder中(拷贝的时候，把拷贝得到的副本添加到folder中)
      	void remove_from_Folders();//从folders中的每个Folders中删除本Message
  };
  
  void Message::save(Folder& f){
      folders.insert(&f);//将给定Folder添加到我们的Folder列表中
      f.addMsg(this);//将本Message添加到f的Message
  }
  
  void Message::remove(Folder& f){
      folders.erase(&f);//将给定Folder从我们的Folder列表中删除
      f.remMsg(this);//将本Message从f的Message集合中删除
  }
  
  void Message::add_to_Folders(const Message& m){//拷贝的时候会用到的
      for (auto f: m.folders){//对每个包含m的Folder
          f->addMsg(this);//向该Folder添加一个指向本Message的指针
      }
  }
  
  Message::Message(const Message& m):contens(m.contents), folders(m.folders){
      add_to_Folders(m);//将本消息添加到指向m的Folder中
  }
  
  void Message::remove_from_Folders(){//析构的时候会用到
      for (auto f :folders){
          f->remMsg(this);//对folders中的每个指针，从该Folder中删除本Message
      }
  }
  
  Message::~Message(){
      remove_form_Folders();
  }
  
  Message& Message::operator=(const Message &rhs){
      //通过先删除指针在插入它们来处理自赋值情况
      remove_from_Folders();//更新已有Folders
      contents = rhs.contents;
      folders = rhs.folders;
      add_to_Folders(rhs);//将本Message添加到那些Folder中
      return *this;
      /*
      这里解释一下为什么不会发生自我赋值的意外情况：
      如果是自我赋值的话：
      第一行是把本对象从已有的folder中全部删掉，但是注意folder还是在folders中的
      所以后面folders = rhs.folders是不改变的
      然后是add_to_Folders是根据rhs已有的folders，来重新添加关系，所以又会恢复原状了的
      */
  }
  
  void swap(Message& lhs, Message& rhs){
      using std::swap;//在本例中严格来说并不需要，但是这是一个好习惯
      //其实是利用swap的匹配性，即在这个作用域内，如果又更加适合该变量swap就会使用那个，而不是使用普适的std::swap
      //将每个消息的指针从它原来的Folder中删除
      for (auto f: lhs.folders){
          f -> remMsg(&lhs);
      }
      for (auto f: rhs.folders){
          f -> remMsg(&rhs);
      }
      //交换contents和Folder指针set
      swap(lhs.folders, ths.folders);
      swao(lhs.contents, ths.contents);
      //将每个Message的指针添加到它的新Folder中
      for (auto f:lhs.folders){
          f -> addMsg(&lhs);
      }
      for (auto f: rhs.folsers){
          f -> addMsg(&rhs);
      }
  }
  ```

<br/>

<br/>

## 13.5 动态内存管理类

<br/>

<br/>

## 13.6 对象移动

- 在其中某些情况下，对象拷贝后就立即被销毁了，在这些情况下，移动而非拷贝对象会大幅度提升性能

- 右值引用

  - 就是必须绑定到右值的引用，通过&&而不是&来获得右值引用（即：只能绑定到一个将要销毁的对象）
  - 左值和右值的区别：一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值
  - 左值引用：不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式

- 左值持久：右值短暂

  - 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象
  - 右值引用：所引用的对象将要被销毁；该对象没有其他用户
  - 总结：右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象”窃取“状态

- 变量是左值

  - 右值引用返回的是一个左值（所以不能将一个右值引用绑定到一个右值引用类型的变量上）
  - 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行

- move函数

  - 显式的将一个左值转换为对应的右值引用类型

  - ```cpp
    int rr1 = 10;//意味着除了对rr1赋值或销毁之外，我们将不再使用它
    int &&rr3 = std::move(rr1);//ok
    ```

  - 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值

- 移动构造函数和移动赋值运算符

  - 移动构造函数的第一个参数是该类类型的一个引用，这个引用参数在移动构造函数中是一个右值引用

  - 需要保证源对象的销毁是无害的

  - 一旦资源完成移动，源对象必须不再指向被移动的资源，这些资源的所有权已经归属新创建的对象

  - ```cpp
    StrVec::StrVec(StrVex &&s) noexcept:elements(s.elements), first_free(s.first_tree), cap(s.cap){
        s.elements = s.first_free = s.cap = nullptr;
    }
    ```

- 移动操作、标准库容器和异常

  - 移动操作不分配资源，因此移动操作通常不会发生异常，所以要加上noexcept
  - 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept

- 移动赋值运算符

  - ```cpp
    StrVec& StrVec::operator=(StrVec &&rhs) noexcept{
        if (this != &rhs){
            free();//释放已有元素
            elements  rhs.elements;
            first_tree = rhs.first_tree;
            cap = rhs.cap;
            rhs.elements = rhs.first_tree = rhs.cap = nullptr;
        }
        
        return *this;
    }
    ```

- 移后源对象必须可析构

  - 移后源对象置为析构安全的状态之，移动操作还必须保证对象仍然是有效的
  - 在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其进行任何假设

- 合成的移动操作

  - 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了
  - 如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作
  - 只有一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符
  - 总结：只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符
  - 在以下情况，移动构造函数或移动赋值运算符被定义为删除的
    - 有类成员定义了自己的拷贝构造函数且为定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数
    - 有类成员的移动构造函数或移动赋值运算被定义为删除或是不可访问的
    - 类的析构函数被定义为删除或不可访问的
    - 有类成员是const的或是引用
  - 总结：定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认地被定义为删除的

- 移动右值，拷贝左值

  - 对于等号，右边如果是右值的话，就调用移动赋值，否则就用拷贝赋值（前提是有移动构造和拷贝构造）

- 如果没有移动构造函数，右值也被拷贝

  - ```cpp
    class Foo{
        public:
        	Foo() = default;
        	Foo(const Foo&);
    };
    
    Foo x;
    Foo y(x);//拷贝构造函数，x是一个左值
    Foo z(std::move(x));//拷贝构造函数，因为未定义移动构造函数
    ```

  - 如果一个类有一个人可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来”移动“的。拷贝赋值运算符和移动赋值运算符的情况类似

- 拷贝并交换赋值运算符和移动操作

  - 所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作（拷贝构造函数，拷贝赋值运算符，析构函数，移动构造函数和移动赋值运算符）

- Message类的移动操作

- 移动迭代器

- 右值引用和成员函数

  - 区分移动和拷贝的重载函数通常有一个版本接受一个const T&，而另一个版本接受一个T&&

- 右值和左值引用成员函数

  - 引用限定符可以是&或是&&，分别之处this可以指向一个左值或右值，类似const限定符，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中

  - 写一个函数，为了提高性能，可以写拷贝的版本和移动的版本

  - ```cpp
    class StrVec{
        public:
        	void push_back(const std::string&);//拷贝元素
        	void push_back(std::string&&);//移动元素
    };
    
    StrVec vec;
    std::string s = "hello world!";
    vec.push_back(s);//调用push_back(const string&)
    vec.push_back("done");//调用push_back(s)
    ```

- 重载和引用函数

  - 就像一个成员函数可以根据是否有const来区分重载版本一样，引用限制符也可以区分重载版本

  - ```cpp
    class Foo{
        public:
        	Foo sorted() &&;//可以用于可改变的右值
        	Foo sorted() const &;//可用于任何类型的Foo
        private:
        	vector<int> data;
    };
    
    Foo Foo::sorted() &&{//本对象是右值，因此可以原址排序
        sort(data.begin(), data.end());
    }
    
    //本对象是const或是一个左值，所以无论是哪种都不可以原址排序
    Foo Foo::sorted() const &{
        Foo ret(*this);
        sort(ret.data.begin(), ret.data.end());
        return ret;
    }
    ```

  - 如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者都不加

  - 我的理解：可以认为添加了&&和&引用限定符，是实现了一种重载。有&&的表示接受的是一个右值，而有&的表示接受的是一个左值或const类型

  - 总结：如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符