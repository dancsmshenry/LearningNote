# 第2章 变量和基本类型

## 2.1 基本内置类型

- 基本算术类型

  | 类型      | 含义                   |
  | --------- | ---------------------- |
  | bool      | 布尔类型               |
  | char      | 字符                   |
  | short     | 短整型                 |
  | int       | 整型                   |
  | long      | 长整型（最小尺寸32位） |
  | long long | 长整型（最小尺寸64位） |
  | float     | 单精度浮点数           |
  | double    | 双精度浮点数           |

- 带符号类型和无符号类型

  - 类型`int、short、long和long long`都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型
  - 而字符型则被分为`char、signed char和unsigned char`
  - 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数

- 类型转换

  - 浮点数和整数：
    - 浮点数->整数，结果仅保留浮点数中小数点之前的部分
    - 整数->浮点数，小数部分记为0
  - 布尔类型：
    - 非布尔类型->布尔类型

- 字面值常量

  - 字符和字符串字面值
    - 用单引号括起来的一个字符为char型字面值，双引号括起来的零个或多个字符为字符串字面值
  - 转义序列
    - 在c++语言中有特殊含义的字符是不能直接使用的，在这些情况下需要用到转义序列
    - 转义序列均以反斜杠开始，如`\n`表示换行，`\"`表示双引号，`\'`表示单引号
  - 指定字面值类型
    - 通过前缀或后缀可以改变整型、浮点型和字符型字面值的默认类型
    - 如对于整型，前缀`ll`可以表示`long long`，前缀`l`可以表示`long`



## 2.2 变量

- 命名规范
  - 需要由字母、数字和下划线组成，同时对大小写敏感
  - 变量名一般用小写字母，类名一般用大写字母开头
- 变量声明和定义的关系
  - **声明**使得名字为程序所知，**定义**负责创建于名字关联的实体
  - 变量能且只能被定义一次，但是可以被多次声明

```c++
extern int i;//是声明i而不是定义i
int j;//声明并定义了j
```

- 初始值
  - 当对象在创建时候获得了一个特定的值，这个对象就被初始化了
  - 初始化不是赋值，赋值是指把对象的当前值擦除，而以一个新值代替
- 初始化的几种方式

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```



## 2.3 复合类型

- 引用
  - 引用即为对象起了另外一个名字
  - 引用通常是将声明写成`&d`的形式来定义引用类型，其中d是声明的变量名
  - 因为引用本身不是一个对象，所以不能定义引用的引用
  - 引用类型的初始值必须是一个对象，且类型要与原对象相同

```c++
int a = 1024;
int &a1 = a;//a1是a的一个引用
cout << a1 << endl;//1024
a ++ ;
cout << a1 << endl;//1025，可以看出引用的本质
```

- 指针
  - 指针本身是一个对象，允许对指针赋值或拷贝，所以可以指向不同的对象（但是指针类型要与指向的对象的类型相同）
  - 指针的含义是存放着某个对象的地址
  - 指针无须再定义时赋值
  - 通常是将声明符写成`*d`的形式，其中d是变量名，如果一条语句中定义了几个指针变量，每个变量前面都要有`*`

```c++
int a = 2047;
int *a1;//定义一个指向int型对象的指针

a1 = &a;//a1存放a的地址，也可以说a1是指向a的指针
//&是取地址符，用于获取对象的具体地址
//注意：&在定义的类型的后买你是声明的一部分，而在表达式中是取地址符

cout << *a1 << endl;//2047
//*是解引用符号，用于获取指针所指向的对象的值
//注意：*在定义中的类型的后面是声明的一部分，而在表达式中的是解引用符

*a1 = 0;//通过对*a1进行赋值，从而改变a的值


int *p1 = 0;
int *p2 = nullptr;
//上面两条语句都表示空指针（需要首先#include <cstdlib>）

int *pi;
int zero = 0;
p1 = zero;//虽然zero=0，但还是不可以把int变量直接赋给指针


void *pv = &obj;//这里定义的是一个特殊的指针类型，obj可以指向任意类型的对象，即pv可以存放任意类型指针


int ival = 1024;
int *pi = &ival;
int **ppi = &pi;//可以定义指向指针的指针

int i = 42;
int *p;
int * &r = p;//r是一个对指针p的引用
```



## 2.4 `const`限定符

- `const`是指把一个变量变为常量

- 与define的区别
  - `const`常量有数据类型，而define定义宏常量没有数据类型
  - define宏是在预处理阶段展开，`const`常量则是编译运行阶段使用
  - define宏仅仅是展开，有几个地方使用则展开几次，不分配内存；`const`常量会在内存中分配地址（可以是堆中也可以是栈中）
  - define定义的常量在内存中有若干个拷贝，`const`定义的常量在程序运行过程中只有一份拷贝，甚至不为普通`const`常量分配存储空间，而是将它们保存在符号表中，相当于没有了读内存的操作，使得效率也很高



## 2.5 处理类型

- 类型别名

  - 是某种类型的同义词，使用类型别名可以使复杂的类型名字变得简洁明了

  ```c++
  typeof double wages;//typeof命名
  using SH = short;//用using命名，简称别名声明
  ```

  - 和define的区别：
    - #define是 C 中定义的语法, typedef 是 C++ 中定义的语法, 二者在 C++ 中可以通用
    - 但 #define 成了预编译指令, typedef 当成语句处理

- `auto`类型说明符

  - 有时声明变量的时候很难知道表达式的类型，就可以用`auto`来让编辑器替我们分析所属类型
  - 所声明的变量一定有初始值
  - 可以同时声明多个变量，但数据类型一定要相同

```c++
int i = 1;
auto j = i * 2047;//即j的类型就是int
```

- `decltype`类型指示符
  - 希望从表达式的类型推断处要定义的变量的类型，但是不想用该表达式的值初始化变量

```c++
decltype(f()) sum = x;//sum的类型就是函数f的返回类型
```



## 2.6 自定义数据类型

- 定义一个结构体

  ```c++
  struct Sales_data{
    	string bookNo;
      unsigned units_sold = 0;
      double revence = 0.0;
  };
  ```

- 使用结构体中的

  ```c++
  Sales_data data1, data2;cin >> data1.bookNo >> data1.units_sold;
  ```




# 第3章 字符串、向量和数组

## 3.1 命名空间的`using`声明

- 使用某个命名空间：例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。
- 头文件中不应该包含`using`声明
  - 这是因为头文件的内容会拷贝到所有引用它的文件中，可能会引起名字的冲突

## 3.2 标准库类型`string`

- `string`表示可变长的字符序列

- 注意要用头文件`#include <string>`

- 定义和初始化string对象

  - | 方式                  | 解释                                                    |
    | --------------------- | ------------------------------------------------------- |
    | `string s1`           | 默认初始化，`s1`是个空字符串                            |
    | `string s2(s1)`       | `s2`是`s1`的副本                                        |
    | `string s2 = s1`      | 等价于`s2(s1)`，`s2`是`s1`的副本                        |
    | `string s3("value")`  | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
    | `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本          |
    | `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串                |

  - 拷贝初始化：使用等号`=`将一个已有的对象拷贝到正在创建的对象

  - 直接初始化：通过括号给对象赋值

- `string`的操作：

  - | 操作                 | 解释                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | `os << s`            | 将`s`写到输出流`os`当中，返回`os`                            |
    | `is >> s`            | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is`        |
    | `getline(is, s)`     | 从`is`中读取一行赋给`s`，返回`is`                            |
    | `s.empty()`          | `s`为空返回`true`，否则返回`false`                           |
    | `s.size()`           | 返回`s`中字符的个数                                          |
    | `s[n]`               | 返回`s`中第`n`个字符的引用，位置`n`从0计起                   |
    | `s1+s2`              | 返回`s1`和`s2`连接后的结果                                   |
    | `s1=s2`              | 用`s2`的副本代替`s1`中原来的字符                             |
    | `s1==s2`             | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
    | `s1!=s2`             | 同上                                                         |
    | `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感         |

  - 执行读操作`>>`：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止

  - `getline`：读取一整行，**包括空白符**

- 处理string对象中的字符

  - `cctype`头文件中定义了一组标准函数：

  - | 函数          | 解释                                                         |
    | ------------- | ------------------------------------------------------------ |
    | `isalnum(c)`  | 当`c`是字母或数字时为真                                      |
    | `isalpha(c)`  | 当`c`是字母时为真                                            |
    | `iscntrl(c)`  | 当`c`是控制字符时为真                                        |
    | `isdigit(c)`  | 当`c`是数字时为真                                            |
    | `isgraph(c)`  | 当`c`不是空格但可以打印时为真                                |
    | `islower(c)`  | 当`c`是小写字母时为真                                        |
    | `isprint(c)`  | 当`c`是可打印字符时为真                                      |
    | `ispunct(c)`  | 当`c`是标点符号时为真                                        |
    | `isspace(c)`  | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
    | `isupper(c)`  | 当`c`是大写字母时为真                                        |
    | `isxdigit(c)` | 当`c`是十六进制数字时为真                                    |
    | `tolower(c)`  | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c`         |
    | `toupper(c)`  | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c`         |

- 遍历字符串：

  - 使用 `for (auto c: str)`，或者 `for (auto &c: str)`使用引用直接改变字符串中的字符



## 3.3 标准库类型`vector`

- vector是一个容器，也是一个类模板

- 注意头文件`#include <vector>` 然后 `using std::vector`

- 容器：包含其他对象。

- 类模板：本身不是类，但可以**实例化instantiation**出一个类。 `vector`是一个模板， `vector<int>`是一个类型

- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`

- 初始化`vector`对象的方法

  - | 方法                        | 解释                                                         |
    | --------------------------- | ------------------------------------------------------------ |
    | `vector<T> v1`              | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
    | `vector<T> v2(v1)`          | `v2`中包含有`v1`所有元素的副本                               |
    | `vector<T> v2 = v1`         | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本                 |
    | `vector<T> v3(n, val)`      | `v3`包含了n个重复的元素，每个元素的值都是`val`               |
    | `vector<T> v4(n)`           | `v4`包含了n个重复地执行了值初始化的对象                      |
    | `vector<T> v5{a, b, c...}`  | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
    | `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}`                                       |

- 列表初始化： `vector<string> v{"a", "an", "the"};`

- `v.push_back(e)` 在尾部增加元素

- 其他`vector`的操作：

- | 操作               | 解释                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | `v.emtpy()`        | 如果`v`不含有任何元素，返回真；否则返回假                    |
  | `v.size()`         | 返回`v`中元素的个数                                          |
  | `v.push_back(t)`   | 向`v`的尾端添加一个值为`t`的元素                             |
  | `v[n]`             | 返回`v`中第`n`个位置上元素的**引用**                         |
  | `v1 = v2`          | 用`v2`中的元素拷贝替换`v1`中的元素                           |
  | `v1 = {a,b,c...}`  | 用列表中元素的拷贝替换`v1`中的元素                           |
  | `v1 == v2`         | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
  | `v1 != v2`         | 同上                                                         |
  | `<`,`<=`,`>`, `>=` | 以字典顺序进行比较                                           |

- 范围`for`语句内不应该改变其遍历序列的大小。

- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素（所以才有`push_back`）

## 3.4 迭代器介绍

- 所有标准库容器都可以使用迭代器

- 类似于指针类型，迭代器也提供了对对象的间接访问

- `auto b = v.begin();`返回指向第一个元素的迭代器。

- `auto e = v.end();`返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）

- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器

- 使用解引用符`*`访问迭代器指向的元素

- **容器**：可以包含其他对象；但所有的对象必须类型相同

- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素

- **const_iterator**：只能读取容器内元素不能改变

- **箭头运算符**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`

- **谨记**：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

- 标准容器迭代器的运算符:

  - | 运算符           | 解释                                   |
    | ---------------- | -------------------------------------- |
    | `*iter`          | 返回迭代器`iter`所指向的**元素的引用** |
    | `iter->mem`      | 等价于`(*iter).mem`                    |
    | `++iter`         | 令`iter`指示容器中的下一个元素         |
    | `--iter`         | 令`iter`指示容器中的上一个元素         |
    | `iter1 == iter2` | 判断两个迭代器是否相等                 |

- 迭代器运算

  - | 运算符               | 解释                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | `iter + n`           | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
    | `iter - n`           | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
    | `iter1 += n`         | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1`      |
    | `iter1 -= n`         | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1`      |
    | `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
    | `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器                             |



## 3.5 数组

- vector的低配版，长度固定

- 初始化：`char input_buffer[buffer_size];`，长度必须是`const`表达式，或者不写
- 数组不允许直接赋值给另一个数组
- 数组的访问
  - 数组下标的类型：`size_t` 。
  - 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。
- 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 

- 与指针的关系
  - 使用数组时，编译器一般会把它转换成指针
  - 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值
  - **指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针

- C风格字符串
  - 从C继承来的字符串
  - 用空字符结束（`\0`）
  - 对大多数应用来说，使用标准库 `string`比使用C风格字符串更安全、更高效
  - 获取 `string` 中的 `cstring` ： `const char *str = s.c_str();` 
  - C标准库String函数，定义在`<cstring>` 中：

| 函数             | 介绍                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`                               |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                                   |

## 3.6 多维数组

- 多维数组的初始化： `int ia[3][4] = {{0,1,2,3}, ...}`

- 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型

- 动态数组

  - 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间

  - 定义： `int *pia = new int[10];` 10可以被一个变量替代

  - 释放： `delete [] pia;`，注意不要忘记`[]`第三章 字符串、向量和数组

    ### 3.1命名空间的`using`声明

    - 使用某个命名空间：例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。
    - 头文件中不应该包含`using`声明
      - 这是因为头文件的内容会拷贝到所有引用它的文件中，可能会引起名字的冲突

    ### 3.2标准库类型`string`

    - `string`表示可变长的字符序列

    - 注意要用头文件`#include <string>`

    - 定义和初始化string对象

      - | 方式                  | 解释                                                    |
        | --------------------- | ------------------------------------------------------- |
        | `string s1`           | 默认初始化，`s1`是个空字符串                            |
        | `string s2(s1)`       | `s2`是`s1`的副本                                        |
        | `string s2 = s1`      | 等价于`s2(s1)`，`s2`是`s1`的副本                        |
        | `string s3("value")`  | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
        | `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本          |
        | `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串                |

      - 拷贝初始化：使用等号`=`将一个已有的对象拷贝到正在创建的对象

      - 直接初始化：通过括号给对象赋值

    - `string`的操作：

      - | 操作                 | 解释                                                         |
        | -------------------- | ------------------------------------------------------------ |
        | `os << s`            | 将`s`写到输出流`os`当中，返回`os`                            |
        | `is >> s`            | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is`        |
        | `getline(is, s)`     | 从`is`中读取一行赋给`s`，返回`is`                            |
        | `s.empty()`          | `s`为空返回`true`，否则返回`false`                           |
        | `s.size()`           | 返回`s`中字符的个数                                          |
        | `s[n]`               | 返回`s`中第`n`个字符的引用，位置`n`从0计起                   |
        | `s1+s2`              | 返回`s1`和`s2`连接后的结果                                   |
        | `s1=s2`              | 用`s2`的副本代替`s1`中原来的字符                             |
        | `s1==s2`             | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
        | `s1!=s2`             | 同上                                                         |
        | `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感         |

      - 执行读操作`>>`：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止

      - `getline`：读取一整行，**包括空白符**

    - 处理string对象中的字符

      - `cctype`头文件中定义了一组标准函数：

      - | 函数          | 解释                                                         |
        | ------------- | ------------------------------------------------------------ |
        | `isalnum(c)`  | 当`c`是字母或数字时为真                                      |
        | `isalpha(c)`  | 当`c`是字母时为真                                            |
        | `iscntrl(c)`  | 当`c`是控制字符时为真                                        |
        | `isdigit(c)`  | 当`c`是数字时为真                                            |
        | `isgraph(c)`  | 当`c`不是空格但可以打印时为真                                |
        | `islower(c)`  | 当`c`是小写字母时为真                                        |
        | `isprint(c)`  | 当`c`是可打印字符时为真                                      |
        | `ispunct(c)`  | 当`c`是标点符号时为真                                        |
        | `isspace(c)`  | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
        | `isupper(c)`  | 当`c`是大写字母时为真                                        |
        | `isxdigit(c)` | 当`c`是十六进制数字时为真                                    |
        | `tolower(c)`  | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c`         |
        | `toupper(c)`  | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c`         |

    - 遍历字符串：

      - 使用 `for (auto c: str)`，或者 `for (auto &c: str)`使用引用直接改变字符串中的字符

    

    ### 3.3标准库类型`vector`

    - vector是一个容器，也是一个类模板

    - 注意头文件`#include <vector>` 然后 `using std::vector`

    - 容器：包含其他对象。

    - 类模板：本身不是类，但可以**实例化instantiation**出一个类。 `vector`是一个模板， `vector<int>`是一个类型

    - 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`

    - 初始化`vector`对象的方法

      - | 方法                        | 解释                                                         |
        | --------------------------- | ------------------------------------------------------------ |
        | `vector<T> v1`              | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
        | `vector<T> v2(v1)`          | `v2`中包含有`v1`所有元素的副本                               |
        | `vector<T> v2 = v1`         | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本                 |
        | `vector<T> v3(n, val)`      | `v3`包含了n个重复的元素，每个元素的值都是`val`               |
        | `vector<T> v4(n)`           | `v4`包含了n个重复地执行了值初始化的对象                      |
        | `vector<T> v5{a, b, c...}`  | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
        | `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}`                                       |

    - 列表初始化： `vector<string> v{"a", "an", "the"};`

    - `v.push_back(e)` 在尾部增加元素

    - 其他`vector`的操作：

    - | 操作               | 解释                                                         |
      | ------------------ | ------------------------------------------------------------ |
      | `v.emtpy()`        | 如果`v`不含有任何元素，返回真；否则返回假                    |
      | `v.size()`         | 返回`v`中元素的个数                                          |
      | `v.push_back(t)`   | 向`v`的尾端添加一个值为`t`的元素                             |
      | `v[n]`             | 返回`v`中第`n`个位置上元素的**引用**                         |
      | `v1 = v2`          | 用`v2`中的元素拷贝替换`v1`中的元素                           |
      | `v1 = {a,b,c...}`  | 用列表中元素的拷贝替换`v1`中的元素                           |
      | `v1 == v2`         | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
      | `v1 != v2`         | 同上                                                         |
      | `<`,`<=`,`>`, `>=` | 以字典顺序进行比较                                           |

    - 范围`for`语句内不应该改变其遍历序列的大小。

    - `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素（所以才有`push_back`）

    ### 3.4迭代器介绍

    - 所有标准库容器都可以使用迭代器

    - 类似于指针类型，迭代器也提供了对对象的间接访问

    - `auto b = v.begin();`返回指向第一个元素的迭代器。

    - `auto e = v.end();`返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）

    - 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器

    - 使用解引用符`*`访问迭代器指向的元素

    - **容器**：可以包含其他对象；但所有的对象必须类型相同

    - **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素

    - **const_iterator**：只能读取容器内元素不能改变

    - **箭头运算符**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`

    - **谨记**：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

    - 标准容器迭代器的运算符:

      - | 运算符           | 解释                                   |
        | ---------------- | -------------------------------------- |
        | `*iter`          | 返回迭代器`iter`所指向的**元素的引用** |
        | `iter->mem`      | 等价于`(*iter).mem`                    |
        | `++iter`         | 令`iter`指示容器中的下一个元素         |
        | `--iter`         | 令`iter`指示容器中的上一个元素         |
        | `iter1 == iter2` | 判断两个迭代器是否相等                 |

    - 迭代器运算

      - | 运算符               | 解释                                                         |
        | -------------------- | ------------------------------------------------------------ |
        | `iter + n`           | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
        | `iter - n`           | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
        | `iter1 += n`         | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1`      |
        | `iter1 -= n`         | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1`      |
        | `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
        | `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器                             |

    

    ### 3.5数组

    - vector的低配版，长度固定

    - 初始化：`char input_buffer[buffer_size];`，长度必须是`const`表达式，或者不写
    - 数组不允许直接赋值给另一个数组
    - 数组的访问
      - 数组下标的类型：`size_t` 。
      - 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。
    - 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 

    - 与指针的关系
      - 使用数组时，编译器一般会把它转换成指针
      - 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值
      - **指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针

    - C风格字符串
      - 从C继承来的字符串
      - 用空字符结束（`\0`）
      - 对大多数应用来说，使用标准库 `string`比使用C风格字符串更安全、更高效
      - 获取 `string` 中的 `cstring` ： `const char *str = s.c_str();` 
      - C标准库String函数，定义在`<cstring>` 中：

    | 函数             | 介绍                                                         |
    | ---------------- | ------------------------------------------------------------ |
    | `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
    | `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
    | `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`                               |
    | `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                                   |

    ### 3.6多维数组

    - 多维数组的初始化： `int ia[3][4] = {{0,1,2,3}, ...}`
    - 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型

    - 动态数组
      - 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间
      - 定义： `int *pia = new int[10];` 10可以被一个变量替代
      - 释放： `delete [] pia;`，注意不要忘记`[]`



# 第4章 表达式

## 4.1 基础

- 重载运算符：当运算符作用在类类型的运算对象时，用户可以自行定义其含义
- 左值和右值：
  - `C`：左值**可以**在表达式左边，右值不能
  - `C++`：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）
  - 被用做**左值**时，用的是对象的**身份**（在内存中的位置）



## 4.2 算术运算符

```c++
a + b;
a - b;
a * b;

a / b;//代表的是整除，即得到的是一个整数
{
    21 / -5 = -4;
    -21 / -8 = 2;
}

a % b;//求余，注意存在负数的情况
{
    21 % -5 = 1;
    -21 % -8 = -5;
}

+a;//正号
-a;//负号
```



## 4.3 逻辑和关系运算符

```c++
a < b;//小于
a <= b;//小于等于
a > b;//大于
a >= b;//大于等于
a == b;//相等
a != b;//不相等
a && b;//表示逻辑关系中的和，当且仅当二者都为真的时候才为真（所以前面是假的时候就不会继续往下算了）
a || b;//表示逻辑关系中的或，当且仅当二者都为假的时候才为假
! a;//表示逻辑关系中的非，注意只要a不是0，!a一定为假
```



## 4.4 赋值运算符

- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型（参考类型转换）
- 赋值运算符满足右结合律，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`



## 4.5 递增和递减运算符

```c++
a ++;//表示a会先进行部分操作，然后再在原来的基础上加上1
++ b;//表示先让b在原来的基础上加上1，然后再进行操作（优先使用这个，参考原理，迭代器）
a --;//同理
-- b://同理
```



## 4.6 成员访问运算符

```c++
string s1 = "a string", *p = &s1;
auto n = s1.size();//点运算符获取类对象的一个成员
n = (*p).size();//运行p所指对象的size成员
n = p -> size();//与上一句等价
```



## 4.7 条件运算符

```c++
c = (a > b) ? a : b;//等价于一个if语句
```



## 4.8 位运算符

```c++
a = 1;
b = 0;
~a = 0;//位取反符号，先将数值转化为二进制数，然后再全部取反位
a >> 1 = 0;//右移位，先将数值转化为二进制数，然后全体向右边移一位，即除以二
a << 1 = 2;//左移位，先将数值转化为二进制数，然后全体向左边移一位，即乘以二
a & b = 0;//先将数值转化为二进制数，然后按照逻辑关系中的和运算进行比较
a | b = 1;//同理
a ^ b = 1;//同理，不过只有二者不同的时候才会为1
```



## 4.9 sizeof运算符

- 返回一条表达式或一个类型名字所占的字节数，返回的类型是 `size_t`
- `sizeof (type)`和 `sizeof expr`



## 4.10 逗号运算符



## 4.11 类型转换

- 隐式转换
  - 比 `int`类型小的整数值先提升为较大的整数类型
  - 条件中，非布尔转换成布尔
  - 初始化中，初始值转换成变量的类型
  - 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型



# 第5章 语句

## 5.1 简单语句

- 空语句：只有一个分号

```c++
;
```

- 复合语句块：用花括号 `{}`包裹起来的语句和声明的序列。一个块就是一个作用域

```c++
while (val <= 10){
    sum += val;
    ++ val;
}
```

- 空块

```c++
while (cin >> s && s!= sought){
    
}
```

- 注意：不一定所有的语句都会以分号结尾

```c++
for (int i = 0; i < 100; ++ i){
    i1 = i * i, i2 = i * i * i;
}
```



## 5.2 语句作用域



## 5.3 条件语句

- `if`语句

  - ```c++
    if (val < 0){
        
    }
    else{
        
    }//第一种情况
    
    if (val < 0){
        
    }
    else if (val == 0){
        
    }
    else if (val > 10){
        
    }
    else{
        
    }//第二种情况
    ```

  - 当有多个else和if的时候遵循的规则：else与离它最近的尚未匹配的if匹配

- `switch`语句

  - ```c++
    unsigned a = 0, e = 0, i = 0, o = 0, u = 0;
    char ch;
    while (cin >> vh){
        switch(ch){
            case 'a':
                a ++ ;
                break;
            case 'e':
                e ++ ;
                break;
            case 'i':
                i ++ ;
                break;
            case 'o':
                o ++ ;
                break;
            case 'u':
                u ++ ;
                break;
        }
    }
    ```

  - default标签：如果上面的情况都不符合，就执行这个

    - ```c++
      switch (ch){
          case'a':case 'e':case'i':case'o':case'u':
              ++ vowelCnt;
              break;
          default:
              ++ otherCnt;//当ch不属于aeioou其中的任何一个的时候
              break;
      }
      ```



## 5.4 迭代语句

- while语句

```c++
while (a != 100){
    sum += a;
    ++ a;
}
//()里面的值为布尔值
```

- 传统的for语句

```c++
for (int i = 0; i < 100; i ++ ){    sum += i;}//(, , )三部分组成：声明语句，条件判断语句和操作语句//这三个语句都可以为空语句
```

- 范围for语句

```c++
vector<int> v = {0, 1, 2, 3, 4}for (auto &r : v){    r *= 2;//对于v中的每个元素，都翻倍}//等价于for (auto beg = v.begin(), end = v.end())
```

- do while语句

```c++
do{    //statement}while (condition);
```



## 5.5 跳转语句

- break语句
  - 终止离它最近的while、do while、for或者switch语句，并从这些语句之后的第一条语句执行

- continue语句
  - 终止最近的循环中的当前迭代并立即开始下一次迭代

- goto语句
  - 基本不用这个语句
    - 程序的可读性会被降低（从上往下读，然后还有时不时往回看），同时用不好会使程序逻辑混乱



## 5.6 TRY语句块和异常处理

- throw表达式

  - 异常检测部分使用 `throw`表达式来表示它遇到了无法处理的问题。我们说 `throw`引发 `raise`了异常

  - ```c++
    //首先检查两条语句是否相同if (item1.isbn() != item2.isbn())    throw runtime_error("Data must refer to same ISBN");cout << item1 + item2 << endl;
    ```

- try语句块

  - 以 `try`关键词开始，以一个或多个 `catch`字句结束。 `try`语句块中的代码抛出的异常通常会被某个 `catch`捕获并处理。 `catch`子句也被称为异常处理代码

  - ```c++
    try{    //填写需要测试的语句} catch (出现了什么异常){    //出现该异常后需要执行的操作}
    ```

- 标准异常

  - 需要记住一下几个常见的异常处理文件：

    - ```c++
      #include <exception>#include <stdexcept>#include <new>#include <type_info>
      ```



# 第6章 函数

## 6.1 函数基础

- 函数定义
  - 包括返回类型、函数名字和0个或者多个形参组成的列表和函数体
- 调用运算符
  - 调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针
- 函数调用过程：
  - 首先是主调函数的执行被中断
  - 接着被调函数开始执行
- 形参和实参
  - 形参和实参的**个数**和**类型**必须匹配上
- 返回类型
  - `void`表示函数不返回任何值。函数的返回类型不能是数组类型或者函数类型，但也可以是指向数组或者函数的指针

- 生命周期
  - 对象的生命周期是程序执行过程中该对象存在的一段时间
- 局部变量
  - 形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是隐藏的
- 自动对象
  - 只存在于块执行期间的对象。当块的执行结束后，它的值就变成未定义的了
- 局部静态对象
  -  `static`类型的局部变量，生命周期贯穿函数调用前后

- 函数声明
  - 函数的声明和定义唯一的区别是声明无需函数体，用一个分号替代。函数声明主要用于描述函数的接口，也称函数原型



## 6.2 参数传递

- 形参初始化的机理和变量初始化一样。
- **引用传递**：又称传引用调用，指**形参是引用类型**，引用形参是它对应的实参的别名
- **值传递**：又称传值调用，指实参的值是通过**拷贝**传递给形参

- 传值参数
  - 当初始化一个非引用类型的变量时，初始值被拷贝给变量
  - 函数对形参做的所有操作都不会影响实参
  - **指针形参**：常用在C中，`C++`建议使用引用类型的形参代替指针

- 传引用参数
  - 通过使用引用形参，允许函数改变一个或多个实参的值
  - 引用形参直接关联到绑定的对象，而非对象的副本
  - 使用引用形参可以用于**返回额外的信息**
  - 经常用引用形参来避免不必要的复制
  - `void swap(int &v1, int &v2)`
  - 如果无需改变引用形参的值，最好将其声明为常量引用

- `const`形参和实参
  - 形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`
  - 我们可以使用非常量初始化一个底层`const`对象，但是反过来不行
  - 尽量使用常量引用

- 数组形参
  - 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针
  - 要注意数组的实际长度，不能越界

- 可变形参
  - `initializer_list`提供的操作（`C++11`）：

| 操作                                 | 解释                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `initializer_list<T> lst;`           | 默认初始化；`T`类型元素的空列表                              |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)`                          | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst`                         | 同上                                                         |
| `lst.size()`                         | 列表中的元素数量                                             |
| `lst.begin()`                        | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                          | 返回指向`lst`中微元素下一位置的指针                          |

- `initializer_list`使用demo：

```
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay});
```

- 所有实参类型相同，可以使用 `initializer_list`的标准库类型。
- 实参类型不同，可以使用`可变参数模板`。
- 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。



## 6.3 返回类型和return语句

- 无返回值

没有返回值的 `return`语句只能用在返回类型是 `void`的函数中，返回 `void`的函数可以没有 `return`语句

- 有返回值

  - `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型

  - 值的返回：返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果

  - 最好不要返回局部对象的引用或指针

    - ```c++
      const string &manip(){
          return "Hello World!";//错误，返回类型应该是const string，不能返回局部临时量
      }
      ```

  - 引用返回左值：函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值；其他返回类型得到右值。

  - 返回数组指针

    - `Type (*function (parameter_list))[dimension]`

    - 使用类型别名： `typedef int arrT[10];` 或者 `using arrT = int[10;]`，然后 `arrT* func() {...}`

    - 使用 `decltype`： `decltype(odd) *arrPtr(int i) {...}`




## 6.4 函数重载

- 含义：如果同一作用域内几个函数名字相同但形参列表不同，我们称之为重载函数
- `main`函数不能重载
- 重载和``const`形参:

  - 一个有顶层`const`的形参和没有它的函数无法区分。 `Record lookup(Phone* const)`和 `Record lookup(Phone*)`无法区分
- 相反，是否有某个底层`const`形参可以区分。 `Record lookup(Account*)`和 `Record lookup(const Account*)`可以区分
- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名



## 6.5 特殊用途语言特性

- 默认实参
  - `string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');`
  - 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值

- 内联（inline）函数
  - 普通函数的缺点：调用函数比求解等价表达式要慢得多
  - `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数
  - `inline`函数应该在头文件中定义

- constexpr函数
  - 指能用于常量表达式的函数。
  - `constexpr int new_sz() {return 42;}`
  - 函数的返回类型及所有形参类型都要是字面值类型。
  - `constexpr`函数应该在头文件中定义



## 6.6 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配。
- **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。
- **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数（viable function）。
- **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好。

## 6.7 函数指针

- **函数指针**：是指向函数的指针。

- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。

- 函数指针形参

  ：

  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。

- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。





```c++
#include <iostream>

using namespace std;

int test01(int a, int b){
    return a > b ? a : b;
}

int test02(int a, int b, int(*p)(int, int)){
    return p(a, b);
}

int main(){
    int (*p)(int, int);
    p = test01;

    cout << test02(10, 9, p);
}

#include <iostream>

using namespace std;

int func1(const int a);
int func1(int a);//这两个函数声明是一样的

int main(){

}
```





# 第7章 类

## 7.1 定义抽象数据类型

- 类的基本思想是数据抽象和封装

- 数据抽象是一种依赖于接口和实现分离的编程技术

- 定义成员函数

- 引入this

  - 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象

- 引入const成员函数

  - 紧跟在参数列表后面的const表示this是一个指向常量的指针，像这样使用const的成员函数被称为常量成员函数
  - 即不能修改该对象的属性

- 构造函数

  - 类通过一个或几个特殊的成员函数来控制其对象的初始化过程

  - 默认构造函数（无需任何实参）

    - 合成的默认构造函数

  - 构造函数不能被写为const

  - 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数

  - 如果需要编译器生成默认构造函数

    - ```c++
      Sales_data() = default;
      ```

  - 构造函数初始值列表

  - 在类的外部定义构造函数

  - 拷贝，赋值和析构函数

  - 



## 7.2 访问控制与封装

- 访问说明符：public,private,protected
- class默认的访问权限是private，struct默认的访问权限是public
- 友元：类允许其他类或者函数访问它的非公有成员
  - 友元声明只能出现在类定义的内部



## 7.3 类的其他特性

- 定义在类内的成员函数都是自动的inline

- 可变数据成员

  - 写了一个函数是const的常函数，但是有些数据是需要在这个函数里面改变的

  - 那就把这个数据设为可变数据

  - ```c++
    mutable int a;//mutable表示该数据是一个可变数据
    ```

- 类的成员函数

  - 如果提供了构造函数，那么编译器就不会提供默认的构造函数了

  - 如果需要编译器提供默认的构造函数，就要声明出来

  - ```c++
    Screen() = default;//告诉编译器为我们提供默认构造函数
    ```

- 定义一个类型成员

  - ```c++
    typedef std::string::size_type pos;//使用类型别名等价地声明一个类型名字
    using pps = std::string;//同理
    ```

  - 类定义的类型名字和其他成员一样存在访问权限的限制

- 返回*this的成员函数

  - 如果要链式编程的话，就必须以引用的形式返回对象
  - 将this对象作为左值返回

- 从const成员函数返回*this

  - 如果返回的是const Sales_data&的话，那么就不能够链式编程了，因为返回对象是const

- 基于const的重载

  - 可以用const来重载函数

- 类类型

  - 即使两个类的成员列表完全一致，它们也是不同的类型

- 类的声明

  - 也叫做前向声明
  - 在它声明之后定义之前是一个不完全类型

- 类之间的友元关系

  - 把一个类声明为自己的友元类

  - ```c++
    class Screen{
        
    };
    
    class Window_mgr{
        friend class Screen;
    }
    ```

  - 友元关系是不具备传递性的，每个类负责控制自己的友元类和友元函数

- 令成员函数作为友元

  - ```c++
    class Screen{
        friend void Window_mgr::clear(int);
    }
    ```

- 函数重载和友元

  - ```c++
    extern int& storeOn(string, int);
    extern double& storeOn(int);
    
    class Screen{
      friend int& storeOn()  
    }
    ```



## 7.4 类的作用域

- 作用域和定义在类外部的成员

  - 函数成员可以声明在类内，定义在类外

  - ```c++
    void Window_mgr::clear(int i){
        
    }
    ```

- 名字查找：

  - 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明
  - 如果没有找到，继续查找外层作用域
  - 如果最终没有找到匹配的声明，则程序报错

- 对于定义在类内部的函数

  - 首先，编译成员的声明
  - 知道类全部可见后才编译函数体

- 用于类成员声明的名字查找

- 类型名要特殊处理

  - 已经在类外定义了的类型名就不能在类内重新定义

- 成员定义中的普通块作用域的名字查找

  - 首先，在成员函数内查找该名字的声明，和前面一样，只有在函数使用之前出现的声明才被考虑
  - 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑
  - 如果类内也没找到该名字的声明，在成员函数定义之前的作用域继续查找
  - 尽管类的成员被隐藏了，但我们仍可以通过加上类的名字或显著地使用this指针来强制访问类成员

- 类作用域之后，在外围的作用域中查找



## 7.5 构造函数再探

- 构造函数初始化列表

  - 如果成员是const，引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初始值
  - 即用列表初始化成员，可以显式地初始化引用和const成员

- 成员初始化的顺序

  - 事实上，在编译器内部，并不是说按照代码的顺序初始化 初始化列表的，所以要尽量避免使用某些成员初始化其他成员

- 默认实参和构造函数

  - 构造函数也是接受默认实参的
  - 如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数

- 委托构造函数

  - 就是在构造函数写实参的地方，调用构造函数

- 默认构造函数的作用

  - 如果定义了其他构造函数，那么最好也提供一个默认构造函数
  - 即如果有 有参构造函数了，那么就不会提供默认构造函数了

- 使用默认构造函数

  - 如果想要定义一个使用默认构造函数进行初始化对象，正确的方法是去掉对象名之后的空括号对

- 隐式的类类型转换

  - 只允许一步类类型转换
  - 能够通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则
  - 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种函数称为转换构造函数

- 类类型转换不是总有效的

  - 有时候编译器的隐式转换会给代码意想不到的影响

- 抑制构造函数定义的隐式转换

  - 通过关键字explicit来组织系统不自觉的隐式转换
  - 关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于指向隐式转换

- explicit构造函数只能用于直接初始化

  - ```c++
    Sales_data item1(null_book);//正确，可以直接初始化Sales_data item2 = null_book;//错误，这里涉及隐式转换，nonono
    ```

- 为转换显式地使用构造函数

  - 可以用类型等对数据进行强制转换

    - ```c++
      Sales_data(null_book);static_cast<Sales_data>(cin);
      ```

- 标准库中含有显示构造函数的类

- 聚合类

  - 所有成员都是public

  - 没有任何的构造函数

  - 没有类内初始值

  - 没有基类，没有虚函数

  - 可以用花括号来初始化

  - ```c++
    struct Data{    int ival;    string a;}Data vall = {1, "Anna"};//初始化的顺序一定要和类内声明的顺序一样
    ```

- 字面值常量类

  - null
  - https://blog.csdn.net/mbl114/article/details/111602832



## 7.6 类的静态成员

- 声明静态成员
  - 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据
  - 静态成员函数也不与任何对象绑定在一起，它们不包含this指针，不能声明为const
- 使用类的静态成员
  - ：：访问
  - 类对象访问
  - 成员函数可以直接使用静态成员
- 定义静态成员
  - 类外定义的时候，不能重复static关键字
  - 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名，static关键词只能出现在类内
- 静态成员能用于某些场景，而普通成员不能
  - 可以使用静态成员作为默认实参，非静态数据成员不能作为默认实参（其本身就是对象的一部分）
- 静态成员的类内初始化
  - null



# 第13章 拷贝控制（已）

## 13.1 拷贝、赋值与销毁

- 一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁：
  - 拷贝构造函数
  - 拷贝赋值运算符
  - 移动构造函数
  - 移动赋值运算符
  - 析构函数
  
- 拷贝构造函数
  - 定义：一个构造函数的第一个参数时自身类型的引用，且任何额外参数都有默认值
    - 为什么是引用：如果是传值的话，因为一般的拷贝都是值传递，那这个值传递有会调用拷贝构造，会无限递归下去
    - 拷贝构造函数是系统会自动提供
    
  - 合成拷贝构造函数
  
    - 每个成员的类型决定了它如何拷贝，对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝
  
  - 拷贝初始化
  
    - 当直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择我们提供的参数最匹配的构造函数
    - 当拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中（如果有需要的话会进行类型转换）
    - ps：原来，在最开始的初始化的时候=调用的是拷贝初始化而不是重载的=，而后面的重新赋值才写的是operator=；而直接用已有的对象来初始化，比如A a(a1)，调用的就是拷贝构造函数
    - 拷贝初始化在下列情况下也会发生：
      - 将一个对象作为实参传递给一个非引用类型的形参（函数传参）
      - 从一个返回类型为非引用类型的函数返回一个对象（函数返回值）
      - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（花括号初始化）
  
  - 参数和返回值
  
    - 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化；当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果
  
  - 拷贝初始化的限制
    - 防止隐式调用拷贝构造函数explicit，即如果函数有explicit的话，就无法隐式调用了
    
  - 编辑器可以绕过拷贝构造函数
    - 编辑器的优化，可以跳过拷贝构造函数
    
    - ```cpp
      string null_book = "999-999";//拷贝初始化
      string null_book("999-999");//编译器略过了拷贝构造函数
      ```
  
- 拷贝赋值运算符
  - 如果类未定义自己的拷贝赋值运算符，编辑器会为它合成一个
  - 重载赋值运算符
    - 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成
    - 重载运算符的参数表示运算符的运算对象
    - 赋值运算符通常返回一个指向其左侧运算对象的引用
  - 合成拷贝赋值运算符
    - 如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符

- 析构函数
  - 作用：释放对象使用的资源，并销毁对象的非static数据成员
  - 特征：是一个类的成员函数，名字由波浪号类名构成，没有返回值，也不接受参数
  - 析构函数完成什么工作
    - 首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁
    - 析构函数释放对象在生存期分配的所有资源
    - 成员销毁时发生什么完全依赖于成员的类型，销毁类类型的成员需要执行成员自己的析构函数
    - 隐式销毁一个内置指针类型的成员不会delete它所指向的对象！！
  - 什么时候会调用析构函数
    - 变量在离开其作用域时被销毁
    - 当一个对象被销毁时，其成员被销毁
    - 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
    - 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
    - 对于临时对象，当创建它的完整表达式结束时被销毁
    - tips：当指向一个对象的引用或指针离开作用域时，析构函数不会执行
  - 合成析构函数
    - 当一个类未定义自己的析构函数，编译器会为它定义一个合成析构函数
    - 成员是在析构函数体之后隐含的析构阶段被销毁的（在整个对象销毁过程之中，析构函数作为成员销毁步骤之外的另一部分而进行的）
  
- 三/五法则
  
  - 拷贝构造函数、拷贝赋值运算符和析构函数（三），移动构造函数，移动赋值运算符（五）
  - 需要析构函数的类也需要拷贝和赋值操作
    - 我的理解：你需要自己去析构对象，就表明编译器默认的析构你是用不了的，有些操作是要自己去释放的，那也就代表着拷贝对象和赋值对象也是一样需要人工操作的。可以参考：深拷贝和浅拷贝
    - 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数
  - 需要拷贝操作的类也需要赋值操作，反之亦然
    - 接上：有些类只需要拷贝或赋值操作，不需要析构函数（书上有例子）
    - 我的理解：拷贝一般用在对象的初始化上，那你既然都要重写一个用对象来初始化，就也会发生说对象赋值的情况，所以拷贝操作和赋值操作都是必须的
  
- 使用=default
  - 可以通过将拷贝控制成员定义为=default来显式要求编辑器生成合成的版本
  - 只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）
  
- 阻止拷贝
  - 定义删除的函数
    - 可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来组织拷贝
    - 删除的函数是这样一种函数：虽然声明了它们，但是不能以任何方式使用它们
    - 在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的
    - =delete必须出现在函数的第一次声明的时候；可以对任何函数指定=delete
  - 析构函数不能是删除的成员
    - 如果一个类由某些成员的类型删除了析构函数，就无法定义该类的变量或临时对象（对一个类的析构函数也是同理）
    - tips：对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针
  - 合成的拷贝控制成员可能是删除的
    - 总结：如果一个类有数据成员是不能默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的
    - 本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的
  - private拷贝控制
    - 在新版本之前都是把函数设为private来阻止操作的，而为了防止友元函数和成员函数访问，就把该函数设为private并且不定义
    - 总结：希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将他们声明为private





## 13.2 拷贝控制和资源管理

- 通常，管理类外资源的类必须定义拷贝控制成员

  - 一旦与一个类需要析构函数，那么它几乎肯定也要一个拷贝构造函数和一个拷贝赋值运算符

- 行为像值的类

  - 简述：拷贝、析构、拷贝复制运算符（注意深拷贝和浅拷贝的区别）

  - ```cpp
    //类值拷贝赋值运算符
    HasPtr& HasPtr::operator=(const HasPtr &rhs){
        auto newp = new string(*rhs.ps);//拷贝底层string
        delete ps;//释放原来的内存
        ps = newp;//从右侧运算对象拷贝数据到本对象
        i= rhs.i;
        return *this;//返回原对象
    }
    ```

  - 赋值运算符的几点：
    - 如果将一个对象赋予它自身，赋值运算符必须能正确工作
    - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

- 定义行为像指针的类
  - 注意：拷贝的应该是指针的指向
  - 所以，令一个类展现类似指针的行为的最好方法就是使用shared_ptr来管理类中的资源
  - 引用计数的工作原理：
  - 除了初始化对象之外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态，当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
  - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享
  - 析构函数递减计数器，指出共享状态的用户少了一个，如果计数器变为0，则析构函数释放状态
  - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户，拷贝赋值运算符就必须销毁状态
  
- 定义一个使用引用计数的类



## 13.3 交换操作

- 为了减少不必要的内存分配，所以要手写swap

- 编写我们自己的swap函数
  - 与拷贝控制成员不同，swap并不是必要的，但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段
  - 与传统的创建临时对象temp来实现swap，不如直接就交换其内部的数据就可以了
  
- swap函数应该调用swap，而不是std::swap
  - 这里涉及using的问题
  - 如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本
  
- 在赋值运算符中使用swap

  - 通过swap实现拷贝

  - ```cpp
    HasPtr& HasPtr::operator=(HasPtr rhs){
        swap(*this, rhs);
        return *this;//关键就是这里是以值传递rhs的，所以出了作用域后就会被销毁
    }
    ```

  - 使用拷贝和交换的赋值运算自动就是异常安全的，且能正确处理自赋值



## 13.4 拷贝控制示例

- 本节主要演示的是如何细心的根据两个类的关系，设计两个函数的接口

- ```cpp
  class Message{
      friend class Folder;//方便Folder访问其私有的属性
      public:
      	explicit Message(const std::string& str = ""):contents(str){}
          Message(const Message&);//拷贝构造函数
      	Message& operator=(const Message&);//拷贝赋值运算符
      	~Message();//析构函数
      	//从给定Folder集合中添加/删除本Message
      	void save(Folder&);
      	void remove(Folder&);
      private:
      	std::string contents;//实际消息文本
      	std::set<Folder*> folders;//包含本Message的Folder
      	//拷贝构造函数、拷贝赋值运算符和析构函数所使用的工具函数
      	void add_to_Folders(const Message&);//将本Message添加到指向参数的Folder中(拷贝的时候，把拷贝得到的副本添加到folder中)
      	void remove_from_Folders();//从folders中的每个Folders中删除本Message
  };
  
  void Message::save(Folder& f){
      folders.insert(&f);//将给定Folder添加到我们的Folder列表中
      f.addMsg(this);//将本Message添加到f的Message
  }
  
  void Message::remove(Folder& f){
      folders.erase(&f);//将给定Folder从我们的Folder列表中删除
      f.remMsg(this);//将本Message从f的Message集合中删除
  }
  
  void Message::add_to_Folders(const Message& m){//拷贝的时候会用到的
      for (auto f: m.folders){//对每个包含m的Folder
          f->addMsg(this);//向该Folder添加一个指向本Message的指针
      }
  }
  
  Message::Message(const Message& m):contens(m.contents), folders(m.folders){
      add_to_Folders(m);//将本消息添加到指向m的Folder中
  }
  
  void Message::remove_from_Folders(){//析构的时候会用到
      for (auto f :folders){
          f->remMsg(this);//对folders中的每个指针，从该Folder中删除本Message
      }
  }
  
  Message::~Message(){
      remove_form_Folders();
  }
  
  Message& Message::operator=(const Message &rhs){
      //通过先删除指针在插入它们来处理自赋值情况
      remove_from_Folders();//更新已有Folders
      contents = rhs.contents;
      folders = rhs.folders;
      add_to_Folders(rhs);//将本Message添加到那些Folder中
      return *this;
      /*
      这里解释一下为什么不会发生自我赋值的意外情况：
      如果是自我赋值的话：
      第一行是把本对象从已有的folder中全部删掉，但是注意folder还是在folders中的
      所以后面folders = rhs.folders是不改变的
      然后是add_to_Folders是根据rhs已有的folders，来重新添加关系，所以又会恢复原状了的
      */
  }
  
  void swap(Message& lhs, Message& rhs){
      using std::swap;//在本例中严格来说并不需要，但是这是一个好习惯
      //其实是利用swap的匹配性，即在这个作用域内，如果又更加适合该变量swap就会使用那个，而不是使用普适的std::swap
      //将每个消息的指针从它原来的Folder中删除
      for (auto f: lhs.folders){
          f -> remMsg(&lhs);
      }
      for (auto f: rhs.folders){
          f -> remMsg(&rhs);
      }
      //交换contents和Folder指针set
      swap(lhs.folders, ths.folders);
      swao(lhs.contents, ths.contents);
      //将每个Message的指针添加到它的新Folder中
      for (auto f:lhs.folders){
          f -> addMsg(&lhs);
      }
      for (auto f: rhs.folsers){
          f -> addMsg(&rhs);
      }
  }
  ```





## 13.5 动态内存管理类

- 





## 13.6 对象移动

- 在其中某些情况下，对象拷贝后就立即被销毁了，在这些情况下，移动而非拷贝对象会大幅度提升性能

- 右值引用

  - 就是必须绑定到右值的引用，通过&&而不是&来获得右值引用（即：只能绑定到一个将要销毁的对象）
  - 左值和右值的区别：一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值
  - 左值引用：不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式

- 左值持久：右值短暂

  - 右值要么是字面常量，要么是在表达式求值过程中创建的临时对象
  - 右值引用：所引用的对象将要被销毁；该对象没有其他用户
  - 总结：右值引用指向将要被销毁的对象，因此，我们可以从绑定到右值引用的对象”窃取“状态

- 变量是左值

  - 右值引用返回的是一个左值（所以不能将一个右值引用绑定到一个右值引用类型的变量上）
  - 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行

- move函数

  - 显式的将一个左值转换为对应的右值引用类型

  - ```cpp
    int rr1 = 10;//意味着除了对rr1赋值或销毁之外，我们将不再使用它
    int &&rr3 = std::move(rr1);//ok
    ```

  - 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值

- 移动构造函数和移动赋值运算符

  - 移动构造函数的第一个参数是该类类型的一个引用，这个引用参数在移动构造函数中是一个右值引用

  - 需要保证源对象的销毁是无害的

  - 一旦资源完成移动，源对象必须不再指向被移动的资源，这些资源的所有权已经归属新创建的对象

  - ```cpp
    StrVec::StrVec(StrVex &&s) noexcept:elements(s.elements), first_free(s.first_tree), cap(s.cap){
        s.elements = s.first_free = s.cap = nullptr;
    }
    ```

- 移动操作、标准库容器和异常

  - 移动操作不分配资源，因此移动操作通常不会发生异常，所以要加上noexcept
  - 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept

- 移动赋值运算符

  - ```cpp
    StrVec& StrVec::operator=(StrVec &&rhs) noexcept{
        if (this != &rhs){
            free();//释放已有元素
            elements  rhs.elements;
            first_tree = rhs.first_tree;
            cap = rhs.cap;
            rhs.elements = rhs.first_tree = rhs.cap = nullptr;
        }
        
        return *this;
    }
    ```

- 移后源对象必须可析构

  - 移后源对象置为析构安全的状态之，移动操作还必须保证对象仍然是有效的
  - 在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其进行任何假设

- 合成的移动操作

  - 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了
  - 如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作
  - 只有一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符
  - 总结：只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符
  - 在以下情况，移动构造函数或移动赋值运算符被定义为删除的
    - 有类成员定义了自己的拷贝构造函数且为定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数
    - 有类成员的移动构造函数或移动赋值运算被定义为删除或是不可访问的
    - 类的析构函数被定义为删除或不可访问的
    - 有类成员是const的或是引用
  - 总结：定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认地被定义为删除的

- 移动右值，拷贝左值

  - 对于等号，右边如果是右值的话，就调用移动赋值，否则就用拷贝赋值（前提是有移动构造和拷贝构造）

- 如果没有移动构造函数，右值也被拷贝

  - ```cpp
    class Foo{
        public:
        	Foo() = default;
        	Foo(const Foo&);
    };
    
    Foo x;
    Foo y(x);//拷贝构造函数，x是一个左值
    Foo z(std::move(x));//拷贝构造函数，因为未定义移动构造函数
    ```

  - 如果一个类有一个人可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来”移动“的。拷贝赋值运算符和移动赋值运算符的情况类似

- 拷贝并交换赋值运算符和移动操作

  - 所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作（拷贝构造函数，拷贝赋值运算符，析构函数，移动构造函数和移动赋值运算符）

- Message类的移动操作

- 移动迭代器

- 右值引用和成员函数

  - 区分移动和拷贝的重载函数通常有一个版本接受一个const T&，而另一个版本接受一个T&&

- 右值和左值引用成员函数

  - 引用限定符可以是&或是&&，分别之处this可以指向一个左值或右值，类似const限定符，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中

  - 写一个函数，为了提高性能，可以写拷贝的版本和移动的版本

  - ```cpp
    class StrVec{
        public:
        	void push_back(const std::string&);//拷贝元素
        	void push_back(std::string&&);//移动元素
    };
    
    StrVec vec;
    std::string s = "hello world!";
    vec.push_back(s);//调用push_back(const string&)
    vec.push_back("done");//调用push_back(s)
    ```

  - 

- 重载和引用函数

  - 就像一个成员函数可以根据是否有const来区分重载版本一样，引用限制符也可以区分重载版本

  - ```cpp
    class Foo{
        public:
        	Foo sorted() &&;//可以用于可改变的右值
        	Foo sorted() const &;//可用于任何类型的Foo
        private:
        	vector<int> data;
    };
    
    Foo Foo::sorted() &&{//本对象是右值，因此可以原址排序
        sort(data.begin(), data.end());
    }
    
    //本对象是const或是一个左值，所以无论是哪种都不可以原址排序
    Foo Foo::sorted() const &{
        Foo ret(*this);
        sort(ret.data.begin(), ret.data.end());
        return ret;
    }
    ```

  - 如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者都不加

  - 我的理解：可以认为添加了&&和&引用限定符，是实现了一种重载。有&&的表示接受的是一个右值，而有&的表示接受的是一个左值或const类型

  - 总结：如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符







# 第14章 重载运算与类型转换（已）

## 14.1 基本概念

- 重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成

- 当一个重载的运算符是成员函数时，this绑定到左侧运算对象上，成员运算符函数的显式参数数量比运算对象的数量少一个

- 重载运算符函数：或者是类的成员，或者至少含有一个类类型的参数（不能重定义内置的运算符）

- 一个非成员运算符函数的等价调用

  - ```cpp
    data1 + data2;//普通表达式
    operator+(data1, data2);//等价的函数调用
    ```

- 像调用其他成员函数一样显式地调用成员运算符函数

  - ```cpp
    data1 += data2;//基于“调用”的表达式
    data1.operator+=(data2);//对成员运算符函数的等价调用
    ```

- 通常情况下不重载逗号，取地址符，逻辑与和逻辑或运算符（在逻辑与前面如果是假的话就不会检测后面的了，而重载后的必然是两个都计算出来的）

- 选择作为成员或者非成员

  - 赋值（=）、下标（[]）、调用（()）和成员访问箭头运算符（->）必然是成员
  - 复合赋值运算符一般来说应该是成员，但并非必须
  - 递增和递减和解引用都应该是成员
  - 具有对称属性的运算符可能转换任意一端的运算对象，通常应该是普通的非成员函数（参考：s+"s"和"s" + s的区别）





## 14.2 输入和输出运算符

- 重载输出运算符
  - 第一个形参是一个非常量ostream对象的引用（ostream是非常量是因为向流写入内容会改变其状态）
  - 输出运算符尽量减少格式化操作
  - 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符
  
- 为了方便使用，输入输出符必须是非成员函数

  - ```c++
    Sales_data data;
    data << cout;//用起来不方便
    ```

  - 如果涉及到对象的私有数据的话，就要变为友元函数

- 重载输入运算符

  - 第一个形参是运算符将要读取的流的引用（不能为const，理由同上），第二个形参是将要读入到的对象的引用
  - 需要判断是否输入成功，即输入运算符必须处理可能失败的情况，而输出运算符不需要





## 14.3 算术和关系运算符

- 算数运算符通常回计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果
- 如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符
- 相等运算符的规则：
  - 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的命名函数
  - 如果类定义了operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据
  - 相等性运算符应该具有传递性
  - 如果类定义了operator==，则这个类也应该定义了operator!=
  - 相等运算符和不相等运算符中的一个应该把工作委托给另一个
  - 如果某个类再逻辑上有相等性的含义，则该类应该定义operator==，这样做可以使得用户更容易使用标注库算法来处理这个类
- 关系运算符
  - 定义顺序关系，令其与关联容器中对关键字的要求一致
  - 如果类同时也含有==运算符的话，则定义一种关系令其与 == 保持一致
  - 如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符，如果类同时还包含==，则当且仅当<的定义和 ==产生的结果一致时才定义 < 运算符





## 14.4 赋值运算符

- ```cpp
  //参考下面用{}初始值的
  vector<string> v;
  v = {"a", "an", "the"};
  
  class StrVec{
      public:
      	StrVec &operator=(std::initializer_list<std::string>);
  };
  
  //为了和内置的运算符一样，返回的也要是引用
  StrVec &StrVec::operator=(initializer_list<string> i1){
      auto data = allov_n_copy(i1.begin(), i1.end());
      free();
      elements = data.first;
      first_free = cap = data.second;
      return *this;
  }
  ```

- 可以重载赋值运算符，不论形参的类型是什么，赋值运算符都必须定义为成员函数

- 复合赋值运算符

  - ```cpp
    Sales_data& Sales_data::operator+=(const Sales_data &rhs){
        units_sole += rhs.units_sold;
        revence += rhs.revence;
        return *this;
    }
    ```

- 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做，这两类运算符都应该返回左侧对象的引用





## 14.5 下标运算符

- 下标运算符必须是成员函数
- 总结：如果一个类包含小标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用
  - 这点非常重要，因为如果没有返回常量引用的，那么const对象的内容也会被随意的更改，这是不对的





## 14.6 递增和递减运算符

- 定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义成类的成员

- ```cpp
  class StrBlobPtr{
      public:
      	StrBlobPtr& operator++();//为了与内置版本保持一致，前置运算符应该返回递增或递减后的对象的引用
      	StrBlobPtr& operator--();//前置运算符，前置运算符，前置运算符
  };
  
  StrBlobPtr& StrBlobPtr::operator++(){
      ++ curr;
      return *this;//返回的是一个引用
  }
  ```

- 以上是前置运算符

- ```cpp
  class StrBlobPtr{
      public:
      	StrBlobPtr operator++(int);
      	StrBlobPtr operator--(int);
      //为了解决后置版本的问题，后置版本接受一个额外的（不被使用）int类型的形参，当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参
  };
  
  StrBlobPtr StrBlobPtr::operator++(int){//因为不会用到int形参，所以无须为其命名
      StrBlobPtr ret = *this;
      ++ *this;
      return set;//为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用
  }
  ```

- 显式地调用后置运算符

  - ```cpp
    StrBlobPtr p(a1);//p指向a1中的vector
    p.operator++(0);//调用后置版本的operator++
    p.operator++();//调用前置版本的operator++
    ```






## 14.7 成员访问运算符

- 箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此
- 也要加上const（->和*都不会修改对象的属性）
- 重载的箭头运算符必须返回类的指针（因为是指针就可以无限的递归调用下去）或者自定义了箭头运算符的某个类的对象（最后都会循环返回到一个对象）





## 14.8 函数调用运算符

- ```cpp
  struct abdInt{
      int operator() (int val) const{
          return val < 0 ? -val : val;
      }
  }
  ```

- 函数调用运算符必须是成员函数，一个类可以定义多个不同版本的调用运算符，相互之间应该再参数数量或类型上有所区别

- 如果类定义了调用符，则该类的对象称作函数对象

- 函数调用符也有参数可以传入

- lambda（lambda其实就相当于函数调用运算符）

  - ```cpp
    stable_sort(words.brgin(), words.end(),[](const string &a, const string &b){return a.size() < s2.size();})
    ```

  - ```cpp
    class ShorterString{
        public:
        	bool operator() (const string &s1, const string &s2) const{
                return s1.size() < s2.size();
            }
    };
    ```

- 标准库定义的函数对象






## 14.9 重载、类型转换与运算符

- 类型转换运算符：负责将一个类类型的值转换成其他类型

  - 形式：operator type() const;
  - 可以转换成指针或引用类型，但是不能转换为数组或函数类型
  - 类型转换运算符没有显式的返回类型，也没有形参，而且必须定义为类的成员函数
  - 总结：一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空，类型转换函数通常为const

- 隐式的用户定义类型转换（即后面写的类型转换运算符）可以置于标准（内置）类型转换之前或之后（即int->double）

- 尽量不要把类型转换为bool

- 显式的类型转换运算符：

  - ```cpp
    class SmallInt{
        public:
        	//编译器不会自动执行这一类型转换
        	explict operator int() const {return val;}
    };
    
    SmallInt si = 3;//ok,是显式调用
    si + 3;//error,是隐式调用
    ```

  - 当表达式出现在下列位置时，显式的类型转换将被隐式地执行：

    - if、while及do语句的条件部分
    - for语句头的条件表达式
    - 逻辑非表达式，逻辑或运算符，逻辑与运算符的运算对象
    - 条件运算符的条件表达式

- 向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的

- 避免有二义性的类型转换

  - 总结：通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算数类型的转换

  - 实参匹配和相同的类型转换（在A中定义了把B转换为A的转换函数，在B中定义了转换为A的转换符）

  - ```cpp
    struct B;
    struct A{
        A() = default;
        A(const B&);//也是把B转换为A
    };
    
    struct B{
        operator A() const;//把B转换为A
    };
    
    A f(const A&);//定义了一个函数
    B b;
    A a = f(b);//发生了二义性
    
    //解决办法
    A a1 = f(b.operator A());
    A a2 = f(A(b));
    ```

- 二义性与转换目标为内置类型的多重类型转换

  - 有类型转换符和带有默认参数的类型转换

  - ```cpp
    struct A{
        A(int = 0);
        A(double);//最好不要创建两个转换源都是算术类型的类型转换
        operator int() const;
        operator double() const;//最好不要创建两个转换对象都是算术类型的类型转换
    };
    
    void f2(long double);
    A a;
    f2(a);//这里是调用double转long double，还是调用int转long double？
    
    long lg;
    A a2(lg);//这里调用的是A(int)还是A(double)
    ```

  - 产生的原因：它们所需的标注那类型转换级别一致

  - 总结：当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在类型转换，则标准类型转换将决定最佳匹配到底是哪个

- 重载函数与转换构造函数

  - ```cpp
    struct C{
        C(int);
    };
    
    struct D{
        D(int);
    };
    
    void manip(const C&);
    void manip(const D&);
    manip(10);//不知道调用的是manip(C(10))，还是mainp(D())
    ```

  - 如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则通常意味着程序的设计存在不足

- 重载函数与用户定义的类型转换

  - ```cpp
    struct C{
        C(int);
    };
    
    struct E(){
        E(double);
    };
    
    void manip2(const C&);
    void manip2(const E&);
    
    manip(10);//这里调用的是manip2(C(10))还是manip2(E(double(10)))
    ```

  - 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用，如果所需的用户定义的类型转换不止一个，则该调用具有二义性

- 函数匹配与重载运算符

  - 当我们调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载
  
  - ```cpp
    class SmallInt{
        friend SmallInt operator+(const SamllInt&, const SmallInt&);
        public:
        	SmallInt(int = 0);
        	operator int() const{return val;}
        private:
        	std::size_t val;
    };
    
    SmallInt s1, s2;
    SmallInt s3 = s1 + s2;
    int i = s3 + 0;//发生二义性错误，可以把0转换为smallint，再调用smllptr的+；或者把s3转换成int，然后再相加
    ```
  
  - 如果我们对同一个类既提供了转换目标是算数类型的转换，也提供了重载的符号的运算符，则将会遇到重载运算符与内置运算符的二义性问题





# 第15章 面向对象程序设计

## 15.1 OOP：概述

- 面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定（多态）
  - 通过数据抽象，将类的接口和实现分离
  - 使用继承，可以定义相似的类型并对其相似关系建模
  - 使用动态绑定，可以在相似的类型并对其关系建模
- 继承
  - 在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类
  - 基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为虚函数
  - 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的
- 动态绑定
  - 函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时被称为运行时绑定





## 15.2 定义基类和派生类

- 定义基类

  - 基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作

- 成员函数与继承

  - 虚函数：基类希望其派生类进行覆盖的函数
  - 当我们使用指针或引用调用虚函数时，该调用将被动态绑定（即根据实际的对象来调用函数）
  - 任何构造函数之外的非静态函数都可以是虚函数

- 访问控制与继承

  - 基类希望它的派生类有权访问该成员，同时禁止其他用户访问，用受保护访问运算符说明这样的成员

- 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的

  - 类派生列表的形式：一个冒号，后面紧跟以逗号分割的基类列表，，其中每个基类前都有访问说明符

- 派生类中的虚函数

  - cpp11新标准：允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数（在最后面加上override）

- 派生类对象及派生类向基类的类型转换

  - 一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生对象继承的基类对应的子对象
  - 综上：就有了派生类到基类的类型转换
  - 总结：在派生类对象中含有与其基类对应的组成部分

- 派生类构造函数

  - ```cpp
    Bulk_quote(const std::string& book, double p, std::size_t qty, double disc):Quote(book, q), min_qty(qty), discount(disc){}
    //这里是先调用基类的构造函数在初始化派生类独有的数据
    ```

  - 总结：首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

- 派生类使用基类的成员

  - 总结：派生类可以访问基类的公有成员和受保护的成员

- 派生类的声明

  - 总结：派生类声明中包含类名但是不包含它的派生列表

- 被用作基类的类

  - 如果一个类被用作基类，则该类必须已经定义而非仅仅声明
  - 直接基类（爸爸），间接基类（爷爷）

- 防止继承的发生

  - ```cpp
    class NoDerived final{};
    ```

  - 总结：在类的后面加上final来防止继承

- 继承与静态成员

  - 如果基类定义了一个静态成员，则在整个继承体系中只存在该陈冠的唯一定义

- 可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：但使用基类的引用（或指针）时，该对象可能是基类的对象，也可能是派生类的对象

- 静态类型与动态类型

  - 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型

  - 动态类型则是变量或表达式表示的内存中的对象类型，知道运行时才可知

  - 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致！！！

  - ps：一个我踩的误区

  - ```cpp
    class A{
        public:
            int i;
    };
    
    class B:public A{
        public:
            int j;
    };
    
    void test(A a){
        std::cout << a.i << "void test()" << std::endl;
    }
    //这里看上去好像是动态类型，因为即使传入的是b，好像也会当作b来处理，就有点多态的感觉了
    //而实际上，这里其实是把B类型给切割了，把其中A的部分给拿了出来
    ```

- 不存在从基类向派生类的隐式转换...

  - 之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到给基类部分上
  - 不存在基类向派生类的隐式转换（派生类用到的属性可能基类没有）！！
  - 即使一个基类指针或引用绑定在一个派生类对象上，我们也不能从基类转到派生类，编译器在编译时无法确定某个特定的转换在运行时是否安全

- ...在对象之间不存在类型转换

  - 派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换
  - PS：当初始化或赋值一个类类型的对象时，实际上调用的是某个函数，这些成员通常都包含一个参数，该参数的类型就是类类型的const版本的引用
  - 即：给基类的构造函数传递一个派生类对象，实际运行的构造函数是基类中定义的那个（即把派生类中基类的部分给切割出来）
  - 总结：
    - 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉
    - 从派生类向基类的类型转换只对指针或引用类型有效
    - 基类向派生类不存在隐式类型转换





## 15.3 虚函数

- 对虚函数的调用可能在运行时才被解析

  - 当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数
  - 动态绑定只有当我们通过指针或引用调用虚函数时才会发生
  - 对非虚函数的调用在编译时进行绑定
  - 总结：当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同

- 派生类中的虚函数

  - 总结：基类中的虚函数在派生类中隐含地也是一个虚函数，当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配
  - 一般来说返回值的类型也要相同，但是如果是返回类本身的指针或引用的话就例外了
  - 所以一个好习惯，在派生类的虚函数前面加上virtual

- final和override说明符

  - override说明派生类中的虚函数（如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器就会报错）
  - 把函数指定为final，则任何尝试覆盖该函数的操作将会引发错误

- 虚函数与默认实参

  - 如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定（如果是通过基类的引用或指针调用函数，则使用基类中定义的默认实参）
  - 总结：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致

- 回避虚函数的机制

  - 不希望对虚函数的调用不要进行动态绑定

  - ```cpp
    A* a = new B();
    a->test();//正常的虚函数调用
    a->A::test();//强制调用某个特定版本的虚函数
    ```

  - 通常，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制（如：当一个派生类的虚函数需要调用它覆盖的基类的虚函数版本的时候）

  - 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致 





## 15.4 抽象基类

- 纯虚函数
  - 纯虚函数的定义：在函数体的位置（即声明语句的分号之前）书写=0（其中=0只能出现在类内部的虚函数声明语句处）
  - 可以为纯虚函数提供定义，但函数体必须定义在类的外部，不能在类的内部为一个=0的函数提供函数体
- 含有纯虚函数的类是抽象基类
  - 含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类
  - 不能创建一个抽象基类
  - 抽象基类负责定义接口，后续的其他类可以覆盖接口
  - 总结：不能创建抽象基类的对象
- 派生类构造函数只初始化它的直接基类
  - 即派生类只需要调用直接基类的构造函数，至于其他的变量就由直接基类去初始化管理
  - 重构：负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中（所以一旦重构了，就要重新编译代码了）





## 15.5 访问控制与继承

- 受保护的成员

  - 关于protected：
  - 受保护的成员对于类的用户来说是不可访问的，对于派生类的成员和友元来说是可以访问的
  - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权（即派生类的友元或成员，要想访问到基类的protected，必须通过派生类，而不能通过基类）

- 公有、私有和受保护继承

  - 派生访问说明符  对于派生类的成员（及友元）   能否访问   其直接基类的成员   没影响，只和基类中的访问说明符有关
  - 派生访问说明符的目的是控制        派生类用户（包括派生类的派生类）       对于         基类成员         的访问权限
  - 类的访问修饰符都是对于类的使用者来说的，public则无事发生，private则表示基类的属性对类的派生类和类的使用者private，protected则表示基类属性对类的使用者private，但对类的派生类public

- 派生类向基类转换的可访问性

  - 只有公有继承，派生类才可以向基类转换（即私有和保护的都不可以）
  - 基类的成员函数和友元都能使用派生类向基类的转换
  - 只有公有或保护继承，派生类的成员或友元可以使用基类向派生类的类型转换（即私有不可以）

- 友元与继承

  - 派生类的友元也不能随意访问基类的成员
  - 即友元函数只能访问到属于它的那个朋友的属性（如果是朋友的派生类的属性，那就无法访问得到）
  - 当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效
  - 总结：不能继承友元关系，每个类负责控制各自成员的访问权限

- 改变个别成员的可访问性

  - 通过using声明改变 继承下来的 属性的访问性

  - ```cpp
    class Base{
        public:
        	std::size_t size() const {return n;}
        protected:
        	std::size_t n;
    };
    
    class Dervied : private Base{
        public:
        	using Base::size;
        protected:
        	using Base::n;
    };
    ```

  - 通过在类的内部使用using声明语句，可以将该类的直接或间接基类中的任何访问成员标记出来

  - 如果基类的属性已经为private了，那么就无法using声明

  - 派生类只能为那些它可以访问的名字提供using声明

- 默认的继承保护级别

  - 使用class定义的派生类默认是私有的；使用struct定义的派生类默认是public的

  - ```cpp
    class Base{};
    struct D1:Base{};//public继承
    class D2:Base{};//private继承
    ```

  - 总结：一个私有派生的类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会





## 15.6 继承中的类作用域

- 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内
- 在编译时进行名字查找
  - 一个对象、引用或指针的静态类型决定了该对象的那些成员是可见的
  - 所以对于一个指针或引用、需要寻找的对象如果只是出现在对象上，该指针上没有，那就是找不到的
- 名字冲突与继承
  - 派生类的成员将隐藏同名的基类成员（即使隐藏了，但是内存管理上派生类还是会有的）
- 通过运算符来使用隐藏的成员
  - 如题
  - tips：除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字
- 一如往常，名字查找先于类型检查
  - 背景：声明在内层作用域的函数并不会重载声明在外层作用域的函数
  - 推广：如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏该基类成员（如果要用到基类的同名函数，必须加上类名和：：）
- 虚函数与作用域
  - 背景：假如基类与派生类的虚函数接受的实参不同，就无法通过基类的引用或指针调用派生类的虚函数
  - 原因：派生类的同名函数会隐藏基类的同名函数，以致于无法调用得到基类的虚函数
- 通过基类调用隐藏的虚函数
  - 在动态绑定的过程中，如果指针所在的类没有该虚函数，即使指向的派生类由这个虚函数，也不会调用
  - 而对于非虚函数而言，实际调用的函数版本由指针的静态类型决定
- 覆盖重载的函数
  - 背景：重载基类函数的时候，会覆盖掉基类原有的函数
  - 解决：在派生类中写一个using+函数名就可以把该函数的所有重载实例添加到派生类作用域中（前提：基类函数的每个实例在派生类中都必须是可访问的）





## 15.7 构造函数与拷贝控制

- 虚析构函数

  -  只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本
  -  如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为
  -  如果一个类定义了析构函数，则即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作

-  合成拷贝控制与继承

   -  派生类合成的成员使用直接基类中对应的操作对对象的直接基类进行初始化、赋值或销毁的

-  派生类中删除的拷贝控制与基类的关系

   -  如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数被删除或不可访问，则派生类的对应函数是被删除的
   -  基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数是被删除的

-  移动操作与继承

   -  基类缺少移动操作会阻止派生类拥有自己的合成构造函数（所以如果基类由虚析构函数，那么当子类需要移动操作的时候，就要先给基类写一个默认的移动操作函数）

-  派生类的拷贝控制成员

   -  当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象

-  定义派生类的拷贝或移动构造函数

   -  当为派生类定义拷贝或移动构造函数，可以使用对应基类构造函数初始化对象的基类部分

   -  ```cpp
      class Base{};
      class D:public Base{
          public:
          	D(const D& d):Base(d){}
      };
      ```

   -  在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数

-  派生类赋值运算符

   -  同样，这里也会要调用基类的赋值运算符

   -  ```cpp
      D& D::operator=(const D& rhs){
          Base::operator=(rhs);//为基类部分赋值
      }
      ```

-  派生类析构函数

   -  派生类析构函数只负责销毁由派生类自己分配的资源
   -  对象销毁的顺序正好与其创建的顺序相反

-  在构造函数和析构函数中调用虚函数

   -  如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本
   -  但这和我们的初衷（根据对象的不同在构造函数中调用不同类型的虚函数）不同，所以最好不要这样做

-  继承的构造函数

   -  一个类只继承其直接基类的构造函数，不能继承默认、拷贝和移动构造函数

   -  派生类继承基类构造函数的方式是提供基类名的using声明语句

   -  ```cpp
      class Bulk_quote:public Disc_quote{
          public:
          	using Disc_quote::Disc_quote;//继承Disc_quote的构造函数
          //对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数
      };
      ```

-  继承的构造函数的特点

   -  一个构造函数的using声明不会改变该构造函数的访问级别（包括不能指定explicit或constexpr）
   -  当一个基类构造函数含有默认实参时，这些实参并不会被继承（相反派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参）（这里书上有例子）





## 15.8 容器与继承

## 15.9 文本查询程序再探
