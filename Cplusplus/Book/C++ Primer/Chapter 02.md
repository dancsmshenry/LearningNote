# 第2章 变量和基本类型

## 2.1 基本内置类型

- 基本算术类型

  | 类型      | 含义                   |
  | --------- | ---------------------- |
  | bool      | 布尔类型               |
  | char      | 字符                   |
  | short     | 短整型                 |
  | int       | 整型                   |
  | long      | 长整型（最小尺寸32位） |
  | long long | 长整型（最小尺寸64位） |
  | float     | 单精度浮点数           |
  | double    | 双精度浮点数           |

- 带符号类型和无符号类型

  - 类型`int,short,long和long long`都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型
  - 而字符型则被分为`char、signed char和unsigned char`
  - 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数

- 类型转换

  - 浮点数和整数：
    - 浮点数->整数，结果仅保留浮点数中小数点之前的部分
    - 整数->浮点数，小数部分记为0
  - 布尔类型：
    - 非布尔类型->布尔类型

- 字面值常量

  - 字符和字符串字面值
    - 用单引号括起来的一个字符为char型字面值，双引号括起来的零个或多个字符为字符串字面值
  - 转义序列
    - 在c++语言中有特殊含义的字符是不能直接使用的，在这些情况下需要用到转义序列
    - 转义序列均以反斜杠开始，如`\n`表示换行，`\"`表示双引号，`\'`表示单引号
  - 指定字面值类型
    - 通过前缀或后缀可以改变整型、浮点型和字符型字面值的默认类型
    - 如对于整型，前缀`ll`可以表示`long long`，前缀`l`可以表示`long`

<br/>

<br/>

## 2.2 变量

- 命名规范
  - 需要由字母、数字和下划线组成，同时对大小写敏感
  - 变量名一般用小写字母，类名一般用大写字母开头
- 变量声明和定义的关系
  - **声明**使得名字为程序所知，**定义**负责创建于名字关联的实体
  - 变量能且只能被定义一次，但是可以被多次声明

```c++
extern int i;	//	是声明i而不是定义i
int j;	//	声明并定义了j
```

- 初始值
  - 当对象在创建时候获得了一个特定的值，这个对象就被初始化了
  - 初始化不是赋值，赋值是指把对象的当前值擦除，而以一个新值代替
- 初始化的几种方式

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

<br/>

<br/>

## 2.3 复合类型

- 引用
  - 引用即为对象起了另外一个名字
  - 引用通常是将声明写成`&d`的形式来定义引用类型，其中d是声明的变量名
  - 因为引用本身不是一个对象，所以不能定义引用的引用
  - 引用类型的初始值必须是一个对象，且类型要与原对象相同

```c++
int a = 1024;
int &a1 = a;//a1是a的一个引用
cout << a1 << endl;//1024
a ++ ;
cout << a1 << endl;//1025，可以看出引用的本质
```

- 指针
  - 指针本身是一个对象，允许对指针赋值或拷贝，所以可以指向不同的对象（但是指针类型要与指向的对象的类型相同）
  - 指针的含义是存放着某个对象的地址
  - 指针无须再定义时赋值
  - 通常是将声明符写成`*d`的形式，其中d是变量名，如果一条语句中定义了几个指针变量，每个变量前面都要有`*`

```c++
int a = 2047;
int *a1;//定义一个指向int型对象的指针

a1 = &a;//a1存放a的地址，也可以说a1是指向a的指针
//&是取地址符，用于获取对象的具体地址
//注意：&在定义的类型的后买你是声明的一部分，而在表达式中是取地址符

cout << *a1 << endl;//2047
//*是解引用符号，用于获取指针所指向的对象的值
//注意：*在定义中的类型的后面是声明的一部分，而在表达式中的是解引用符

*a1 = 0;//通过对*a1进行赋值，从而改变a的值


int *p1 = 0;
int *p2 = nullptr;
//上面两条语句都表示空指针（需要首先#include <cstdlib>）

int *pi;
int zero = 0;
p1 = zero;//虽然zero=0，但还是不可以把int变量直接赋给指针


void *pv = &obj;//这里定义的是一个特殊的指针类型，obj可以指向任意类型的对象，即pv可以存放任意类型指针


int ival = 1024;
int *pi = &ival;
int **ppi = &pi;//可以定义指向指针的指针

int i = 42;
int *p;
int * &r = p;//r是一个对指针p的引用
```

<br/>

<br/>

## 2.4 const限定符

- `const`是指把一个变量变为常量

- 与define的区别
  - `const`常量有数据类型，而define定义宏常量没有数据类型
  - define宏是在预处理阶段展开，`const`常量则是编译运行阶段使用
  - define宏仅仅是展开，有几个地方使用则展开几次，不分配内存；`const`常量会在内存中分配地址（可以是堆中也可以是栈中）
  - define定义的常量在内存中有若干个拷贝，`const`定义的常量在程序运行过程中只有一份拷贝，甚至不为普通`const`常量分配存储空间，而是将它们保存在符号表中，相当于没有了读内存的操作，使得效率也很高

<br/>

<br/>

## 2.5 处理类型

- 类型别名

  - 是某种类型的同义词，使用类型别名可以使复杂的类型名字变得简洁明了

  ```c++
  typeof double wages;//typeof命名
  using SH = short;//用using命名，简称别名声明
  ```

  - 和define的区别：
    - #define是 C 中定义的语法, typedef 是 C++ 中定义的语法, 二者在 C++ 中可以通用
    - 但 #define 成了预编译指令, typedef 当成语句处理

- `auto`类型说明符

  - 有时声明变量的时候很难知道表达式的类型，就可以用`auto`来让编辑器替我们分析所属类型
  - 所声明的变量一定有初始值
  - 可以同时声明多个变量，但数据类型一定要相同

```c++
int i = 1;
auto j = i * 2047;//即j的类型就是int
```

- `decltype`类型指示符
  - 希望从表达式的类型推断处要定义的变量的类型，但是不想用该表达式的值初始化变量

```c++
decltype(f()) sum = x;//sum的类型就是函数f的返回类型
```

<br/>

<br/>

## 2.6 自定义数据类型

定义一个结构体

```c++
struct Sales_data{
  	string bookNo;
    unsigned units_sold = 0;
    double revence = 0.0;
};
```

使用结构体中的

```c++
Sales_data data1, data2;cin >> data1.bookNo >> data1.units_sold;
```