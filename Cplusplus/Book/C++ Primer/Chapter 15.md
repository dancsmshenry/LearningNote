# 第15章 面向对象程序设计

## 15.1 OOP：概述

- 面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定（多态）
  - 通过数据抽象，将类的接口和实现分离
  - 使用继承，可以定义相似的类型并对其相似关系建模
  - 使用动态绑定，可以在相似的类型并对其关系建模
- 继承
  - 在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类
  - 基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为虚函数
  - 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的
- 动态绑定
  - 函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时被称为运行时绑定

<br/>

<br/>

## 15.2 定义基类和派生类

- 定义基类

  - 基类通常应该定义一个虚析构函数，即使该函数不执行任何实际操作

- 成员函数与继承

  - 虚函数：基类希望其派生类进行覆盖的函数
  - 当我们使用指针或引用调用虚函数时，该调用将被动态绑定（即根据实际的对象来调用函数）
  - 任何构造函数之外的非静态函数都可以是虚函数

- 访问控制与继承

  - 基类希望它的派生类有权访问该成员，同时禁止其他用户访问，用受保护访问运算符说明这样的成员

- 派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来的

  - 类派生列表的形式：一个冒号，后面紧跟以逗号分割的基类列表，，其中每个基类前都有访问说明符

- 派生类中的虚函数

  - cpp11新标准：允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数（在最后面加上override）

- 派生类对象及派生类向基类的类型转换

  - 一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生对象继承的基类对应的子对象
  - 综上：就有了派生类到基类的类型转换
  - 总结：在派生类对象中含有与其基类对应的组成部分

- 派生类构造函数

  - ```cpp
    Bulk_quote(const std::string& book, double p, std::size_t qty, double disc):Quote(book, q), min_qty(qty), discount(disc){}
    //这里是先调用基类的构造函数在初始化派生类独有的数据
    ```

  - 总结：首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

- 派生类使用基类的成员

  - 总结：派生类可以访问基类的公有成员和受保护的成员

- 派生类的声明

  - 总结：派生类声明中包含类名但是不包含它的派生列表

- 被用作基类的类

  - 如果一个类被用作基类，则该类必须已经定义而非仅仅声明
  - 直接基类（爸爸），间接基类（爷爷）

- 防止继承的发生

  - ```cpp
    class NoDerived final{};
    ```

  - 总结：在类的后面加上final来防止继承

- 继承与静态成员

  - 如果基类定义了一个静态成员，则在整个继承体系中只存在该陈冠的唯一定义

- 可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：但使用基类的引用（或指针）时，该对象可能是基类的对象，也可能是派生类的对象

- 静态类型与动态类型

  - 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型

  - 动态类型则是变量或表达式表示的内存中的对象类型，知道运行时才可知

  - 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致！！！

  - ps：一个我踩的误区

  - ```cpp
    class A{
        public:
            int i;
    };
    
    class B:public A{
        public:
            int j;
    };
    
    void test(A a){
        std::cout << a.i << "void test()" << std::endl;
    }
    //这里看上去好像是动态类型，因为即使传入的是b，好像也会当作b来处理，就有点多态的感觉了
    //而实际上，这里其实是把B类型给切割了，把其中A的部分给拿了出来
    ```

- 不存在从基类向派生类的隐式转换...

  - 之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到给基类部分上
  - 不存在基类向派生类的隐式转换（派生类用到的属性可能基类没有）！！
  - 即使一个基类指针或引用绑定在一个派生类对象上，我们也不能从基类转到派生类，编译器在编译时无法确定某个特定的转换在运行时是否安全

- ...在对象之间不存在类型转换

  - 派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换
  - PS：当初始化或赋值一个类类型的对象时，实际上调用的是某个函数，这些成员通常都包含一个参数，该参数的类型就是类类型的const版本的引用
  - 即：给基类的构造函数传递一个派生类对象，实际运行的构造函数是基类中定义的那个（即把派生类中基类的部分给切割出来）
  - 总结：
    - 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉
    - 从派生类向基类的类型转换只对指针或引用类型有效
    - 基类向派生类不存在隐式类型转换

<br/>

<br/>

## 15.3 虚函数

- 对虚函数的调用可能在运行时才被解析

  - 当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数
  - 动态绑定只有当我们通过指针或引用调用虚函数时才会发生
  - 对非虚函数的调用在编译时进行绑定
  - 总结：当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同

- 派生类中的虚函数

  - 总结：基类中的虚函数在派生类中隐含地也是一个虚函数，当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配
  - 一般来说返回值的类型也要相同，但是如果是返回类本身的指针或引用的话就例外了
  - 所以一个好习惯，在派生类的虚函数前面加上virtual

- final和override说明符

  - override说明派生类中的虚函数（如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器就会报错）
  - 把函数指定为final，则任何尝试覆盖该函数的操作将会引发错误

- 虚函数与默认实参

  - 如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定（如果是通过基类的引用或指针调用函数，则使用基类中定义的默认实参）
  - 总结：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致

- 回避虚函数的机制

  - 不希望对虚函数的调用不要进行动态绑定

  - ```cpp
    A* a = new B();
    a->test();//正常的虚函数调用
    a->A::test();//强制调用某个特定版本的虚函数
    ```

  - 通常，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制（如：当一个派生类的虚函数需要调用它覆盖的基类的虚函数版本的时候）

  - 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致 

<br/>

<br/>

## 15.4 抽象基类

- 纯虚函数
  - 纯虚函数的定义：在函数体的位置（即声明语句的分号之前）书写=0（其中=0只能出现在类内部的虚函数声明语句处）
  - 可以为纯虚函数提供定义，但函数体必须定义在类的外部，不能在类的内部为一个=0的函数提供函数体
- 含有纯虚函数的类是抽象基类
  - 含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类
  - 不能创建一个抽象基类
  - 抽象基类负责定义接口，后续的其他类可以覆盖接口
  - 总结：不能创建抽象基类的对象
- 派生类构造函数只初始化它的直接基类
  - 即派生类只需要调用直接基类的构造函数，至于其他的变量就由直接基类去初始化管理
  - 重构：负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中（所以一旦重构了，就要重新编译代码了）

<br/>

<br/>

## 15.5 访问控制与继承

- 受保护的成员

  - 关于protected：
  - 受保护的成员对于类的用户来说是不可访问的，对于派生类的成员和友元来说是可以访问的
  - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权（即派生类的友元或成员，要想访问到基类的protected，必须通过派生类，而不能通过基类）

- 公有、私有和受保护继承

  - 派生访问说明符  对于派生类的成员（及友元）   能否访问   其直接基类的成员   没影响，只和基类中的访问说明符有关
  - 派生访问说明符的目的是控制        派生类用户（包括派生类的派生类）       对于         基类成员         的访问权限
  - 类的访问修饰符都是对于类的使用者来说的，public则无事发生，private则表示基类的属性对类的派生类和类的使用者private，protected则表示基类属性对类的使用者private，但对类的派生类public

- 派生类向基类转换的可访问性

  - 只有公有继承，派生类才可以向基类转换（即私有和保护的都不可以）
  - 基类的成员函数和友元都能使用派生类向基类的转换
  - 只有公有或保护继承，派生类的成员或友元可以使用基类向派生类的类型转换（即私有不可以）

- 友元与继承

  - 派生类的友元也不能随意访问基类的成员
  - 即友元函数只能访问到属于它的那个朋友的属性（如果是朋友的派生类的属性，那就无法访问得到）
  - 当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效
  - 总结：不能继承友元关系，每个类负责控制各自成员的访问权限

- 改变个别成员的可访问性

  - 通过using声明改变 继承下来的 属性的访问性

  - ```cpp
    class Base{
        public:
        	std::size_t size() const {return n;}
        protected:
        	std::size_t n;
    };
    
    class Dervied : private Base{
        public:
        	using Base::size;
        protected:
        	using Base::n;
    };
    ```

  - 通过在类的内部使用using声明语句，可以将该类的直接或间接基类中的任何访问成员标记出来

  - 如果基类的属性已经为private了，那么就无法using声明

  - 派生类只能为那些它可以访问的名字提供using声明

- 默认的继承保护级别

  - 使用class定义的派生类默认是私有的；使用struct定义的派生类默认是public的

  - ```cpp
    class Base{};
    struct D1:Base{};//public继承
    class D2:Base{};//private继承
    ```

  - 总结：一个私有派生的类最好显式地将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会

<br/>

<br/>

## 15.6 继承中的类作用域

- 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内
- 在编译时进行名字查找
  - 一个对象、引用或指针的静态类型决定了该对象的那些成员是可见的
  - 所以对于一个指针或引用、需要寻找的对象如果只是出现在对象上，该指针上没有，那就是找不到的
- 名字冲突与继承
  - 派生类的成员将隐藏同名的基类成员（即使隐藏了，但是内存管理上派生类还是会有的）
- 通过运算符来使用隐藏的成员
  - 如题
  - tips：除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字
- 一如往常，名字查找先于类型检查
  - 背景：声明在内层作用域的函数并不会重载声明在外层作用域的函数
  - 推广：如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏该基类成员（如果要用到基类的同名函数，必须加上类名和：：）
- 虚函数与作用域
  - 背景：假如基类与派生类的虚函数接受的实参不同，就无法通过基类的引用或指针调用派生类的虚函数
  - 原因：派生类的同名函数会隐藏基类的同名函数，以致于无法调用得到基类的虚函数
- 通过基类调用隐藏的虚函数
  - 在动态绑定的过程中，如果指针所在的类没有该虚函数，即使指向的派生类由这个虚函数，也不会调用
  - 而对于非虚函数而言，实际调用的函数版本由指针的静态类型决定
- 覆盖重载的函数
  - 背景：重载基类函数的时候，会覆盖掉基类原有的函数
  - 解决：在派生类中写一个using+函数名就可以把该函数的所有重载实例添加到派生类作用域中（前提：基类函数的每个实例在派生类中都必须是可访问的）

<br/>

<br/>

## 15.7 构造函数与拷贝控制

- 虚析构函数

  -  只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本
  -  如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为
  -  如果一个类定义了析构函数，则即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作

- 合成拷贝控制与继承

  -  派生类合成的成员使用直接基类中对应的操作对对象的直接基类进行初始化、赋值或销毁的

- 派生类中删除的拷贝控制与基类的关系

  -  如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数被删除或不可访问，则派生类的对应函数是被删除的
  -  基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数是被删除的

- 移动操作与继承

  -  基类缺少移动操作会阻止派生类拥有自己的合成构造函数（所以如果基类由虚析构函数，那么当子类需要移动操作的时候，就要先给基类写一个默认的移动操作函数）

- 派生类的拷贝控制成员

  -  当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象

- 定义派生类的拷贝或移动构造函数

  - 当为派生类定义拷贝或移动构造函数，可以使用对应基类构造函数初始化对象的基类部分

  - ```cpp
    class Base{};
    class D:public Base{
        public:
        	D(const D& d):Base(d){}
    };
    ```

  - 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数

- 派生类赋值运算符

  - 同样，这里也会要调用基类的赋值运算符

  - ```cpp
    D& D::operator=(const D& rhs){
        Base::operator=(rhs);//为基类部分赋值
    }
    ```

- 派生类析构函数

  -  派生类析构函数只负责销毁由派生类自己分配的资源
  -  对象销毁的顺序正好与其创建的顺序相反

- 在构造函数和析构函数中调用虚函数

  -  如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本
  -  但这和我们的初衷（根据对象的不同在构造函数中调用不同类型的虚函数）不同，所以最好不要这样做

- 继承的构造函数

  - 一个类只继承其直接基类的构造函数，不能继承默认、拷贝和移动构造函数

  - 派生类继承基类构造函数的方式是提供基类名的using声明语句

  - ```cpp
    class Bulk_quote:public Disc_quote{
        public:
        	using Disc_quote::Disc_quote;//继承Disc_quote的构造函数
        //对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数
    };
    ```

- 继承的构造函数的特点

  -  一个构造函数的using声明不会改变该构造函数的访问级别（包括不能指定explicit或constexpr）
  -  当一个基类构造函数含有默认实参时，这些实参并不会被继承（相反派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参）（这里书上有例子）

<br/>

<br/>

## 15.8 容器与继承

<br/>

<br/>

## 15.9 文本查询程序再探