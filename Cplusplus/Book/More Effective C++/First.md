
- [条款1：指针与引用的 区别](#条款1指针与引用的-区别)
- [条款2：尽量使用c++风格的类型转换](#条款2尽量使用c风格的类型转换)
- [条款3：不要对数组使用多态](#条款3不要对数组使用多态)
- [条款4：避免无用的缺省构造函数](#条款4避免无用的缺省构造函数)
- [条款5：谨慎定义类型转换函数](#条款5谨慎定义类型转换函数)
- [条款6：自增自减操作符前缀形式与后缀形式的区别](#条款6自增自减操作符前缀形式与后缀形式的区别)
- [条款7：不要重载&&，||和,操作符](#条款7不要重载和操作符)
- [条款8：理解各种不同含义的new或delete](#条款8理解各种不同含义的new或delete)
- [条款13：通过引用（reference）捕获异常](#条款13通过引用reference捕获异常)


###### 条款1：指针与引用的 区别

- 指针用操作符“*”和“->”，引用使用操作符“. ”
- 任何情况下都不能使用指向空值的引用，引用应该被初始化
- 因此如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向 任何对象，这时你应该把变量声明为指针，因为这样你可以赋空值给该变量。相反，如果变 量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为引用
- 指针与引用的另一个重要的不同是指针可以被重新赋值以指向另一个不同的对象。但是 引用则总是指向在初始化时被指定的对象，以后不能改变
- 使用指针的情况：
  - 存在不指向任何对象的时候
  - 需要改变指向对象的时候
- 使用引用的情况：
  - 重载某个操作符的时候



###### 条款2：尽量使用c++风格的类型转换

- 原因
  - c风格的强制转换在代码上难以识别
  - 过于粗鲁，允许你在任何类型之间进行转换
- 所以，最好使用以下四种cpp的强制转换类型
  - static_cast
  - const_cast
  - dynamic_cast
  - reinterpret_cast



###### 条款3：不要对数组使用多态

- 比如B类是继承A类的，写了一个函数是操作A类的，但是这个函数此时又对B类进行操作了，就会出现问题
  - 因为数组的操作实际上是指针在移动，操作A类的函数，指针移动的位移大小是A类对象的大小，而明显B类的大小是大于A类的，此时就会出现问题



###### 条款4：避免无用的缺省构造函数



###### 条款5：谨慎定义类型转换函数

- cpp中有两种方法进行类型的转换，一个是单参数构造函数，另一个是隐式类型转换符
- 对于单参数构造函数，很容易说被作为隐式转换，如
  - 类student，构造函数有一个student(int a)，而如果写代码的时候不小心写了一个student1 == b(其中b为int，是8)，那么这里就会被不自觉的转换为student类型，就不会出现我们想要的报错（因为这本身就是代码逻辑上的错误，却因为编辑器的隐式转换而敷衍过去了）
  - 所以，对于单参数构造函数，最好在其前面加上explicit，防止被隐式转换
- 对于隐式类型转换符，写法是operator加上类型关键词，这种转换函数不好的地方，在一些我们认为正确的地方，编译器会不自觉的调用这种隐式转换符，导致代码错误，如
  - 类rational，有一个double类型的隐式转换，而代码cout << 一个rational类型的时候，本来是不能执行的，但是因为这种隐式转换，就可以执行了，和我们想要的代码结果不一样
  - 所以，对此，最好单独写一个函数来替换掉这种重载，如用asDouble代替operator double



###### 条款6：自增自减操作符前缀形式与后缀形式的区别

- 后缀增加符号返回的应该是一个const类型的值，如果不是的话，就会出现说i++++，第一个++返回的就是一个临时的对象
- 第二个++调用的就是这个临时的对象了，就达不到我们想要的效果
- 所以应该将返回值设为const，表明返回值是不可以被修改的，即在语法上打消了这种做法
- 因此，这种后缀创造临时对象的方式会降低程序的效率，正常情况下应该大量的使用前缀++



###### 条款7：不要重载&&，||和,操作符

- 前两个操作符的情况是，如果前面一个是真或是假，那么后面一个就不用再算下去了
- 但是重载过后，会变为函数运算，而函数运算传入的参数是要事先进行运算的，即两个都要算一下
- 而对于&&和||来说，这个运算符的前一个会决定后一个要不要算，所以在使用的时候会造成说后面一个会出现越界的情况，
- 这种重载就与常规的使用不符，
- 逗号运算符也是一样的，逗号运算符是要保证左边的内容要先于右边的内容运算的，而函数吗，你懂的，是不能准确说谁先运算谁后运算的



###### 条款8：理解各种不同含义的new或delete



###### 条款13：通过引用（reference）捕获异常

- 传入参数的三种方式
  - 通过指针，通过传值，通过引用