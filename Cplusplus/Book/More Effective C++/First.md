
- [条款1：指针与引用的区别](#条款1指针与引用的区别)
- [条款2：尽量使用c++风格的类型转换](#条款2尽量使用c风格的类型转换)
- [条款3：不要对数组使用多态](#条款3不要对数组使用多态)
- [条款4：避免无用的缺省构造函数](#条款4避免无用的缺省构造函数)
- [条款5：谨慎定义类型转换函数](#条款5谨慎定义类型转换函数)
- [条款6：自增、自减操作符前缀形式与后缀形式的区别](#条款6自增自减操作符前缀形式与后缀形式的区别)
- [条款7：不要重载&&，||和,操作符](#条款7不要重载和操作符)
- [条款8：理解各种不同含义的new或delete](#条款8理解各种不同含义的new或delete)
- [条款13：通过引用（reference）捕获异常](#条款13通过引用reference捕获异常)
- [有关本书的一些特殊用于的扫盲](#有关本书的一些特殊用于的扫盲)







###### 条款1：指针与引用的区别

- 区别：
  - 指针用操作符“*”和“->”，引用使用操作符“. ”
  - 任何情况下都不能使用指向空值的引用，引用应该被初始化
  - 如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该把变量声明为**指针**，因为这样你可以赋空值给该变；相反，如果变量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为**引用**
    - 总结为：指针可以被重新赋值以指向另一个不同的对象，而引用则总是指向在初始化时被指定的对象，以后不能改变
  - 不存在指向空值的引用。这意味着使用引用的代码效率比使用指针的要高，因为在使用引用之前不需要测试它的合法性
- 使用指针的情况：
  - 存在不指向任何对象的时候（在这种情况下，指针可设为空）
  - 需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）
- 使用引用的情况：
  - 总是指向一个对象，并且一旦指向一个对象后就不会改变指向
  - 重载某个操作符的时候





###### 条款2：尽量使用c++风格的类型转换

- 原因：
  - c风格的强制转换在代码上难以识别
    - 在语法上，类型转换由圆括号和标识符组成，而这些可以用在 C++ 中的任何地方
  - 过于粗鲁，允许你在任何类型之间进行转换
- 所以，最好使用以下四种cpp的强制转换类型
  - static_cast
    - 不能去掉 const 
    - 只能转相同类型的类型
  - const_cast
    - 用于类型转换掉表达式的 const 或 volatileness 属性
  - dynamic_cast
    - 被用于安全地沿着类的继承关系向下进行类型转换
    -  把指向基类的指针或引用转换成指向其派生类或其兄弟类的指针或引用，而且你能知道转换是否成功
    - 失败的转换将返回空指针（当对指针进行类型转换时）或者抛出异常（当对引用进行类型转换时）
    - 在浏览继承层次上是有限制的，不能被用于缺乏虚函数的类型上，也不能用来去掉constness
  - reinterpret_cast
    - 相当于是一个强制转换的过程
    - 最普遍的用途就是在函数指针类型之间进行转换
    - 而转换函数指针的代码时不可移植的，所以应该避免转换函数指针类型





###### 条款3：不要对数组使用多态

- 比如说B类是继承A类的，写了一个函数是操作A类的，但此时传入了一个B类的数据到这个函数，就会出现问题
  - 因为数组的操作实际上是指针在移动，操作A类的函数，指针移动的位移大小是A类对象的大小，而明显B类的大小是大于A类的
- 这里探回数组的本质
  - array[i]其实只是一个指针算法的缩写，所代表的是*（array），即array是一个指向数组起始地址的指针，其中每个元素的地址之间的间隔都是一个在数组里的对象的大小
  - 而编译器为了建立正确遍历数组的执行代码，它必须能够确定数组中对象的大小
  - 很明显，如果我实际传进来的数组元素的大小比这个大，就会出现错误
- 因此：通过一个基类指针来删除一个含有派生类对象的数组，结果是不对的







###### 条款4：避免无用的缺省构造函数

- 缺省构造函数（指没有参数的构造函数）
- 对于很多对象来说，不利用外部数据进行完全的初始化是不合理的。比如一个没有输入姓名的地址簿对象，就没有任何意义
- 如果没有缺省构造函数
  - 就不能直接构造该对象的数组（要构建的话需要逐个逐个的传参构建），也不能通过指针来构造该对象的数组（需要的话需要创建指针数组；不过有两个缺点：第一：必须删除数组里每个指针所指向的对象，否则会发生内存泄漏；第二：增加了内存分配量，因为还要预留空间来存指针）
  - 





###### 条款5：谨慎定义类型转换函数

- cpp中有两种方法进行隐式转换，一个是单参数构造函数（是指只用一个参数即可以调用的构造函数），另一个是隐式类型转换运算符（operator 关键字）
- 为什么不适用各种类型转换函数：当你在不需要使用转换函数时，这些的函数却会被调用运行
- 对于单参数构造函数（很容易说被作为隐式转换）
  - 细节两则
    - 对于一个类对象数组Array，如果现在构建了两个Array对象a和b，在判断a[i] == b[i]的时候，写成了a == b[i]，而Array有一个单参数的构造函数，那么，此时编译器是不会报错的（这里的b[i]是一个数字），编译器会自动调用这个单参数的构造函数，然后变为 a == static_cast< Array >(b[i]) 的比较，就不会显示是我们代码上的错误
    - 类student，构造函数有一个student(int a)，而如果写代码的时候不小心写了一个student1 == b(其中b为int，是8)，那么这里就会被不自觉的转换为student类型，就不会出现我们想要的报错
    - 因为这些本身就是代码逻辑上的错误，却因为编辑器的隐式转换而敷衍过去了
  - 解决办法
    - 运用explicit关键字声明单参数构造函数（编译器会拒绝为了隐式类型转换而调用构造函数。显式类型转换依然合法）
- 对于隐式类型转换符（operator加上类型关键词）
  - 细节一则：
    - 这种转换函数不好的地方，在一些我们认为正确的地方，编译器会不自觉的调用这种隐式转换符，导致代码错误
    - 类rational，有一个double类型的隐式转换，而代码cout << 一个rational类型的时候，本来是不能执行的，但是因为这种隐式转换，就可以执行了，和我们想要的代码结果不一样
    - 所以，对此，最好单独写一个函数来替换掉这种重载，如用asDouble代替operator double（用不使用语法关键字的等同的函数来替代转换运算符）
  - 解决办法：不声明运算符（operator）





###### 条款6：自增、自减操作符前缀形式与后缀形式的区别

- 后缀增加符号返回的应该是一个const类型的值，如果不是的话，就会出现说i++++，第一个++返回的就是一个临时的对象
- 第二个++调用的就是这个临时的对象了，就达不到我们想要的效果
- 所以应该将返回值设为const，表明返回值是不可以被修改的，即在语法上打消了这种做法
- 因此，这种后缀创造临时对象的方式会降低程序的效率，正常情况下应该大量的使用前缀++



###### 条款7：不要重载&&，||和,操作符

- 前两个操作符的情况是，如果前面一个是真或是假，那么后面一个就不用再算下去了
- 但是重载过后，会变为函数运算，而函数运算传入的参数是要事先进行运算的，即两个都要算一下
- 而对于&&和||来说，这个运算符的前一个会决定后一个要不要算，所以在使用的时候会造成说后面一个会出现越界的情况，
- 这种重载就与常规的使用不符，
- 逗号运算符也是一样的，逗号运算符是要保证左边的内容要先于右边的内容运算的，而函数吗，你懂的，是不能准确说谁先运算谁后运算的



###### 条款8：理解各种不同含义的new或delete



###### 条款13：通过引用（reference）捕获异常

- 传入参数的三种方式
  - 通过指针，通过传值，通过引用





###### 有关本书的一些特殊用于的扫盲

- placement new
  - 是指在特定的内存空间为准备创建的对象分配内存（而传统的new是调用operator new来分配内存）
  - 例：先分配一个空的数组（特定的内存空间），然后用new创建一个对象，指定是在这个空数组的内存上创建