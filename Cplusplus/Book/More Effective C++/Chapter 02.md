# 条款5：谨慎定义类型转换函数

- cpp中有两种方法进行隐式转换，一个是单参数构造函数（是指只用一个参数即可以调用的构造函数），另一个是隐式类型转换运算符（operator 关键字）
- 为什么不适用各种类型转换函数：当你在不需要使用转换函数时，这些的函数却会被调用运行
- 对于单参数构造函数（很容易说被作为隐式转换）
  - 细节两则
    - 对于一个类对象数组Array，如果现在构建了两个Array对象a和b，在判断a[i] == b[i]的时候，写成了a == b[i]，而Array有一个单参数的构造函数，那么，此时编译器是不会报错的（这里的b[i]是一个数字），编译器会自动调用这个单参数的构造函数，然后变为 a == static_cast< Array >(b[i]) 的比较，就不会显示是我们代码上的错误
    - 类student，构造函数有一个student(int a)，而如果写代码的时候不小心写了一个student1 == b(其中b为int，是8)，那么这里就会被不自觉的转换为student类型，就不会出现我们想要的报错
    - 因为这些本身就是代码逻辑上的错误，却因为编辑器的隐式转换而敷衍过去了
  - 解决办法
    - 运用explicit关键字声明单参数构造函数（编译器会拒绝为了隐式类型转换而调用构造函数。显式类型转换依然合法）
- 对于隐式类型转换符（operator加上类型关键词）
  - 细节一则：
    - 这种转换函数不好的地方，在一些我们认为正确的地方，编译器会不自觉的调用这种隐式转换符，导致代码错误
    - 类rational，有一个double类型的隐式转换，而代码cout << 一个rational类型的时候，本来是不能执行的，但是因为这种隐式转换，就可以执行了，和我们想要的代码结果不一样
    - 所以，对此，最好单独写一个函数来替换掉这种重载，如用asDouble代替operator double（用不使用语法关键字的等同的函数来替代转换运算符）
  - 解决办法：不声明运算符（operator）

<br/>

<br/>

# 条款6：自增、自减操作符前缀形式与后缀形式的区别

- 后缀增加符号返回的应该是一个const类型的值，如果不是的话，就会出现说i++++，第一个++返回的就是一个临时的对象
- 第二个++调用的就是这个临时的对象了，就达不到我们想要的效果
- 所以应该将返回值设为const，表明返回值是不可以被修改的，即在语法上打消了这种做法
- 因此，这种后缀创造临时对象的方式会降低程序的效率，正常情况下应该大量的使用前缀++

<br/>

<br/>

# 条款7：不要重载&&，||和,操作符

- 前两个操作符的情况是，如果前面一个是真或是假，那么后面一个就不用再算下去了
- 但是重载过后，会变为函数运算，而函数运算传入的参数是要事先进行运算的，即两个都要算一下
- 而对于&&和||来说，这个运算符的前一个会决定后一个要不要算，所以在使用的时候会造成说后面一个会出现越界的情况，
- 这种重载就与常规的使用不符，
- 逗号运算符也是一样的，逗号运算符是要保证左边的内容要先于右边的内容运算的，而函数吗，你懂的，是不能准确说谁先运算谁后运算的

<br/>

<br/>

# 条款8：理解各种不同含义的new或delete