# 6.1 继承体系下的对象构造步骤

- 对象的构造顺序
  - 先构造爷爷类，补充爷爷类的虚指针
  - 然后构造父亲类，补充父亲类的虚指针
  - 最后构造自己，补充虚指针，接着初始化列表，最后调用自己的代码

- 虚函数的继续观察
  - 千万不要在构造函数中使用memcpy或直接操作等手段，来修改虚函数指针的值，否则可能会造成无法调用虚函数的情况
  - 对于自己类的虚函数指针，首先是补充为爷爷类的虚指针，接着是补充为父亲类的虚指针，再接着才是补充为自己的指针
- 构造函数中对虚函数的调用
  - 某个类的构造函数 中 调用一个虚函数，走的不是虚函数表，而是直接通过虚函数地址，直接调用这个虚函数（静态方式）
  - 如果当前类没有，就会返回父类去找，递归寻找
  - 一个比较好玩的事情：如果在构造函数中调用虚函数，这个虚函数再调用一个虚函数，那么后面这个虚函数走的是**虚函数表**

<br/>

<br/>

# 6.2 对象复制语义学、析构函数语义学

- 对象的默认复制行为
  - 如果我们不写自己的拷贝构造函数和拷贝赋值运算符，编译器也会有默认的对象拷贝和对象赋值行为
- 拷贝赋值运算符，拷贝构造函数
  - 当我们提供自己的拷贝赋值运算符和拷贝构造函数的时候，我们就接管了系统默认的拷贝行为，此时，我们有责任在拷贝赋值运算符和拷贝构造函数中写适合的代码，来完成对象的拷贝或者是赋值
- 如何禁止对象的拷贝构造和赋值
  - 把拷贝构造函数和拷贝赋值运算符私有起来，只声明，不需要函数体
  - cpp11以后也可以用delete来解决
- 析构函数语义
  - 析构函数被合成（如果不需要的话，编译器是不会生成的，什么情况下编译器会给我们生成一个析构函数）
    - 如果继承一个基类，基类中带有析构函数，那么编译器会合成一个析构函数调用基类中的析构函数
    - 如果类成员是一个类类型成员，并且这个成员带析构函数，编译器也会合成一个析构函数，意义是调用类类成员的析构函数
  - 析构函数被拓展（如果我们有自己的析构函数，那么编译器就会在适当的时候拓展我们的析构函数代码）
    - 如果类成员是一个类类型，并且这个成员带析构函数，编译器拓展类的析构函数（是先执行自己的析构以及代码，再执行成员的析构，即是做完了全部工作，再析构类成员）
    - 如果继承一个基类，基类中带析构函数，那么编译器就会拓展析构函数来调用基类中的析构函数（也是先执行类本身的析构部分，最后再析构基类）

<br/>

<br/>

# 6.3 局部对象、全局对象的构造和析构

- 局部对象的构造和析构
  - 会在，退出对象的作用域的地方，编译器总会在适当的地方插入调用对象的析构函数的代码
  - 所以，最好现用现定义
  - 对于局部对象，里面的属性是随机值（如果构造函数不给初值的话）
- 全局对象的构造和析构
  - 全局变量是放在数据段里的
  - 在构造函数不给初值的情况下，编译器会默认把全局对象所在的内存全部清0（也叫静态初始化）
  - 全局变量在编译阶段就会把空间分配出来（全局变量的地址在编译期间就确定好的，内存也是编译时分配好的，放在BSS数据段里面）
  - 是在main函数执行之前就被构造完毕；在main函数执行完毕后，才被析构
- 总结：
  - 全局对象获得地址（编译时确定好的，内存也是编译时分配好的，内存时运行期间一直存在）
  - 把全局对象的内存内容清零
  - 调用全局对象的构造函数
  - main函数执行完毕，调用析构函数

<br/>

<br/>

# 6.4 局部静态对象、对象数组构造析构和内存分配

- 局部静态对象的构造和析构
  - 如果我们不调用局部的代码，那么局部静态对象就不会被生成
  - 局部静态对象，内存地址是在编译期间就确定好了的
  - 静态局部量刚开始也被初始化为0
  - 局部静态对象的析构，也是在main函数执行结束后才被调用的
  - 局部静态对象之后被构造一次（如何实现只被构造一次：编码中有一个4位的地址用来表示对象是否被创建过；如何实现在main函数后析构：汇编中插入代码，告诉程序在main执行后要执行析构）
  - 总结：局部静态对象只会被构造一次，在调用的时候构造；在main函数执行完毕后析构
- 局部静态对象数组的内存分配
  - 和局部静态对象的特点基本一致
  - 只是，如果局部静态对象数组太多了的话，那么在一些编译器上（比如msvc上）就先不会制造出那么多的对象，即只有用到了那么多的对象的时候才会构造出来

<br/>

<br/>

# 6.5 new、delete运算符，内存高级话题

<br/>

<br/>

# 6.6 new、delete的进一步认识

<br/>

<br/>

# 6.7 new细节，重载类内operator new，delete

<br/>

<br/>

# 6.8 内存池概念、代码实现和详细分析

<br/>

<br/>

# 6.9 嵌入式指针概念及范例、内存池改进版

<br/>

<br/>

# 6.10 重载全局new、delete，定位new及重载等

<br/>

<br/>

# 6.11 临时性对象的详细探讨

- 拷贝构造函数相关的临时性对象

  - 如果函数直接返回的是一个对象的话，未优化的情况

    - 那么编译器会产生临时对象，把要返回的结果通过**拷贝构造**放入到这个临时对象当中，然后返回这个临时对象（注意：调用的时候，是直接把这个对象放到结果当中的，所以返回的结果是不会调用拷贝构造函数的）

    - ```cpp
      A operator+(const A& a1, const A& a2) {
          A ombj;
          return ombj;//这里会调用拷贝构造函数
      }
      
      A a = a1 + a2;//这里是直接把这个临时对象给了a，不调用构造函数
      //所以一共是调用了三次构造函数，一次拷贝构造函数
      ```

  - 如果函数直接返回的是一个对象的话，优化的情况

    - 在msvc和gcc的情况下，里面生成的临时对象在退出程序后会被当作结果来使用（调用了三次构造函数）
    - 但是这里的一个但前提就是自己写拷贝构造函数，然后拷贝里面啥都不写（如果我让编译器帮我写的话，那么后面生成的临时对象就不会被当作结果）

- 拷贝赋值运算符相关的临时性对象

  - 事实证明，拷贝构造（优化后直接把临时对象当作该对象）会比拷贝赋值运算符（优化后把临时对象当作一个对象，然后再调用拷贝赋值运算符）更有效率，即会少调用一次构造函数

- 直接运算产生的临时性对象

  - 临时性对象的析构，是在整行语句的最后一步

  - ```cpp
    cout << (ma + mb).i << endl;//这里临时对象的析构，是执行完输出以后才析构的
    ```

  - 临时对象被摧毁

  - ```cpp
    const char* p = (string("133") + string("12")).c_str();//这行有问题，因为临时对象过了这行就会被摧毁，错译打印p的内容的时候发现是空的（msvc下是这样，但是gcc和clang下却是可以运行的）
    ```

  - 临时对象因绑定到引用而被保留

  - ```cpp
    const string &s = string("q") + string("1");
        cout << s.c_str() << endl;
    //因为这个临时对象被引用了，所以它的声明周期就变为其作用域了
    ```
