# 第二章 对象

## 2.1 类对象所占用的空间

- 空类的大小是1，内存中的一个地址单元里面保存的是1个字节的内容（即便是一个空类的对象，但因为在内存中是有起始地址的，既然这个地址属于该对象，该对象必然最少能存得下一个字节）
- 类的成员函数是不占用类对象内存空间的



## 2.2 对象结构的发展和演化

- 非静态的成员变量保存在对象内部
- 静态变量不会保存在对象内部，而是保存在对象外面
- 成员函数不管是静态还是非静态的，或者是虚函数，全都保存在类对象之外
- 虚函数
  - 一个类中只要有虚函数，这个类就会产生一个指向虚函数的指针
  - 虚函数指针指向虚函数表，该表一半保存在最后i可执行文件中，在程序执行的时候载入到内存中
  - 虚函数指针指向虚函数表
- 指针大小是固定的，4字节还是8字节取决于平台
- 注意padding（内存字节对齐）





## 2.3 this指针调整

- 应用于多继承场景
- A,B；C类先后继承A类和B类，所以C类的this指针和A类的指针都是相同的，A类指针和B类指针差了一个类A的大小
- 总结1：如果一个派生只继承了一个基类，那么这派生类对象和基类子对象地址相同
- 如果派生类对象同时继承多个基类，那么第一个基类子对象的起始地址和派生类对象起始地址相同
- 总结2：调用哪一个子类的成员函数，这个this指针就会被编译器自动调整到对象内存布局中对应该子对象的起始地址去





## 2.4 分析obj（目标文件）与构造函数语义

- obj文件是微软编译器编译cpp文件后得到的中间文件
- 编译器生成“合成默认构造函数”的几种情况
  - 第一种情况：该类没有任何构造函数，但包含一个类类型的成员变量，而且该成员变量有一个默认构造函数
  - 第二种情况：父类带有默认构造函数，子类没有任何构造函数（父子类的构造是由内而外的）
  - 第三种情况：一个类含有虚函数，该类没有任何构造函数（需要创建虚函数表和虚指针）
  - 第四种情况：如果一个类带有虚基类，编译器也会为它生成一个“合成默认构造函数”
  - 第五种情况：如果在定义成员变量的时候赋初值，cpp11支持这种新语法



## 2.5拷贝构造函数语义与移动构造函数语义

拷贝构造函数

- 如果没有定义自己的拷贝构造函数，编译器会在必要的时候合成一个拷贝构造函数
- 如果是这种简单类型，直接就按值拷贝过来，编译器在不需要合成拷贝构造函数
- 第一种情况：如果一个类A没有拷贝构造函数，但该类有一个类类型的成员变量，该类含有拷贝构造函数
  - 结论：只是一些类成员变量的值复制这些简单的事情，编译器不用专门生成拷贝构造函数来做，编译器内部就可以完成
- 第二种情况：如果该类没有拷贝构造函数，它有一个父类，且这个父类构造函数有拷贝构造函数
- 第三种情况：如果一个类没有拷贝构造函数，该类定义了虚函数或者该类的父类定义了虚函数
- 第四种情况：如果一个类没有拷贝构造函数，但是该类含有虚基类



移动构造函数

- 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为该类生成出移动析构函数和移动赋值运算符
- 只有一个类没定义任何自己版本的拷贝构造函数、拷贝赋值运算符、析构函数，且类的每个非静态成员都可以移动时，编译器才会为该类合成移动构造函数或者移动赋值运算符
  - 内置类型的成员便来给你可以移动
  - 如果成员变量是一个类类型，如果这个类有对应的移动操作相关的函数，则该成员变量可以移动



## 2.6 程序转换语义

定义时初始化对象

- ```cpp
  X x0;
  X x2(x0);
  //程序员写的代码
  
  X x3_2;
  x3_2.X::X(x0);
  //cpp内部转化的代码
  ```



参数的初始化

- 当把实参传递给形参的时候，调用了拷贝构造函数

- ```cpp
  void func(X tempx){
      return ;
  }
  //这里会调用X的拷贝函数和析构函数
  ```



返回值初始化

- 返回对象的时候，也会调用拷贝构造函数，把局部对象拷贝给返回的对象



## 2.7 程序的优化

从开发者层面的优化

- ```cpp
  //原函数
  X Double(X& ts){
      X temp;
      temp.x1 = ts.x1 * 2;
      temp.x2 = ts.x2 * 2;
      return temp;
  }//因为里面生成了一个对象（后续需要析构里面的临时对象），返回的又是一个临时对象（拷贝给返回值以后又要析构）
  
  //优化后的
  X Double(X& ts){
      return X(ts.x1 * 2, ts.x2 * 2);
  }
  //这样，就减少了一次析构
  ```



从编译器层面的优化



## 2.8 程序优化续、拷贝构造函数续与深浅拷贝

程序优化续

- ```cpp
  class A{
      public:
      	A(int value){
              cout << "A(int value)" << endl;
          }
  };
  
  A a = 100;//会调用转换函数
  ```



拷贝构造续

- 编译器自带的拷贝是bitwise（按位）赋值
- 当处理一些很复杂的成员变量类型的时候，就将指针变量作为类的成员变量
- 程序员往类中增加了拷贝构造函数后，就要对类中各个成员变量的初始化负责



深浅拷贝

- 深拷贝和浅拷贝的区别
- 浅拷贝：对于类定义中有指针变量的情况，只复制指针值，指针所指向的地址编译器并没有额外做处理



## 2.9 成员初始化列表

何时必须用成员初始化列表

- 成员变量是引用类型时
- 成员变量是const类型

- 如果该类继承自一个基类，并且基类中有构造函数，这个构造函数里还有参数
- 如果类中成员变量的类型是某个类类型，而这个类类型所指类的构造函数带有参数



使用初始化列表的优势

- 提高程序效率（可以在这节的代码里面看优化详情）



初始化列表的细节探究

- 初始化列表中的代码可以看作被编译器安插在构造函数中的
- 是在构造函数的函数体代码执行之前被执行
- 其中成员变量的初始化顺序，是这些变量在类中定义的顺序





# 第三章 虚函数

## 3.1 虚函数表指针位置分析

- 虚函数表指针位于对象内存的起始（上面开头）位置



## 3.2继承关系作用下虚函数的手动调用

- 父类对象调用的虚函数都是父类的



## 3.3虚函数表分析

- 包含虚函数的类才会有虚函数表，同属于一个类的对象共享这个虚函数表，但是每个对象都有各自的vptr，当然每个该指针所指向的地址（虚函数表首地址）都相同
- 父类中有虚函数就等于子类中有虚函数，所以因此子类一定也有虚函数指针
- 如果子类中完全没有新的虚函数，则可以认为子类的虚函数表和父类的虚函数表内容相同，只是存储在内存的不同位置
- 超出虚函数表部分的内存内容不可预知



## 3.4多重继承虚函数表分析

- 多重继承情况：A,B,C，C类分别继承了A类和B类
- 结论：
- 子类对象C有两个虚函数表指针
- 子类C有两个虚函数表，因为它继承自两个基类
- 子类和第一个基类共用一个vptr
- 子类中的虚函数覆盖了父类中的同名虚函数



##  3.5辅助工具与vptr、vtbl创建时机

虚函数表的创建时机

- 在编译时候，编译器会往类的构造函数中安插为vptr赋值的语句
- 在编译期间（不是运行期间）就为每个类确定好了对应的虚函数表vtbl的内容

 

## 3.6单纯的类不纯时引发的虚函数调用问题

- 静态联编：编译的时候就能确定调用哪个函数，把调用语句和被调用函数绑定到一起

- 动态联编：在程序运行的时候，根据实际情况，动态地把调用语句和被调用函数绑定到一起，动态联编一般只有在多态和虚函数情况下才存在

- ```cpp
  X x1;
  x1.test();
  x1.tesst();//tesst在X中为虚函数
  //这种直接以定义对象的方式来生成一个对象并通过该对象调用虚函数时根本用不到虚函数表
  ```

- 在栈上生成对象，直接调用虚函数；在堆上生成对象，是通过虚函数表指针找到虚函数表，在虚函数表中查询虚函数地址再调用该虚函数

- 所以，虚函数、多态是专门给指针和引用来使用的

- 不能在构造函数调用memset或在拷贝构造函数中使用memcpy等来覆盖类对象所在内存空间中的内容，否则一旦用到该类对象指针或引用去调用虚函数，那么一定会出问题甚至程序执行崩溃



# 第四章 数据语义学

## 4.1数据成员绑定时机

- 成员函数函数体的解析时机（在整个类定义完毕后）
- 遇到成员函数体内的变量时，会先到类中去找，如果找不到，才会到全局范围内去找
- 在变量前面加上::就可以访问全局变量
- 总结：编译器对成员函数中的属性的解析是整个类定义完毕后才开始的



- 成员函数参数类型的确定时机（最近碰到原则）
- 成员函数的参数类型是在编译器最近一次遇到mytype时决定的，从上往下看代码



## 4.2进程内存空间布局

- 当把一个可执行文件加载到内存后，就变成了一个进程，以下是进程的虚拟地址空间
- 栈（堆栈/栈区）：局部变量等放在这里
- 堆（堆区）：new、malloc等申请的内存空间从这里分配
- BSS段：未初始化的全局变量，初始化为0的全局变量等放在这里
- 数据段：已初始化的全局变量
- 代码段：存放程序执行代码的一块内存区域



## 4.3数据成员布局

- 类对象所占的内存是一块连续的内存



- 边界调整与字节对齐
- 引入1字节对齐，针对该类，要求其各个成员之间紧密排列，不允许做边界调整，不允许在成员之间留任何空隙



- 成员变量偏移值的打印



## 4.4数据成员的存取

- 静态成员变量的存取：静态成员变量的引用，可以用类名，也可以用对象名，还可以用对象指针，用类名后面加：：，用对象名后面加.，用对象指针后面加->



- 非静态成员便令的存取
- 对于成员函数，编译器会插入一个隐式的形参this，这个this就表示对象本身
- 当要访问一个成员便来给你时，编译器是把类对象的首地址加上该要访问的成员变量的偏移值
- 子类继承父类以后，偏移量要加上父类的大小



## 4.5单一继承下的数据成员布局

- 一个子类对象所包含的内容，是它自己的成员加上它父亲成员的总和
- 从偏移值看，在当前的编译器中，父亲成员是先出现的，然后才是子类成员
- 实际上，很多的padding会浪费很多的空间
- ps：编译器在不断进步和优化，不同厂商的编译器实现的细节可能很不相同，内存复制也必须谨慎



## 4.6单类单继承虚函数下的数据成员布局

单个类带虚函数的数据成员布局

- 编译时，编译器会产生类的虚函数表
- 对象中会产生虚函数表指针bptr，用以指向类的虚函数表
- 编译器会增加或拓展类的构造函数，增加给虚函数表指针vptr赋值的代码
- 如果是多重继承，如子类继承了两个父类，每个父类如果都有虚函数表，那么每个父类对象都要有一个虚函数表指针vptr，继承的时候子类就会把这两个vptr都继承过来
- 析构函数中似乎也被拓展增加了给虚函数表指针vptr赋值的代码，构造函数同理

- 虚函数指针放在最上面



单一继承父类带虚函数的数据成员布局

- 第一个是虚函数指针，父类对象是在子类对象的最上面



单一继承父类不带虚函数的数据成员布局

- 和单一继承父类带虚函数的数据成员布局一样





## 4.7多重继承数据布局与this调整深谈

单一继承数据成员布局this指针偏移知识补充

- 父类没有虚函数，子类有虚函数，那么父子类的指针是不同的，访问数据就需要调整
- 父类有虚函数，子类也有，那么父子类的指针是相同的，不用调整



ps：偏移值是相对对象指针来说的



多重继承且父类都带虚函数的数据成员布局

- 尽管偏移值相同，但是它们分属两个不同的基类子对象，经过this指针调整后，偏移值相同的两个成员变量也可以被正常访问

- 当要访问一个类对象中的成员变量时，成员变量的定位是由两个因素定位的：this指针（根据情况编译器知道是否做调整）和该成员的偏移值



## 4.8虚基类问题的提出和初探

虚基类（虚继承、虚派生）问题的提出

- 避免空间问题，效率问题，二义性问题（名字冲突）

- 注意初始化列表的写法



虚基类初探

- 虚基类表，虚基类表指针
- 虚继承子类里面都会被编译器插入一个虚基类表指针
- 与常规继承不一样，编译器把虚基类的爷爷辈grand子类对象犯到了最后，虚基类表指针放到了最前面
- 例如：Grand，A1，A2，B；A1和A2都继承自Grand，B又继承了A1和A2
- 那么B的对象模型是A1，A2，B，Grand



## 4.9两层结构时虚基类表内容分析（略）



## 4.10三层结构时虚基类表内容分析与虚基类设计原由（略）



## 4.11成员变量地址 偏移与指针等重申（略）



# 第五章 函数语义学

## 5.1普通成员函数调用方法

- cpp语言设计的要求：对普通成员函数的调用不应该比对全局函数的调用效率低
- 所以对于成员函数，编译器把其转换成了一种对全局函数的调用
- 编译器额外增加了一个叫做this的形参，是一个指针类型，指向的其实就是生成的那个对象，该形参对于确定对象所属的某个成员变量在内存中的位置有用
- 无论是成员函数还是成员变量，在处理它们的名字的时候，编译器都会向名字中混合其他的内容



## 5.2虚成员函数与静态成员函数调用方法

虚成员函数调用方法

- 在成员函数中调用虚函数有两种方式，第一种方式是直接调用，可以理解为是通过this调用虚函数，即本质上还是虚函数的调用，需要查询虚函数表；而通过类名加上：：的调用，即`Myacls::myvirfunc()`，这种写法就是直接调用，更有效率，压制住了虚拟机制，不再通过查询虚函数表来调用
- 总结：类范围操作符：：虚函数名（参数），这种明确调用虚函数的方法等价于直接调用一个普通的成员函数



静态成员函数调用方法

- 静态成员函数没有this指针
- 无法直接存取类中普通的非静态成员变量
- 静态成员函数不能在末尾增加const后缀，也不能设置为virtual
- 可以用类对象来调用，但不要求一定要用类对象来调用
- 静态成员函数等同于全局函数
- 静态成员函数有地址，并且在编译时就确定了的



## 5.3虚函数地址问题的vcall引入



## 5.4静动态类型、绑定、坑点与多态体现深谈

静态类型和动态类型

- 静态类型：对象定义时的类型，编译期间就确定好的
- 动态类型：对象目前所指的类型（运行的时候才决定类型的）
  - 一般只有指针或引用才有动态类型的说法，而且一般都是指父类的指针或引用
- ps：一个指针或引用时同时有静态类型和动态类型的，对于一个指针，静态类型就是定义的时候定义的类型，动态类型就是后面指向的类型



静态绑定和动态绑定

- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期
- 普通成员函数是静态绑定，而虚函数是动态绑定
- 缺省参数一般是静态绑定



继承的非虚函数坑

- 普通成员函数是静态绑定，所以调用哪个成员函数取决于调用者的静态类型
- 所以，如果一个父类指针指向一个子类（父类和子类都有一个同名的函数），希望通过这个父类指针调用子类的该函数，会因为静态绑定，导致调用到父类的该函数
- 结论：不应该在子类中重新定义一个继承来的非虚成员函数



虚函数的动态绑定

- 虚函数是动态绑定，所以要调用虚函数，取决于调用者的动态类型



重新定义虚函数的缺省参数坑

- 父类和子类都有一个同名的虚函数，并且都有缺省参数，然后通过父类指针调用子类的虚函数的时候，用到的却是父类的缺省参数
- 因为缺省参数是静态绑定的，所以因为父类指针，绑定到的就是父类的缺省参数
- ps：cpp主要考虑的是执行期间的效率问题
- 结论：不要在子类中重新定义虚函数缺省参数的值



C++中的多态性

- 从代码上实现
  - 当调用一个虚函数的时候，调用的路线是不是通过查询虚函数表来找到虚函数人口地址然后去执行虚函数？如果调用的是这个路线，就是多态；如果调用的不是这个路线（而是直接调用）那就不是多态
- 从表现形式上
  - 有父类子类，父类中必须含有虚函数，子类重写父类中的虚函数
  - 父类指针指向子类对象或者父类引用绑定（指向）子类对象
  - 当以父类的指针或者引用调用子类中重写了的虚函数时，就能看出来多态的表现了，因为调用的是子类的虚函数



## 5.5单继承虚函数趣味性测试和回顾

单继承下的虚函数

- 关于子类对象继承父类对象的对象模型上的区别，子类后续的虚函数都是放在父类模型的下面的（即是说是与父类同名的虚函数，位置也是放在和父类一样的位置的）



回顾和一些小试验

- 即便子类不重写任何虚函数（父类有虚函数），子类仍旧有自己的虚函数表，和父类Base的虚函数表不是一个表，但是它们的表项相同
- 即便是纯虚函数也是在虚函数表中占据一个表项的



## 5.6多继承函数深释、第二基类与虚析构必加

