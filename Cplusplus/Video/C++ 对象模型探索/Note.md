# 1-1 cpp对象模型探索课程详细介绍 



# 2-1 类对象所占用的空间

- 空类的大小为1（即空类的大小为1，里面存放的是该对象的地址）
- 成员变量是包含在每个对象中，是占用对象字节的
- 而成员函数虽然也写在类的定义中，但成员函数不占用对象字节数（不占内存空间）
- 成员函数 每个类只诞生一个，而不管你用这个类产生了多少个对象



# 2-2 对象结构的发展和演化

- 非静态的成员变量（普通成员变量）跟着对象走（存在对象内部），也就是每个类对象都有自己的成员变量
- 静态成员变量和对象没有关系，所以肯定不会保存在对象内部，是保存在对象外面（表示所占用的内存空间和类对象无关）
- 成员函数：不管静态的还是非静态的，全部都保存在类对象之外，所以不管几个成员函数，不管是不是静态的成员函数，对象的大小不会因此改变
- 虚函数：不管几个虚函数，sizeof()都是多了4/8个字节（多放了一个虚指针）
- 类里只要有一个虚函数（或者至少有一个虚函数），这个类就会产生一个指向虚函数的指针
  - 有多少个虚函数就有多少个虚函数指针
  - 类本身，指向虚函数的指针，要有地方放，所以存放在一个表格里面，这个表格就是虚函数表 virtual table vtbl
  - 这个虚函数表一般是保存在可执行的文件中，在程序执行的时候载入到内存中
  - 虚函数表是基于类的，跟着类走的
  - 为什么会多出4/8个字节，因为虚函数的存在，导致系统往类对象中添加了一个指针
  - 这个指针正好指向这个虚函数表，很多资料上把这个指针叫做vptr
  - 这个vptr的值由系统在适当的时候(比如构造函数中通过增加额外的代码来给值)
  - 虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针
- 总结：
  - 静态数据，普通成员函数和静态成员函数都不计算到对象的大小上
  - 虚函数也不计算到类对象的大小上，但是虚函数会让类对象的大小增加4个字节以容纳虚函数表指针
  - 虚函数表vtbl是基于类的（跟着类走的，和对象没有关系）
  - 虚函数表存放的是函数的指针
  - 如果有多个数据成员，那么为了提高访问速度，某些编译器可能会将数据成员之间的内存占用比例进行调整（内存字节对齐）
  - 不管什么类型的指针，大小都是一样的
- 总结类对象大小的组成
  - 非静态成员变量
  - 内存字节对齐
  - 虚函数指针
  - PS：如果类之间有多重继承的关系，并且每个父类都有虚函数



# 2-3 this指针调整

- 派生类对象 是包含基类子对象的
- 如果派生类只从一个基类继承来的话，那么这个派生类对象的地址和它的基类子对象的地址相同
- 但如果派生类对象同时继承多个基类：
  - 第一个基类子对象的开始地址和派生类对象的开始地址相同
  - 后续这些基类子对象的开始地址 和派生类对象的开始地址相差多少，那就得把前面那些基类子对象所占用的内存空间干碎
- 总结：调用哪个子类的成员函数，这个this指针就会被编译器自动调整到对象内存布局中，对应该子类对象的起始地址去



# 2-4 分析obj文件，构造函数语义

- 传统观念认为，如果我们自己没定义任何构造函数，那么编译器就会为我们隐式自动定义一个默认的构造函数
  - 我们称这种构造函数为合成的默认构造函数
- 事实上：合成默认构造函数，只有在必要的时候，编译器才会为我们合成出来，而不是必然或者必须为我们合成出来
- 第一种情况：该类没有任何构造函数，但包含一个对象类型的成员，并且该对象所属的类有一个缺省构造函数
  - 这时，编译器就会为该类生成一个 合成默认的构造函数，合成的目的是为了调用上述类的缺省构造函数
  - 换句话，编译器合成了默认的构造函数，并且在其中安插代码，调用成员对象类的缺省构造函数



# 2-5 构造函数语义续

- 第二种情况：父类带缺省构造函数，子类没有任何构造函数，那因为父类这个缺省的构造函数要被调用，所以编译器会为这个子类合成出一个默认构造函数
  - 合成的目的：为了调用父类的构造函数，换句话说，编译器为它合成了默认的构造函数，并在其中安插代码，调用其父类的缺省构造函数
- 第三种情况：如果一个类含有虚函数，但没有任何构造函数时
  - 因为虚函数的存在，编译器会为我们生成一个基于该类的虚函数表
  - 编译器为它合成了默认的构造函数，并在其中安插代码，把类的虚函数表地址赋给类对象的虚函数表指针（赋值语句/代码）：
  - 我们可以把虚函数表指针看成是我们表面上看不见的一个类的成员函数（把虚函数表的首地址赋值给虚指针）
  - 即使有默认构造函数，编译器还是会为我们额外添加代码：
    - 生成虚函数表；调用父类的构造函数；因为虚函数的存在，把类的虚函数表地址赋给对象的虚函数表指针
- 当我们有自己的默认构造函数时，编译器会根据需要扩充我们自己写的构造函数代码，比如调用父类的构造函数，给对象的虚函数表指针赋值
- 编译器干了很多事，没默认构造函数时必要情况下帮助我们合成默认构造函数，如果我们有自己的默认构造函数，编译器会根据需要扩充默认构造函数的代码
- 第四种情况：如果一个类带有虚基类，编译器也会为它合成一个默认构造函数（虚基类：通过两个直接基类继承同一个基类，所以一般是三层）
  - 虚基类结构，编译器为子类和父类都产生了“合成的默认构造函数”



# 2-6 拷贝构造函数语义

- 传统上，大家认为如果我们没有定义一个自己的拷贝构造函数，编译器会帮助我们合成一个拷贝构造函数

- 这个合成的拷贝构造函数，也是在 **必要**的时候才会被编译器合成出来

- ```cpp
  A a1;
  a1.a = 10;
  A a2 = a1;//这里没有为其合成拷贝构造函数
  //这里其实是编译器内部的一种手法，成员变量初始化手法，比如int这种简单类型，直接就按值拷贝过去，编译器不需要合成拷贝构造函数就可以实现
  //同时，这是递归实现的，即如果A里面还有一个对象A1，A1里面有int类型的话，那么也是会递归的去按值拷贝的
  //这种按值拷贝会出现在所有的拷贝构造函数里面
  ```

- 某些情况下，如果我们不写自己的拷贝构造函数，编译器就会帮助我们合成出拷贝函数来

  - 第一种情况：如果一个类A没有拷贝构造函数，但是含有一个类类型CTB的成员变量，该CTB含有拷贝构造函数，那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数
  - 第二种情况：如果一个类A没有拷贝构造函数，但是它的父类CTB有拷贝构造构造函数，那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数
  - 第三种情况：如果一个类A没有拷贝构造函数，但是该类声明了或继承了虚函数，那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数（这个语句的含义是，设定类对象的虚函数指针值，虚函数表指针，虚函数表等概念）
  - 第四种情况：如果一个类A没有拷贝构造函数，但是该类继承了虚基类，那么当代码中有涉及到类A的拷贝构造时，编译器就会为类A合成一个拷贝构造函数

- 编译器合成的拷贝构造函数往往都是干一些特殊的事情，如果只是一些类成员变量值的拷贝，是不用专门生成拷贝构造函数的，内部就会干的



# 2-7 程序转化语义

- 我们写的代码，编译器会对代码进行拆分，拆分成编译器更容易理解和实现的代码

- 站在程序员角度和站在编译器角度看代码

- ```cpp
  //1、定义时初始化对象（编译器视角）
  X x100;//步骤一：定义一个对象，为对象分配内存，从编译器的角度来看，这句是不调用X类的构造函数的
  x100.X::X(x0);//步骤二：直接调用对象的拷贝构造函数
  //等价于下列语句
  X x3(x0);
  ```
  
- ```cpp
  //2、参数初始化（程序员视角）
  void func(X tempx) {//因为这里是拷贝出来的一个临时对象，所以会调用拷贝构造函数
      return ;
  }//出来的时候会析构tempx
  X x1;
  func(x1);
  //上面是现代编译器的
  
  //老编译器的视角
  X tempoj;//编译器产生一个临时对象
  tempoj.X::X(x0);//调用拷贝构造函数
  func(tempoj);//用临时对象调用func
  void func(X& tempx) {//这里改为了引用传递了
  }
  tempoj.X::~X();//析构临时对象
  ```
  
- ```cpp
  //3、返回值初始化
  X func() {
      X x0;
      //...
      return x0;//系统产生临时对象并把x0的内容拷贝构造给了临时对象
  }
  
  //编译器的角度
  void func(X &extra) {
      X x0;//这里不会调用构造函数
      //..
      //..
      extra.X::X(x0);
      return ;
  }
  
  //返回值初始化（程序员角度）
  X my = func();
  
  //编译器的角度
  X my;//不会调用构造函数
  func(my);
  ```

- ```cpp
  func().functest();//通过函数返回的临时对象调用成员函数
  
  //切换到编译器视角
  X my;//不会调用构造函数
  (func(my), my).functest();//逗号表达式，返回值是第二个值
  ```

- ```cpp
  //程序员视角
  X(*pf)();//定义一个函数指针
  pf = func;
  pf().functest();
  
  //编译器视角
  X my;//不调用构造函数
  void (*pf)(X &);
  pf = func;
  pf(my);
  my.functest();
  ```



# 2-8 程序的优化

- 从开发者和编译器的角度对程序进行优化

- ```cpp
  X test(X& ts) {
      X tmpm;//这里生产了临时对象，消耗了两个
      tmpm.x1 = ts.x1 * 2;
      tmpm.x2 = ts.x2 * 2;
      return tmpm;
      
      //优化后
      return X(ts.x1 * 2, ts.x2 * 2);
  }
  ```

- 



# 2-9 程序优化续、拷贝构造续、深浅拷贝

- ```cpp
  class A {
      public:
          A() = default;
          A(int value): m_i(value) {//类型转换函数
              cout << "A(int)" << endl;
          }
          A(const A& other): m_i(other.m_i) {
              cout << "A(const A&)" << endl;
          }
          int m_i;
          ~A() {
              cout << "~A()" << endl;
          }
  };
  
  int main() {
      A x10(100);//没有优化的情况下，这种写法效率最高
      cout << "--------------------------------" << endl;
      A x11 = 100;
      cout << "--------------------------------" << endl;
      A x12 = A(100);
      cout << "--------------------------------" << endl;
      A x13 = (A)100;
      cout << "--------------------------------" << endl;
  }
  
  //结果：（g++ -fno-elide-constructors test.cpp -o test）关闭优化了的
  A(int)
  --------------------------------
  A(int)
  A(const A&)
  ~A()
  --------------------------------
  A(int)
  A(const A&)
  ~A()
  --------------------------------
  A(int)
  A(const A&)
  ~A()
  --------------------------------
  ~A()
  ~A()
  ~A()
  ~A()
  
  //上述代码在msvc中运行得到的都是一样的，但是在linux下的gcc下关闭优化的情况下运行，就不一样
  //从编译器视角来看（不优化）
  //第一行
  X x1;
  x1.X::X(100);
  //第二行
  X temp0;
  temp0.X::X(1000);//带一个参数的构造函数被调用
  X x2;
  x2.X::X(temp0);//拷贝函数被调用
  temp0.X::~X();//调用析构函数
  ```

- 总结：

  - 当编译器面临用一个类对象作为另一个类对象初值的情况，各个编译器表现不同，但是所有编译器都为了提高效率而努力
  - 我们也没有办法确定我们自己使用的编译器是否一定会调用拷贝构造函数

- 拷贝构造函数是否必须要有？视情况而定

  - 如果只有一些简单的类型变量，根本不需要拷贝构造函数，编译器内部本身就提供支持成员变量的bitwise copy（按位拷贝）



# 2-10 成员初始化列表说

- 何时必须用成员初始化列表

  - 如果这个成员是个引用
  - 如果是个const类型成员
  - 如果这个类是继承一个基类，并且基类中有构造函数，这个构造函数里面还有参数
  - 如果你的成员变量类型是某个类类型，而这个类的构造函数带参数时

- 使用初始化列表的优势

  - 提高程序的运行效率

  - ```cpp
    class A{
        public:
            int m_i;
            A(int value = 0):m_i(value) {
                cout << this << endl;
                cout << "A(int)构造函数调用" << endl;
            }
            A(const A&mid) {
                cout << this << endl;
                cout << "A拷贝构造函数调用" << endl;
            }
            A& operator=(const A&tmp) {
                cout << this << endl;
                cout << "A的operator=函数调用" << endl;
                return *this;
            }
            ~A() {
                cout << this << endl;
                cout << "A析构函数调用" << endl;
            }
    };
    
    class B{
        public:
            A m_a;
        
            B(int tmp) {//会调用两次int构造函数，一次operaotr=函数，两次析构函数
            /*
            因为在这一行（最开始的一行）会创建一个m_a对象，然后下面又要把tmp先转换为A类
            再调用=赋值给m_a
            相当于多调用了一遍构造析构和operator=
           	从编译器的视角来看：
           	A aobj;
           	aobj.A::A();
           	//上面是一开始就安插好了的
           	A taobj;//生成一个临时对象
           	taobj.A::A(1000);//临时对象调用构造函数
           	aobj.A::opeartor=(taobj);//调用拷贝赋值运算符
           	taobj.A::~A();//调用析构函数回收对象
            */
            
            
            // B(int tmp) : m_a(tmp){//只调用一次析构一次int构造
            /*
            而这里就直接解决了，从一开始就是调用int构造函数
            从编译器的视角来看：
            A m_a;
            m_a.A::A(1000);
            */
                m_a = tmp;
            }
    };
    
    int main() {
        B b1(1000);
        cout << &b1.m_a << endl;
    }
    ```

  - 对于类类型成员变量放到初始化列表中能够比较明显的看到效率的提升

  - 但如果是个简单类型的成员变量，比如int，其实放到初始化列表或者放在函数体里效率差别不大

  - 最好写在初始化列表中，更加专业，高端

- 初始化列表细节探究

  - 初始化列表中的代码可以看作是被编译器安插到构造函数体中，只是这些代码有些特殊
  - 这些代码 是在任何用户自己的构造函数体代码之前被执行的，所以要区分构造函数中用户代码和编译器插入的 初始化所属的代码
  - 这些列表中变量的初始化顺序是 定义顺序，而不是在初始化列表中的顺序（所以不要相互赋值）
    - 建议不在初始化列表中进行  两个 都在初始化列表中出现的成员之间的赋值



# 3-1 虚函数表指针位置分析

- 类：有虚函数，这个类就会产生一个虚函数表
- 类对象，有一个指针，指针（vptr）会指向这个虚函数表的开始地址
- 经过代码验证发现，虚函数指针位于对象内存的开头



# 3-2 继承关系作用下虚函数的手工调用



# 3-3 虚函数表分析

- 一个类只有包含虚函数才会存在虚函数表，同属于一个类的对象共享虚函数表，但是有各自的vptr，当然所指向的地址（虚函数表首地址）是相同的，即同一个类共用一个vtbl
- 父类中有虚函数就等于子类中有虚函数：父类中有虚函数表，则子类中也有虚函数表
  - 只要父类是虚函数，子类的同名函数也是虚函数（无论有没有virtual）
  - 但不管是父类还是子类，都是一个类配一个虚函数表
- 如果子类中完全没有新的虚函数，则我们可以认为子类的虚函数表和父类的虚函数表**内容相同**（内容相同的两张表）
  - 虚函数中的每一项，保存着一个虚函数的地址，但如果子类的虚函数表某项和父类的虚函数某项代表同一个函数（这表明子类没有覆盖父类的函数），则该表项所执行的该函数的地址应该相同
- 超出虚函数表的内容不可知
- 直接用子类对象给父类对象赋值，子类中属于父类那部分内容会被编译器自动区分（切割）出来并拷贝给了父类对象
  - 首先生成一个base对象
  - 其次用derive来初始化base对象
  - 编译器的一个操作是，derive的虚函数表指针并没有覆盖base对象的虚函数表指针值，编译器帮我们做到了这点



# 3-4 多重继承虚函数表分析

- 一个对象，如果它的类有多个基类则有多个虚函数表指针（注意是两个虚函数表指针，不是有两个虚函数表）
  - 在多继承中，对应各个基类的vptr按继承顺序依次放置在类的内存空间中，且子类与第一个基类共用一个vptr（第二个基类有自己的vptr）
- 画图（一个类继承了两个类以后）
  - 子类对象有两个虚函数指针
  - 子类有两个虚函数表，因为它继承了两个基类
  - 子类和第一个基类共用一个vptr（因为vptr指向一个虚函数表，所以也可以说子类和第一个基类共用一个虚函数表vtbl）
    - 所以子类后续的虚函数（如无覆盖的话）都会加到这个表中
    - 如果出现覆盖了的话，子类就会把所有的表中的同名函数全给覆盖了
  - 子类中的虚函数覆盖了父类中的同名虚函数



# 3-5 辅助工具，vptr，vtbl创建时机

- 后续要好好学习gdb和gcc的调试
- vptr创建的时机
  - vptr跟着对象走，所以对象什么时候创建出来，vptr就什么时候创建出来，即运行的时候
  - 但实际上，对于这种有虚函数的类，在编译的时候，编译器会往相关的构造函数中增加为vptr赋值的代码，这是在编译期间编译器为构造函数所增加的（这都是编译器做的事情）
  - 当程序运行的时候，遇到创建对象的代码，执行对象的构造函数，那么这个构造函数里有给对象的vptr（成员对象）赋值的语句，自然这个vptr就被赋值了
  - 总结：vptr是类对象被创建的时候就创建了，而这个创建，是编译器在编译期间插入相关代码到构造函数中的
- vtbl创建的时机
  - 实际上，虚函数表是编译器在编译期间（不是运行期间）就为每个类确定好了对应的虚函数表vtbl的内容
  - 然后也是在编译期间在相应的类构造函数中添加给vptr赋值的代码，这样程序运行的时候，当运行到类对象的代码的时候，会调用类的构造函数
  - 总结：编译期间就确定了每个类的vtbl
- ![虚函数在存储器中的位置](虚函数在存储器中的位置.PNG)



# 3-6 单纯的类不纯时引发的虚函数调用问题

- 



# 4-1 数据成员绑定时机

- 编译器对成员函数中的数据的解析，是整个类定义完毕后才开始的
  - 所以对类的函数里面的属性的解析和绑定，是在整个类定义后发生的
  - 即使是在类内定义，类外实现的函数，对于其中变量的解析还是会先在类内寻找，然后再到类外寻找
  - 提示：使用::符可以访问到全局变量

- 对于成员函数参数（在类内定义或实现）：是在编译器第一次遇到整个类型的时候被决定的
  - 所以特别是对于typedef，如果最近遇到的typedef是全局的，那函数的成员函数参数就会被定义为全局的那个类型
  - 所以，一个类中所有的typedef就要全部放在类的最前面
  - 特别的：在类内定义，类外实现的函数，对于成员函数参数的解析，是先到类内判断，再到类外判断的（有点违背了）
  - 结论：为了在类中尽早的看到类型mytype，所以这种类型定义语句typedef一定要挪到类的最开头定义；那后边的成员函数第一次遇到这个类型的时候，它就本着最近碰到原则来应用最近碰到的类型



# 4-2 进程内存空间布局

- 不同的数据在内存中会有不同的保存时机和保存位置
- 当运行一个可执行文件时，操作系统就会把这个可执行文件加载到内存中，此时进程有一个虚拟的地址空间（内存空间）
- linux有一个nm命令，能够列出可执行文件中的全局变量存放的地址
- 从高地址往下到低地址
  - 堆栈段（栈，一般函数里面的临时变量都是放到这里的）
  - 空洞（未映射区域）
  - 堆（堆，申请才被使用的）
  - BSS段（存放未被定义了的全局数据和静态数据）
  - 数据段（存放定义了的全局数据和静态数据）
  - 代码段（存放代码）
- ![内存布局](内存布局.PNG)



# 4-3 数据成员布局

- 观察成员变量地址规律

  - 普通成员变量的存储顺序，是按照在类中的定义顺序从上到下来的
  - 后面出现的成员变量在内存中有更高的地址
  - 类定义中public，private，protected的数量，不影响类对象的sizeof

- 边界调整，字节对齐（padding）

  - 某些因素会导致成员变量之间排列不连续，就是边界调整（字节对齐），调整的目的是提高效率（是编译器自动调整）

    - 调整的定义：往成员之间填补一些字节，使用类对象的sizeof字节数凑成一个4的整数倍或8的整数倍

    - 为了统一字节对齐问题，引入一个该概念叫一字节对齐（不对齐）

    - ```cpp
      #pragma pack(1);//对齐方式设置为1字节对齐（不对齐）
      
      #pragma pack();//取消指定对齐，恢复缺省对齐；
      ```

    - ps：有虚函数时，编译器会往类定义中增加vptr（这个要视为内部数据成员）

- 成员变量偏移值的打印

  - 成员变量偏移值，是这个成员变量的地址，离对象首地址偏移多少

  - ```cpp
    printf("%d", &A::m_i);//输出十进制的偏移值
    //记录一种偏门的写法
    #define GET(A, m) (int)(&((A*)0) -> m)//其中A为类名，m为属性名
    ```

  - ```cpp
    int A::*mypointer = &A::m_i;//定义成员变量指针
    
    printf("%p", mypointer);//输出的是变量的偏移值
    ```



# 4-4 数据成员布局

- 静态成员变量的存取

  - 静态成员变量，可以当做一个全局变量，但是它只在类的空间内可见
  - 可以通过类名，对象或对象指针来访问成员属性（查看反汇编后发现这几个都是一模一样的）
  - 静态成员变量只有一个实体，保存在可执行文件的数据段
    - 编译后，运行多次的情况下，静态成员的地址都是不变的
    - 即静态成员变量的地址是在编译为可执行文件后，就已经确定好了的（地址都写在了可执行文件上了）

- 非静态成员变量的存取（普通的成员变量）

  - 通过类对象或指针来存取

  - ```cpp
    class A{
        public:
        	int a;
        	void func() {
                a += 2;
            }
    };
    
    A a1;
    a1.a = 1;
    a1.func();//其实这里调用func函数的时候，编译器会隐含的传入一个this指针
    //编译器的视角
    void A::func(A* const this) {
        this -> a += 2;
    }
    
    a1.a;
    apointer->a;//这两个访问的效率上在单一继承中是无差别的，但是在虚基类中是有差别的（汇编中都是一样的）
    ```

  - 对于普通成员的访问，编译器是把类对象的首地址加上成员变量的偏移值（所以可以O(1)的访问任意对象）

    - 注意：这个偏移值已经写到了汇编代码里面了的

- 虚基类是个例外哦



# 4-5 单一继承下的数据成员布局

- 一个子类对象，所包含的内容，是他自己的成员，加上他父类的成员的总和

- 从偏移值上看，父类成员先出现，然后才是子类成员

- ```cpp
  class BB {//sizeof(BB) = 8
      int m_i1;
      char m_c1;
      char m_c2;
      char m_c3;
  };
  
  class Base {//8(msvc,g++,clang)
      public:
      	int m_i1;
      	char m_c1;
  };
  
  class Base1: public Base {//12(msvc,g++,clang)
    public:
      	char m_c2;
  };
  
  class Base2: public Base2 {//sizeof(Base2) = 16(msvc)/12(g++,clang)
      public:
      	char m_c3;
  }
  ```

  - 引入继承关系后，可能会带来内存空间的额外增加
  - ![windows上的内存布局](windows上的内存布局.PNG)
  - ![linux上的内存布局](linux上的内存布局.PNG)
  - linux和windows上数据布局不一样，说明：
    - 编译器在不断地进步和优化
    - 不同厂商编译器，实现细节也不一样
    - 内存拷贝就要谨慎（因为不同对象地内存布局是不一样的，比如base2在linux下就不能往base3下拷贝，因为这会覆盖掉原来base3的m_c3的位置的值）



# 4-6 单类单继承虚函数下的数据成员布局

- 单个类带虚函数的数据成员布局（类中引入虚函数时，会有额外的成本付出）

  - 编译的时候，编译器会产生虚函数表
  - 对象中会产生虚函数指针vptr，用以指向虚函数表
  - 增加或者拓展构造函数，增加给虚函数表指针vptr赋值的代码，让vptr指向虚函数表
  - 如果出现多重继承，比如继承了两个父类，每个父类都有虚函数的话，每个父类都会有vptr，那继承时，子类就会把这两个vptr给继承过来（如果子类还有自己额外的虚函数的话，子类与第一个基类共用一个vptr）
  - 析构函数中也被拓展增加了虚函数表指针vptr相关的代码
  - ![单个类带虚函数的数据成员布局](单个类带虚函数的数据成员布局.PNG)

- 单一继承父类带虚函数的数据成员布局

  - ![单一继承父类带虚函数的数据成员布局](单一继承父类带虚函数的数据成员布局.PNG)
  - 基类带虚函数，派生类继承基类，派生类有虚函数

- 单一继承父类不带虚函数的数据成员布局

  - ```cpp
    class A {
        public:
            int a;
    };
    
    class B: public A {
        public:
            virtual ~B() {}
            int b;
            int c;
    };
    
    int main() {
        printf("%d\n", &B::a);//0
        printf("%d\n", &B::b);//12
        printf("%d\n", &B::c);//16
    }
    ```

  - 这里如果只是看偏移值的话，会觉得虚函数指针是在父类对象下面的，但是实际上从内存中来看的话，虚函数指针还是在对象的第一个位置的

  - ![单一继承父类不带虚函数的数据成员布局](单一继承父类不带虚函数的数据成员布局.PNG)

  - ps：右边才是正确的