class Solution {
public:
    int matrixScore(vector<vector<int>>& A) {
        /**
        具体的思路：
        一开始没有想到使用贪心来解决的（做题后才发现其实贪心是一种策略，它是用来引导你去怎么思考这道题目，但是实际上实现的时候还是得以来其他的技巧，如模拟转化，数据结构等）

        要明白一点即可，要想最大，最好的一个方法就是把第一列的元素全部变为1，这样做是能够保证最大的一个前提
        其次，就是对于每一列，我们要保证尽可能的有足够多的1在里面
        以上就是这道题目的思路

        而到了具体实现的这一块
        即先假设第一列所有的元素都是1，把它加到初值上面
        然后对后续的每一列进行分析，分析它的0/1的个数，谁大就加谁（在思路上就是要保证这一列有尽可能多的1在里面）
        不过这里统计01数目的时候要注意一点，就是前面不是假设说第一列所有元素都是1吗，那么如果不是1的那一行会被翻转
        所以统计前要判断一下，方便后续统计的正确
        **/

        int n = A.size(), m = A[0].size();
        int res = n * (1 << (m - 1));//假设全部都是1

        for (int i = 1; i < m; i ++ ){
            int count_1 = 0, count_0 = 0;

            for (int j = 0; j < n; j ++ ){
                if (A[j][0]){
                    A[j][i] ?  count_1 ++ : count_0 ++ ;//原来就是1，就不要翻转
                }else{
                    A[j][i] ?  count_0 ++ : count_1 ++ ;//原来不是1，就要翻转
                }
            }
            
            res += max(count_0, count_1) * (1 << (m - i - 1));//最后把01数量最大的那一个乘起来
        }

        return res;
    }
};