class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        /*
        这道题看第一眼感觉挺简单的，就是找到每个窗口的最大值嘛，可仔细模拟一下，好像很麻烦
        因为每一次窗口的移动，都要去遍历一遍维护当前的最大值，其实这样是非常的耗费时间的（时间复杂度为O（n*k））
        所以在想是否有较快的方法去模拟这个过程

        而在题解中看到了一个非常巧妙的方法，分享一下：
        对于一个长度为k的区间（左端点left，右端点right），我们可以发现，那些能够被k整除的数（统称为k1）和区间的关系无非就两种
        第一种，k1刚好位于区间的端点上
        那么此时，就可以想一下，如果我能维护k1到k0，k1到k2之间的最大值，答案不久出来了吗？
        第二种，k1位于这个区间之间，
        那就可以把这个区间分为两个部分，左边是left到这个数，右边是这个数到right
        那我找到左半区的最大值，再和右半区的最大值进行比较，就可以得出结果

        重点来了，如何找到这两种方法的一个共性？
        然后发现，其实都是维护最大值，不过是区间不一样罢了
        然后发现需要查找左半区和右半区的最大值，就得知应该维护两个区间方向的最大值

        所以，对于左半区，我们需要维护的是left到k1区间的最大值
        既然是维护一个向右方向的最大值，所以要从后往前遍历，每一次都比较自己后面的一个数（而最后一个数后面没有数，所以这里变为他自己）
        （同时注意，应该是i+1对k进行比较，因为坐标是从0开始的，到k-1的时候刚好是一个长度为k的序列，所以用i+1来表示其真实的长度）

        对于右半区，我们维护的是k1到right区间的最大值
        维护的是一个向左方向的最大值，所以要从前往后遍历，每一次比较自己前面的一个数

        最后，我们只要比较得到左半区和右半区的最大值即可
        （循环遍历：从0到n-k-1开始遍历，即逐步推动left向右移动；即对i的右半区求解，i + k - 1的左半区求解）

        思考：
        这道题感觉最重要的一点就是，它找到了k作为它的一个分界线，从而使得题目有了解题方向
        你看，因为有了k，所以维护区间最大值变为了找左半区和右半区的最大值，从而有解
        所以，对于区间型的题目，除了传统的双指针，数据结构以外，分解问题，然后用数组维护状态也是一种不错的方法
        （其实状态的维护至关重要，因为往深了说就是数据结构或dp了）

        debug:不要看到过了几个样例就觉得程序没什么问题，或者说程序问题不大
        我觉得，要以严谨的态度去对待，即出现了问题，就要全面排查逻辑和代码上的错误
        */

        int n = nums.size();
        vector<int> res;
        vector<int> max1(n), max2(n);
        if (n == 0){
            return res;
        }

        for (int i = 0; i < n; i ++ ){
            if (i % k == 0){
                max1[i] = nums[i];
            }else{
                max1[i] = max(max1[i - 1], nums[i]);
            }
        }

        for (int i = n - 1; i >= 0; i -- ){
            if (i == n - 1 || (i + 1) % k == 0){
                max2[i] = nums[i];
            }else{
                max2[i] = max(max2[i + 1], nums[i]);
            }
        }

        for (int i = 0; i <= n - k; i ++ ){
            res.push_back(max(max2[i], max1[i + k - 1]));
        }

        return res;
    }
};