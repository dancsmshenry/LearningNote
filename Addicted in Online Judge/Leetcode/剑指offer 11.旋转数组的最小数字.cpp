class Solution {
public:
    int minArray(vector<int>& numbers) {
        /*
        本题的思路：
        看到数组类型的题目，想到的就是双指针和二分查找
        很明显，对于旋转后的数组有两种情况，一种是前面的较大的那一部分数组长度大于数组长度的一半
        另一种情况是前面的较大的那一部分数组长度小于数组长度的一半
        那这个时候就要找规律了
        你看，如果中间的那个数大于左边（或者中间的那个数大于右边），那最小的数就在右边，对于第一种情况
        否则，中间的数小于左边（或者中间的那个数小于右边），那最小的数就在左边，对应第二种情况

        那现在有两种情况都可以用，是不是都可行呢？
        那，其实比较左边数的方法是不可行的
        因为如果到某一个时候，分隔到的小数组是没有被旋转的
        那我中间的数大于左边的数，然后就直接往右边寻找了
        很显然是错误的
        所以只能是对右边的数进行比较

        debug：这道题比较坑的地方是，他会出现元素相等的情况
        想到了早上在评论区看到的一个解答：
        如果遇到当前的mid值和边界值相等，怎么办？就把边界值向中间靠拢一个单位
        我的理解：既然当前的mid对应的值和边界值相等，那我就把边界靠拢向中间，然后再来一次二分
        相等就继续二分，直到不相等，这样就在缩小范围的同时，也能有效避免因为相同元素导致递归结果错误
        因为如果二者相等的话，其实我们是不知道到底因该想做还是向右的（即第一种情况或者第二种情况都会发生）

        就相当于二分的魔改了
        */
        int left = 0, right = numbers.size() - 1;

        while (left < right){
            int mid = (left + right) >> 1;
            if (numbers[mid] > numbers[right]){
                left = mid + 1;
            }else if (numbers[mid] == numbers[right]){
                right -- ;
            }else{
                right = mid;
            }
        }

        return numbers[left];
    }
};