### TCP三次握手

- ![](F:/Code/LearningNote/Computer Network/Note/TCP/image/TCP三次握手.png)
- 一开始客户端和服务端都是close状态，然后服务端监听某个端口，进入LISTEN状态



第一次握手

- ![](F:/Code/LearningNote/Computer Network/Note/TCP/image/第一次握手.png)
- 客户端->服务端
- 客户端随机初始化序列号，并将SYN标志位置为1
- 不包含应用层数据
- 此后客户端处于SYN-SENT状态



第二次握手

- ![](F:/Code/LearningNote/Computer Network/Note/TCP/image/第二次握手.png)
- 服务端->客户端
- 服务端随机初始化报文的序列号
- 将收到的来自客户端的序列号+1，作为自己的确认应答号
- 并把SYN和ACK都设为1
- 不包含应用层数据
- 此后服务端处于SYN-RCVD状态



第三次握手

- ![](F:/Code/LearningNote/Computer Network/Note/TCP/image/第三次握手.png)
- 客户端->服务端
- 将ACK设为1
- 将收到的来自服务端的序列号+1，作为自己的确认应答号
- 可以携带应用层数据（！！）
- 发送后，客户端处于ESTABLISHED状态；同时，服务端收到报文后，也会处于ESTABLISHED状态



### TCP三次握手的原因

- 1、避免历史连接
  - 三次握⼿的⾸要原因是**为了防⽌旧的重复连接初始化造成混乱**
  - 试想一下场景：
    - 如果第一次报文超时，就会发送第二次报文，但是第一次报文却又先到达服务端，此时服务端发送第二次报文
    - 此时如果是两次握手的话，客户端收到报文后就直接确立连接了
    - 这就不是我们想要的（因为这是历史连接，是过期或超时了的）
    - 但，如果是三次握手才确立连接的话，那么客户端通过上下文发现这是历史或超时了的连接，就直接发送RST报文中止这次连接
  - 所以，最主要原因，就是防止历史连接初始化了连接



- 2、同步双方初始序列号
- PS：序列号的作用
  - 接收方可以去除重复的数据
  - 接收方可以根据数据包的序列号按序接受
  - 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的
- 所以，对于发送和接受的双方，都要确保自己发送的数据都能被对方接受
- 所以，当客户端发送携带「初始序列号」的 SYN 报⽂的时 候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收；
- 那当服务端发送「初始序 列号」给客户端的时候，依然也要得到客户端的应答回应
- 这样一来一回，就是四次握手，而其中的两次可以合并，所以就是三次握手了
- ![](F:/Code/LearningNote/Computer Network/Note/TCP/image/四次握手-》三次握手.png)
- 所以，我可以提炼为，三次握手是为了确保双方的发送和接受能力都没有问题



- 3、避免资源的浪费
  - 试想一个场景：如果只有两次握手的话，那么会发生什么？第二次握手就要确定连接了
  - 但是，如果客户端发送的SYN请求在网络中阻塞，就会重新发送，而这些阻塞的请求后续服务端逐渐收到，服务端就会因此创建很多连接（但是这些连接都是冗余无效的），因此造成了资源不必要的浪费



小结

- 通过三次握⼿**能防止历史连接的建立**，**能减少双方不必要的资源开销**，**能帮助双方同步初始化序列号**









### TCP四次挥手

- ![](F:/Code/LearningNote/Computer Network/Note/TCP/image/TCP四次挥手.png)



四次挥手

- 1、客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，之后客户端进⼊ FIN_WAIT_1 状态
  - 客户端打算不发送信息，关闭连接了，但是要先通知服务端，因为可能服务端后续需要发送一些信息，此时客户端是可以接受信息的
- 2、服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态；客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态
  - 服务端知道了客户端要关闭连接了，所以发送ack报文
- 3、等待服务端处理完数据后，服务端向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态
  - 服务端把信息都发送处理好了之后，就告诉客户端可以彻底关闭了
- 4、客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态；服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭；客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭
  - 客户端知晓后，就关闭，并通知服务端
- PS：
  - 每个方向都有一个ACK和FIN，所以是四次挥手
  - 主动关闭连接的才会有TIME_WAIT状态



### TCP四次挥手的原因

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据
- 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂（因为服务端可能还有数据需要处理和发送）
- 等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接
- https://www.zhihu.com/question/50646354/answer/122035678



### TIME_WAIT等待时间是2MSL的原因

- MSL：报文最大生存时间，是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃
- TTL：在IP头中，是 IP 数据报可以经过的最⼤路由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报⽂通知源主机（单位：经过路由跳数）
- MSL要大于等于TTL消耗为0的时间
- 原因：
  - ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包 被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间
  - 可能被动关闭方没有收到断开连接的ack报文，就会触发超时重传报文，被动关闭方重新发送FIN以后，主动关闭方收到，一来一回正好是2个MSL
- 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的



### 为什么需要TIME_WAIT状态

- 1、防止旧连接的数据包
  - ![](F:/Code/LearningNote/Computer Network/Note/TCP/image/为什么需要TIME_WAIT状态(1).png)
  - 如果没有TIME_WAIT或TIME_WAIT太短了的话，例如：之前发送的报文出现了网络延迟，直到下一次三次握手以后才接收到，就会产生数据错乱的问题（如上图）
  - 所以才有TIME_WAIT状态，⾜以让两个⽅向上的数据包都被丢弃，使得原来 连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的
- 2、保证连接正确关闭
  - ![](F:/Code/LearningNote/Computer Network/Note/TCP/image/为什么需要TIME_WAIT状态(2).png)
  - 如果没有TIME_WAIT或TIME_WAIT太短了的话，例如：最后一次ACK报文延迟或丢失了，那么服务端就会一直储在LAST_ACK的状态，那么后续再来一次三次握手的话。服务端就会中断连接的

- 足够长的话就刚好
  - 服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接
  - 服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会发 FIN 关闭连接报文并等待新的 ACK 报文



### TIME_WAIT过多的危害

- 第一是内存资源占用
- 第二是对端口资源的占用，一个TCP连接至少消耗一个本地端口（占满了所有端⼝资源，则会导致⽆法创建新连接）