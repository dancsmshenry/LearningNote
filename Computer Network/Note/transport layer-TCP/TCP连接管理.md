# 三次握手

- ![](../image/TCP三次握手.png)
- 一开始客户端和服务端都是close状态，然后服务端监听某个端口，进入LISTEN状态



## 第一次握手

- ![](../image/第一次握手.png)
- 主动开启者（通常称为客户端）发送一个SYN报文段，并指明自己想要连接的端口号和它的客户端初始序列号
- 客户端随机初始化序列号，并将SYN标志位置为1
- 不包含应用层数据
- 客户端发送第一次握手后处于SYN_SENT状态，而服务端接收第一次握手后处于SYN_RCVD状态



## 第二次握手

- ![](../image/第二次握手.png)
- 服务端也发送自己的SYN报文段作为响应，并包含了它自己的初始序列号
- 为了确认客户端的SYN，服务器将其收到的初始序列号加一作为ACK（确认应答号）的返回值
- 如果出现丢包的现象，就会重传
- 服务端随机初始化报文的序列号（记作ISN(s)）
- 并把SYN和ACK都设为1
- 不包含应用层数据
- 发送第二次握手时服务端处于SYN-RCVD状态，接收第二次握手时客户端处于established状态
- 在第二次握手的时候，如果收到了主动打开方发来的重置信息而非ACK，那么就会返回到LISTEN状态，并且等待另一个连接请求的到来



## 第三次握手

- ![](../image/第三次握手.png)
- 客户端->服务端
- 为了确认服务器的SYN，客户端将收到的初始序列号加一作为返回的ACK数值
- 将ACK设为1
- 将收到的来自服务端的序列号+1，作为自己的确认应答号
- 可以携带应用层数据
- 发送后，客户端处于ESTABLISHED状态；同时，服务端收到报文后，也会处于ESTABLISHED状态



## 同时三次握手

- <img src="../image/同时三次握手.png" style="zoom:200%;" />
- 需要交换4次报文段（由于通信双方都扮演了客户端和服务端的角色）



## 为什么要三次握手

避免历史连接
- 三次握⼿的首要原因是**为了防止旧的重复连接初始化造成混乱**
- 试想一下场景：
  - 如果第一次报文超时，就会发送第二次报文，但是第一次报文却又先到达服务端，此时服务端发送第二次报文
  - 此时如果是两次握手的话，客户端收到报文后就直接确立连接了
  - 这就不是我们想要的（因为这是历史连接，是过期或超时了的）
  - 但，如果是三次握手才确立连接的话，那么客户端通过上下文发现这是历史或超时了的连接，就直接发送RST报文中止这次连接
- 所以最主要原因，就是防止历史连接初始化了连接



同步双方初始序列号

- 序列号的作用
  - 接收方可以去除重复的数据
  - 接收方可以根据数据包的序列号按序接受
  - 可以标识发送出去的数据包中，哪些是已经被对⽅收到的
- 对于发送和接受的双方，都要确保自己发送的数据都能被对方接受
- 所以，当客户端发送携带「初始序列号」的SYN报⽂的时候，需要服务端回⼀个ACK应答报⽂，表示客户端的SYN报⽂已被服务端成功接收
- 那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应
- 这样一来一回，就是四次握手，而其中的两次可以合并，所以就是三次握手了
- ![](../image/四次握手-》三次握手.png)
- 所以可以提炼为，三次握手是为了确保双方的发送和接受能力都没有问题



避免资源的浪费
- 试想一个场景：如果只有两次握手的话，那么会发生什么？第二次握手就要确定连接了
- 但是，如果客户端发送的SYN请求在网络中阻塞，就会重新发送，而这些阻塞的请求后续服务端逐渐收到，服务端就会因此创建很多连接（但是这些连接都是冗余无效的），因此造成了资源不必要的浪费



小结

- 通过三次握⼿**能防止历史连接的建立**，**能减少双方不必要的资源开销**，**能帮助双方同步初始化序列号**



## 为什么第一二次握手不能携带数据，而第三次可以

- 第一次握手如果可以携带数据的话：若有人攻击服务器，就会从第一次握手的SYN报文中投放大量数据，会使服务器花费很多时间和内存空间来接收这些报文，**会使服务器更容易受到攻击**，所以第一次握手不能携带数据
- 第二次握手不能携带数据是因为握手还没有完成，没建立链接，不能发送数据
- 而对于第三次的话，此时客户端已经处于**established**状态，并且也已经知道服务器的接收、发送能力是正常的了**，所以携带数据是可以的**
  - 能够发出第三次握手报文的主机，肯定接收到第二次(服务器)握手报文
  - 因为伪造IP的主机是不会接收到第二次报文的
  - 所以，能够发出第三次握手报文的，应该是合法的用户



## 连接建立超时

- 如果要建立连接的服务器关闭了，TCP会为了建立连接频繁的发送SYN报文段，第一次间隔2s，第二次间隔4秒，第三次间隔8s，称为指数回退
- 一些系统可以配置发送SYN的次数，但是通常选择一个相对较小的数值5
- 在linux中，系统配置变量net.ipv4.tcp_syn_retries表示了在一次主动申请中尝试重新发送SYN报文段的最大次数







# 四次挥手

- 四次挥手：每个方向都有一个ACK和FIN
- 主动关闭连接的才会有TIME_WAIT状态
- TCP协议规定，通信的任何一方在完成数据发送任务后都能够发送一个FIN
- **四次挥手的fin都要占用序列号**，但是其中不会有数据

- ![](../image/四次挥手_01.png)
- <img src="../image/四次挥手_02.png" style="zoom:200%;" />



## 第一次挥手

- 客户端打算关闭连接，此时会发送⼀个TCP⾸部FIN标志位被置为1的报⽂，之后客户端进⼊FIN_WAIT_1状态
  - 客户端打算不发送信息并关闭连接，但是要先通知服务端
  - 因为可能服务端后续需要发送一些信息，此时客户端是可以接受信息的
- 当前报文还可以包含一个ACK段，用于确认对方最近一次发送来的数据



## 第二次挥手

- 服务端收到该报⽂后，就向客户端发送ACK应答报⽂（服务端知道了客户端要关闭连接了，所以发送ack报文）
  - 服务端进⼊CLOSED_WAIT状态
  - 客户端收到服务端的ACK应答报⽂后，之后进⼊FIN_WAIT_2状态

- 连接的被动关闭者将ACK的数值加1作为响应的ACK值，以表明它已经成功接收到主动关闭者发送的FIN
- 此时上层的应用程序会被告知连接的另一端已经提出了关闭的请求（此时被动关闭的一方是可以向主动关闭的一方发送数据的）
- 通常，这会导致应用程序发起自己的关闭操作，接着，被动关闭者将身份转变为主动关闭者，并发送自己的FIN，该报文段的序列号为L（这里就属于第三次挥手的内容了）



## 第三次挥手

- 等待服务端处理完数据后，服务端向客户端发送FIN报⽂，之后服务端进⼊LAST_ACK状态
  - 服务端把信息都发送处理好了之后，就告诉客户端可以彻底关闭了



## 第四次挥手

- 客户端收到服务端的FIN报⽂后，回⼀个ACK应答报⽂，之后进⼊TIME_WAIT状态
- 服务器收到了ACK应答报⽂后，就进⼊了CLOSED状态，⾄此服务端已经完成连接的关闭
- 客户端在经过2MSL⼀段时间后，⾃动进⼊CLOSED状态，⾄此客户端也完成连接的关闭
  - 客户端知晓后，就关闭，并通知服务端
- 为了连接的关闭，最后发送的报文还包含一个ACK用于确认上一个FIN
- 如果FIN丢失，那么发送方将重新传输直到接收到一个ACK确认为止



## 同时四次挥手

- <img src="../image/同时四次挥手.png" style="zoom:200%;" />



## 半关闭状态

- ![](../image/半关闭.png)
- 指仅关闭数据流的一个传输方向
  - 两个半关闭操作合在一起就能关闭整个连接

- “我已经完成了数据的发送工作，并发送一个FIN给对方，但是我仍然希望接收来自对方的数据，直到它发送一个FIN给我”
- 调用shutdown代替close即可



## 为什么要四次挥手，可以三次挥手吗

- 关闭连接时，客户端向服务端发送FIN时，表示客户端不再发送数据了但是还能接收数据
- 服务器收到客户端的FIN报⽂时，先回⼀个ACK应答报⽂（因为服务端可能还有数据需要处理和发送；即使没有数据要处理，也要告诉一声给客户端）
  - 此时仅代表客户端就不会再发送数据，client -> server这一个方向断开
  - 而如果服务端还有数据要发送，于是就继续发送，即server -> client这个方向没有断

- 等服务端不再发送数据时，才发送FIN报⽂给客户端来表示同意现在关闭连接
  - 发送给客户端FIN后，就代表需要server -> client这个方向断开了

- 最后，收到客户端发来的ACK之后，就可以真正断开了



- 其实在实际的网络环境下是**可以三次挥手**的：一些抓包的情况下，可以看到，服务端的ACK和FIN合并发送
  - 即**延迟确认**，就是Server对Client的FIN报文的确认延迟到和Server的FIN一起发
  - ![](../image/三次挥手.svg)
  - 参考：http://intronetworks.cs.luc.edu/current1/uhtml/tcp.html



## 为什么需要TIME_WAIT

《unix网络编程》给出的答案

- 优雅的关闭 TCP 连接，也就是尽量保证被动关闭的一端收到它自己发出去的 FIN 报文的 ACK 确认报文（为了在一般的情况下保证报文的收到，所以才设置2MSL）
- 处理延迟的重复报文，这主要是为了避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接



我的一个思路：

- 试想一个很极端的场景：

- 如果没有TIME_WAIT，客户端在收到FIN发送ACK之后立马关闭并开始新的连接
- 如果ACK的发送出现了丢包的情况，会直接造成服务端重发FIN；此时服务端发送的FIN会被客户端新的连接给收到，直接结果就是客户端的现有连接断开
- 因此，客户端需要当需要在发送之后等待一会，目的就是接收服务端重发的FIN



保证连接正确关闭（小林八股给出的解释，和我的看法基本一致）

- ![](../image/为什么需要TIME_WAIT状态(2).png)
- 如果没有TIME_WAIT或TIME_WAIT太短了的话，例如：最后一次ACK报文延迟或丢失了，那么服务端就会一直处在LAST_ACK的状态
- 造成的两个结果：服务端的端口和内存资源的浪费；客户端有可能收到服务端的FIN报文，造成现有连接的终止



防止旧连接的数据包（小林八股给出的解释，我觉得不是很合理...）

- ![](../image/为什么需要TIME_WAIT状态(1).png)



- 就小林认为TIME_WAIT是为了防止数据错乱才有的
- 我对此的认为：其实，那些被网络延迟的数据，首先是很罕见（毕竟你说绕那么一大圈才收到，着实汉奸），其次，如果这个数据包真的被延迟了，其实你的TIME_WAIT无论设置多久都不管用，因为它总会有在TIME_WAIT之后才返回的数据包
- 我的结论：这个论据有点说不通的....



## 为什么TIME_WAIT是2MSL

**背景**

- MSL：报文最大生存时间，代表任何报文段在被丢弃前在网络中被允许存在的最长时间
  - 要大于等于TTL消耗为0的时间
  - 影响这个时间的两个因素：IP数据报拥有TTL字段和跳数限制字段
- TTL：在IP头中，是IP数据报可以经过的最大路由数，每经过⼀个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报⽂通知源主机（单位：经过路由跳数）
- 2MSL的时间是从客户端接收到FIN并发送ACK后开始计时的



- 书接上文，既然要等待，那要等待多久呢？
- 另一个很极端的场景：如果服务端发送的FIN遇到了网络拥塞（很有可能会绕地球n圈），那么我们的客户端要一直等下去吗？
- 所以TIME_WAIT需要一个范围限制，所以一般选取比较常见的一种情况进行分析：



- 场景：B是发送FIN报文的，A是接收FIN报文的；A发出ACK后（第四次挥手），等待一段时间T，确保如果B重传FIN自己一定能收到
- 分析：
  - ACK从A到B最多经过1MSL，超过这个时间B会重发FIN
  - B重发的FIN最多经过1MSL到达A
- 结论：如果B重发了FIN，且网络没有故障(重发的FIN被丢弃或错误转发)，那么A一定能在2MSL之内收到该FIN，因此A只需要等待2MSL
  - 所以在出现重传的情况下，对于A来说，发送ACK和收到重复的FIN的时间间隔就是2MSL
- 问题：如果在A关闭连接后才接收到重传FIN（比如说网络非常的拥塞），此时A应该不会回复ACK吧？那么B不是会无法正常关闭吗？
  - A关闭了以后，不会回复任何报文了
  - B的确无法正常关闭
  - B会在重试一段时间后关闭连接，且重试的间隔会越来越长



- 参考：
- https://www.zhihu.com/question/67013338
- https://cloud.tencent.com/developer/article/1450264



## TIME_WAIT过多的危害

- **内存资源占用**，socket本质上是文件（过多的占用内存）
- **端口资源的占用**，一个TCP连接至少消耗一个本地端口（占满了所有端口资源，则会导致⽆法创建新连接）
