# 八股

## tcp的最大连接数是多少

- 最大连接数 = 客户端IP数 * 客户端的端口数，即2的48次方
- 但是连接数受到两方面的限制：
  - 一方面是文件描述符的限制，socket 都是⽂件，而每个进程能够打开的文件数量有限
  - 另一方面是内存限制，每个 TCP 连接都要占用一定内存，而操作系统的内存是有限的



## 如何确定一个唯一的TCP连接

- 四元组（源地址，源端口，目的地址，目的端口）



## TCP的三大特点

- 是**面向连接，可靠的，基于字节流**的传输层通信结构

  - 面向连接：一定是一对一连接

  - 可靠的：⽆论的网络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报文⼀定能够到达接收端

  - 字节流：：**消息是没有边界的**，所以⽆论我们消息有多⼤都可以进⾏传输，并且消息是有序的



## TCP和UDP的对比

- 连接
  - TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接
  - UDP 是不需要连接，即刻传输数据
- 服务对象
  - TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点
  - UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信
- 可靠性
  - TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不᯿复、按需到达
  - UDP 是尽最⼤努力交付，不保证可靠交付数据
- 拥塞控制、流量控制
  - TCP 有拥塞控制和流量控制机制，保证数据传输的安全性
  - UDP 则没有，即使网络⾮常拥堵了，也不会影响 UDP 的发送速率
- ⾸部开销
  - TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」 字段则会变⻓的。 
  - UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩
- 传输⽅式
  - TCP 是流式传输，没有边界，但保证顺序和可靠
  - UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序
- 分片不同 
  - TCP 的数据大小如果⼤于 MSS 大小，则会在**传输层**进⾏分片，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分片，只需要传输丢失的这个分片
  - UDP 的数据大小如果⼤于 MTU 大小，则会在 **IP 层**进⾏分片，⽬标主机收到后，在 IP 层组装完数据，接着 再传给传输层，但是如果中途丢了⼀个分片，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样 传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU



## 为什么IP层分片数据后，TCP协议还要分片数据

- MTU和MSS的关系

- ![](..\image\MTU和MSS.png)
- 如果TCP不分片数据的话，那么如果一个IP分片丢失，整个IP报文的所有分片都得重传（因为IP层没有超时重传等recovery的操作）
- 所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进⾏分片，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不⽤ IP 分片了
- 其实就是整个数据不分片的话，当数据发生丢失的时候，要恢复起来粒度就太大了（recovery是在传输层实现的；可能只是小部分数据丢失，但传输层认为整个package丢失，所以重传整个package），而如果以更小的粒度进行数据传输的话，已经接收的部分可以返回ack，那么就可以把哪些没有接收到ack的部分给重传



## 如何理解TCP是面向字节流（引申至粘包）

从发送者的角度理解：

- 应用层的应用程序在发送数据时，是调用send函数将应用层数据递交给传输层的tcp协议
- 从应用层的角度来说，数据就认为是发送出去了（而实际上，数据只是暂时被保存在发送缓冲区中）
- 但实际上，不能认为tcp发送数据是每次调用send的时候就已经发送了；而是，tcp可能会一点一点发送数据
  - 如果数据太小，tcp会用naggle算法，等待数据很多的时候一并发送
  - 如果数据太大，tcp会将数据分片发送

- 而对于**接收方**来说，我们是recv读取数据，但我们不知道一次要读多少数据
- 基于这两点就有了粘包的说法



- 换句话说，应用程序对数据的发送和接收是没有边界限制的



- 其实，如果是类似于文件的传输，是否粘包其实是无关紧要的，只要接收方正常接收即可
- 只有在TCP长链接且发送不同结构数据时（数据毫不相干，或者必须分开解读），那就要处理粘包问题了



粘包

- 现象：现在有一个能实现加法（如X+Y形式）的服务端，客户端提供数据，服务端进行计算

  - 客户端第一次发送12+12，数据就在网络中传输
  - 客户端再次发送24+24

  - 第一次数据到达服务端的传输层的tcp协议后，第二次的数据也到达此处
  - 这两次发送的数据没有任何分隔，当应用层调用recv接口接收数据后，服务端无法分隔该数据（是12+12和24+24，还是12+122和4+24，或者是其它组合，根本无从分辨）
  
- 解决办法：

  - **关闭Nagle算法，通过TCP_NODELAY选项来关闭**。缺点是TCP传输效率降低（Nagle算法主要做两件事：1、只有上一个分组得到确认，才会发送下一个分组；2、收集多个小分组，在一个确认到来时一起发送。正是Nagle算法造成了发送方有可能造成粘包现象）
  - 在应用层自定制协议：应用层头部+应用层数据+间隔符(\n\r)，格式化数据，每条数据都约定好格式（但缺点就是数据中不能有\n\r的符号）
  - **参考http是如何处理粘包的**
  



## 如何处理TCP丢包
