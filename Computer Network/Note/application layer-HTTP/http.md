# HTTP的优缺点

### 优点

- 简单
  - HTTP基本的报⽂格式就是header+body，头部信息也是key-value简单⽂本的形式，易于理解，降低了学习和使⽤的⻔槛
- 灵活和易于扩展
  - HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充
-  应⽤⼴泛和跨平台



### 缺点

- 无状态
  - 好处：因为服务器不会去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的CPU和内存⽤来对外提供服务
  - 坏处：需要反复的验证信息（由此延申出cookie和session，其中Cookie通过在请求和响应报⽂中写⼊Cookie信息来控制客户端的状态）
- 不安全
  - 明文传输，信息泄漏
  - 不验证通信⽅的身份，因此有可能遭遇伪装
  - ⽆法证明报⽂的完整性，所以有可能已遭篡改





# http默认端口

- 80端口





# HTTP1.1的特点

长连接

- 在HTTP1.0时，每发起一个请求都要三次握手
- HTTP1.1就用长连接的通信方式，也叫做持久连接
- 长连接的特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态



管道网络传输

- 可在同⼀个TCP连接里面，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间



队头阻塞

- 如果前面的请求被阻塞了的话，那么后面的请求也一同被阻塞了







# HTTP与HTTPS的区别

-  HTTP是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS则解决HTTP不安全的缺陷，在TCP和HTTP⽹络层之间加⼊了SSL/TLS安全协议，使得报⽂能够加密传输
- HTTP连接建⽴相对简单，TCP三次握⼿之后便可进⾏HTTP的报⽂传输。⽽HTTPS在TCP三次握⼿之后，还需进⾏SSL/TLS的握⼿过程，才可进⼊加密报⽂传输
- HTTP的端⼝号是80，HTTPS的端⼝号是443
- HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的







# HTTP1.1的优化

### 避免发送HTTP请求

- 背景：对于⼀些具有重复性的HTTP请求，⽐如每次请求得到的数据都⼀样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过⽹络获取服务器的响应了，这样的话HTTP/1.1的性能肯定⾁眼可⻅的提升
- 说人话：将内容缓存至本地（同时设置过期时间），请求的时候就先看本地是否有数据
- ![](../image/HTTP缓存(1).png)
- 过期时间：服务器在发送HTTP响应时，会估算⼀个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，⼀旦发现缓存的响应是过期的，则就会重新发送⽹络请求
- 如果缓存过期了，客户端重新发送后发现服务端的数据没有变更，那该怎么做呢？
  - 只需要客户端在重新发送请求时，在请求的Etag头部带上第⼀次请求的响应头部中的摘要，这个摘要是唯⼀标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个⽐较。
  - 如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源
  - 如果相同，说明客户端的缓存还是可以继续使⽤的，那么服务器仅返回不含有包体的304NotModified响应，告诉客户端仍然有效，这样就可以减少响应资源在⽹络中传输的延时
- ![](../image/HTTP缓存(2).png)



### 减少重定向请求次数

- 解决办法：使用代理服务器帮我们实现重定向
- ![](../image/使用代理服务器(之前).png)
- ![](../image/使用代理服务器(之后).png)



### 合并请求

- 背景：
  - 另外由于HTTP/1.1是请求响应模型，如果第⼀个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防⽌单个请求的阻塞，所以⼀般浏览器会同时发起5-6个请求，每⼀个请求都是不同的TCP连接，那么如果合并了请求，也就会减少TCP连接的数量，因⽽省去了TCP握⼿和慢启动过程耗费的时间
  - 如果把多个访问小⽂件的请求合并成⼀个大的请求，虽然传输的总资源还是⼀样，但是减少请求，也就意味着减少了重复发送的HTTP头部
- 解决办法：合并请求的⽅式就是合并资源，以⼀个⼤资源的请求替换多个⼩资源的请求
- 缺点：当⼤资源中的某⼀个⼩资源发⽣变化后，客户端必须重新下载整个完整的⼤资源⽂件，这显然带来了额外的网络消耗



### 延迟发送请求

- 遇到不需要的资源，可以按需获取



### 减少响应的数据大小

- 无损压缩
- 有损压缩







# HTTP缓存的私有和共有字段

- private指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中
  - Cache-Control:private
- public指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中
  - Cache-Control:public







# HTTP的禁用缓存和确认缓存

HTTP/1.1通过Cache-Control首部字段来控制缓存

- 禁止进行缓存no-store指令规定不能对请求或响应的任何一部分进行缓存
  - Cache-Control:no-store

- 强制确认缓存no-cache指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应
  - Cache-Control:no-cache







# HTTP的长连接和短链接

- 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接
- 而从HTTP/1.1起，默认使用长连接，用以保持连接特性





# 浏览器在与服务器建立了一个TCP连接后是否会在一个HTTP请求完成后断开？什么情况下会断开？

背景

- 在HTTP/1.0中，一个服务器在发送完一个HTTP响应后，会断开TCP链接。但是这样每次请求都会重新建立和断开TCP连接，代价过大



解决办法

- 所以虽然标准中没有设定，某些服务器对Connection:keep-alive的Header进行了支持。意思是说，完成这个HTTP请求之后，不要断开HTTP请求使用的TCP连接。这样的好处是连接可以被重新使用，之后发送HTTP请求的时候不需要重新建立TCP连接，以及如果维持连接，那么SSL的开销也可以避免
- 持久连接：既然维持TCP连接好处这么多，HTTP/1.1就把Connection头写进标准，并且默认开启持久连接，除非请求中写明Connection:close，那么浏览器和服务器之间是会维持一段时间的TCP连接，不会一个请求结束就断掉
- 默认情况下建立TCP连接不会断开，只有在请求报头中声明Connection:close才会在请求完成后关闭连接。