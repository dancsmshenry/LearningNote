# 13.1 引言



# 13.2 TCP连接的建立与终止

- 三次握手
  - 主动开启者发送一个SYN报文段，并指明自己想要连接的端口号和它的客户端初始序列号
  - 服务器也发送自己的SYN报文段作为响应，并包含了它自己的初始序列号。此外，为了确认客户端的SYN，服务器将其收到的初始序列号加一作为ACK的返回值。（因此每发送一个SYN，序列号就会自动加一）ps：如果出现丢包的现象，就会重传
  - 为了确认服务器的SYN，客户端将收到的初始序列号加一作为返回的ACK数值
- 三次握手的目的：
  - 让通信双方了解一个连接正在建立，还在于数据包的选项来承载特殊的信息，交换序列号
- 四次挥手
  - TCP协议规定通过发送一个FIN段来发起关闭操作
  - 连接的主动关闭者发送一个FIN段指明接收者希望看到的自己的当前的序列号



13.2.1 TCP半关闭

- 应用程序表明：我已经完成了数据的发送工作，并发送一个FIN给对方，但是我仍然希望接受来自对方的数据直到它发送一个FIN给我
- <img src="半关闭.png" style="zoom:150%;" />



13.2.2 同时打开与关闭

- ![](同时打开.png)
- ![](同时关闭.png)
- 两者真正的区别在于报文段序列是交叉的还是顺序的



13.2.3 初始序列号

- 背景：TCP报文段在经过网络路由后可能会存在延迟抵达与排序混乱的情况
  - 如果连接由于某个报文段的长时间延迟而被关闭，然后又以相同的4元组被重新打开，那么可以相信延迟的报文段又会被视为有效数据重新进入新连接的数据流中
- 所以需要避免序列号重叠，降低风险
- 并且如果有人有合适的序列号，ip地址以及端口号，那么就可以伪造出TCP报文
- 现代系统通常采用半随机的方法选择初始序列号
  - linux采用基于时钟的方案，并且针对每个连接为时钟设置随机的偏移量（偏移量是在4元组基础上用加密散列函数得到的）



13.2.5 连接建立超时

- 如果服务器关闭了，那当客户端发送请求的时候，TCP为了建立连接频繁的发送SYN报文段，第一次间隔2s，第二次间隔4秒，第三次间隔8s，称为指数回退
- 同时报文段的发送有次数限制（linux下可以改变变量来控制）
- 注意要和保活机制的探测报文区分开来



# 13.3 TCP选项

13.3.1 最大段大小选项（MSS）

- 最大段大小是指TCP协议所允许的从对方接收到的最大的报文段
- 只记录TCP数据的字节大小，不包括头部
- 默认是536字节
- IPV4模式是1460字节
- 不是TCP通信双方的协商结果，而是一个限定的数值，当通信的一方将自己的最大段大小选项发送给对方时，它表明自己不愿意接受在整个连接过程中接受任何大于该尺寸大报文段



13.3.2 选择确认选项（SACK）

- 背景：采用累计ACK确认，TCP不能正确地确认之前已经接受的数据
  - 由于接收的数据是无序的，所以接收到数据的序列号也是不连续的
  - TCP接收方的数据队列中因此会发现空洞的情况
- 作用：如果TCP发送方能够了解接收方当前的空洞，它就能在报文段丢失或被接收方遗漏时更好地进行重传工作
- SACK包含了接收方已经成功接受的数据块的序列号范围，每一个范围被称作一个SACK块，由一对32位的序列号表示
- 长度是8n+2字节



13.3.3 窗口缩放选项

- 窗口缩放选项能够有效地将TCP窗口广告字段的范围从16位增加到30位；另外，使用另一个选项作为这16位数值的比例因子，该比例因子能够使窗口字段值有效地左移
- 该选项只能出现在一个SYN报文段中，因此当连接建立以后比例因子是与方向绑定的



13.4 时间戳选项与防回绕序列号

- 时间戳选项要求发送方在每一个报文段中添加2个4字节的时间戳数值，接收方将会在确认中反映这些数值，允许发送方针对每一个接收到的ACK估算TCP的往返时间
- 为了设置重传超时，重传超时用于告知TCP通信方何时应该重新发送可能已经丢失的报文段



13.3.5 用户超时选项

- 用户超时数值指明了TCP发送者在确认对方未能成功接受数据之前原因等待该数据ACK确认的时间



13.3.6 认证选项

- 选项在于增强与替换较早的TCP-MD5机制
- 目的：为了针对各种TCP欺骗攻击提供强有力的抵御策略，但是需要创建并分发一个共享母要，所以没有得到广泛使用



# 13.5 TCP状态转换

- 下图是TCP状态转换图，粗箭头表示客户端的行为，虚线箭头表示服务器的行为

- ![](TCP状态转换图.png)



- 在第二次握手的时候，如果收到了主动打开方发来的重置信息而非ACK，那么就会返回到LISTEN状态，并且等待另一个连接请求的到来



- 下图是三四次握手挥手的过程
- ![](三四次握手挥手.png)

13.5.2 TIME_WAIT 状态

- 在该状态中，TCP将会等待两倍于最大段生存期的时间，有时也被称为加倍等待
- 每个实现都必须为最大段生存期选择一个数值
- 它代表任何报文段在被丢弃前在网络中被允许存在的最长时间
  - 影响这个时间的两个因素：IP数据报拥有TTL字段和跳数限制字段
- 规定：当TCP执行一个主动关闭并发送最终的ACK时，连接必须处于TIME_WAIT状态并连续两倍于最大生存期的时间
- 原因一：因为这样能够让TCP重新发送最终的ACK以避免出现丢失的情况（即最后发送的ACK可能会超时无法到达被动关闭方，导致另一方重传了它的FIN）
- 原因二：当在2MSL的状态的时候，通信双方将该连接定义为不可重新使用（2MSL状态能够防止新的连接将前一个连接的延迟报文段解释成自身数据的状况）



13.5.3 静默时间的概念

- 背景：如果一台与处于TIME_WAIT状态侠的连接相关联的主机崩溃，然后在MSL内重新启动，那应该如何处理
- 静默时间：在崩溃或重启后TCP协议应当在创建新的连接之前等待相当于一个MSL的时间



13.5.4 FIN_WAIT_2 状态

- 只有当应用程序完成了这一关闭操作，正在关闭的TCP连接才会从FIN_WAIT_2状态转移至TIME_WAIT状态
- 防止连接进入FIN_WAIT_2这一无限等待状态：
  - 如果负责主动关闭的应用执行的是一个完全关闭操作，而不是用一个半关闭来指明它还期望接受数据，那么就会设置一个计时器
  - 如果当计时器超时时连接是空心啊的，那么TCP连接就会转移到CLOSED状态



# 13.6 重置报文段

- RST位字段，一个将该字段置位的报文段被称作“重置报文段”

- 一般来说，当发现一个到达的报文段对于相关连接而言是不正常的时候，TCP会发送一个重置报文段



13.6.1 针对不存在端口的连接请求

- 当一个连接请求到达本地却没有相关进程在目的端口侦听时就会产生一个重置报文段
- UDP协议规定，当一个数据报到达一个不能使用的目的端口时就会产生一个ICMP目的地不可到达（端口不可达）的消息
- TCP协议则使用重置报文段来代替相关工作
- 对于一个被TCP端接收的重置报文段而言，它的ACK位字段必须被置位，并且ACK号字段的数值必须在正确窗口的范围内
  - 原因：防止任何人都能生成一个与相应连接匹配的重置报文段



13.6.2 终止一条连接

- 有序释放：终止一条连接的正常方法是由通信一方发送一个FIN（因为FIN是在之前所有排队数据都已发送后才被发送出去，通常不会出现丢失数据的情况）
- 终止释放：任何时刻，发送一个重置报文段替代FIN来终止一条连接
- 终止连接的两大特性：
  - 任何排队的数据都将被抛弃，一个重置报文段会被立即发送出去
  - 重置报文段的接收方会说明通信另一方采用了终止的方式而不是依次正常的关闭

- SOCKET的实现：将SO_LINGER的数值设置为0来实现终止行为的方式来取代正常的关闭操作
  - 这意味着，socket不会在终止之前为了确定数据是否到达另一端而逗留任何时间

- 注意：
  - 重置报文段不会令通信另一端做出任何响应，即不会对重置报文段做出回应
  - 接收重置报文段的一端会终止连接并通知应用程序当前连接已被重置




13.6.3 半开连接

- 如果在未告知另一端的情况下通信的一端关闭或终止连接，那么就认为该条TCP连接处于半开状态（这种情况一般发生在通信一方的主机崩溃的情况下）
  - 所以如果不通过连接传输数据，正常工作的一端是不会检测出另一端崩溃了的
  - 发生的原因可能是某一台主机的电源被切断而不是正常关机

- 因此会导致有很多的半开连接（后续的保活机制会处理这些连接的）
- 如果服务器重开，我们重新连接以太网并且尝试从客户端向服务器发送一条命令；但是重启之后，服务器的TCP会丢失之前所有连接的记忆，因此它对数据段中指出的这台连接一无所知，此时TCP规定接收者将回复一个重置报文段作为响应，然后两端就会关闭
- 服务器主机被切断连接后重启，留给客户端一个半开的连接，当再次从这条连接上接收到其他数据时，服务器对其一无所知，在服务器回复一个重置报文段作为响应之后，两端之间的连接就会被关闭



13.6.4 时间等待错误

- 设计TIME_WAIT状态的目的是允许任何受制于一条关闭连接的数据包被丢弃（期间等待TCP不需要做任何操作）
- 但是如果它在这段时间内接收到来自这条连接的一些报文段，或者重置报文段，那么状态就会被破坏，称为时间等待错误
- 就四次握手以后，主动关闭的一方处于time_wait的状态，此时收到来自服务器发送的迟来的报文或重置报文，此时主动关闭方就发送ACK回应，而服务器已经没有了关于这条连接的任何信息，因此发送一个重置报文段响应，使得主动关闭方过早的从TIME_WAIT变为CLOSED状态
- 解决：处于TIME_WAIT状态时不对重置报文段做出反应，从而避免上述问题



# 13.7 TCP服务器选项



13.7.4 进入连接队列

背景

- 在被用于应用程序之前新的连接可能会处于一下两个状态
  - 连接尚未完成但是已经接收到SYN（处于SYN_RCVD状态）
  - 另一种是连接已经完成了三次握手并且处于ESTABLISHED状态，但是尚未被应用程序接收的



Linux内核的实现

- 当一个请求到达时（SYN报文段），将会检查系统范围的参数net.ipv4.tcp_max_syn_backlog（默认是1000）；如果处于SYN_RCVD状态的连接数目超过了这一阈值，进入的连接将会被拒绝
- 每个处于侦听状态下的结点都拥有一个固定长度的连接队列；其中的连接已经被TCP完全接收（三次握手已经完成），但未被应用程序接收；应用程序会对这一队列做出限制，通常称为未完成连接（backlog）；backlog的数目必须在0与一个系统指定的最大值之间；一般记为net.core.somaxconn，默认是128；需要记住的是backlog的数值指出了侦听节点中排队连接的最大数目，所有这些连接已经被TCP接收并等待应用接收
- 如果侦听节点的队列中仍然有空间分配给新的连接，TCP模块会应答SYN并完成连接。直到接收到三次握手中的第三个报文段之后，与侦听节点相关的应用程序才会知道新的连接。当客户端的主动打开操作顺利完成之后，客户端可能会认为服务器已经准备好接收数据，然而服务器上的应用程序此时可能还未收到关于新连接的通知；如果这种情况发生，服务器的TCP模块会把到来的数据存入队列
- 如果队列中已没有足够的空间分配给新的连接，TCP将会延迟对SYN做出响应，从而给应用程序一个跟上节奏的机会（这里的队列就是上述的侦听队列）；而在linux下，它坚持在能力允许的范围内不忽略进入的连接，如果系统控制变量net.ipv4.tcp_abort_on_已被设定，新进入的连接会被重置报文段重新置位
- 正常情况下，当队列已满，应用程序或操作系统会十分繁忙，此时应当阻止应用程序再去服务那些进入的连接。但是如果发送重置报文，会使得客户端将会放弃主动打开的操作。所以不发送重置报文，如果一台侦听的服务器时钟无法抽出时间来接收那些已经被TCP接受却超出队列保存上限的连接，那么根据正常TCP的机制，客户端的主动打开操作将会超时。在linux中，连接的客户端将会明细那放缓一段时间-它们既不会超时也不会重置
- 综上，当队列满了以后，解决办法就是忽略syn报文段



# 13.8 与TCP连接管理相关的攻击

- SYN泛洪是一种TCP拒绝服务攻击，在这种攻击中一个或多个恶意的客户端产生一系列TCP连接尝试，并将它们发送给一台服务器，它们通常采用伪造的源IP地址
- 而服务器会为每一条连接分配一定数量的连接资源，由于连接尚未完全建立，服务器为了维护大量的半打开连接会耗尽自身内存后拒绝为后续的合法连接请求服务
- 解决办法：引入SYN cookies：
- 当一个SYN到达时，这条连接存储的大部分信息都会被编码并保存在SYN+ACK报文段的序列号字段，不需要为进入的连接请求分配任何存储资源（只有当SYN+ACK报文段本身被确认后才会分配真正的内存），在这种情况下所有重要的连接参数都能够重新获得，同时连接也能够被设置为ESTABLISHED状态
- Linux采用的办法：
  - 服务器在接收到一个SYN后会采用下面的方法设置初始序列号（保存于SYN+ACK报文段，供于客户端）的数值：首5位时t mod 32的结果，其中t是一个32位的计数器，每隔64秒+1；接着3位是服务器最大段大小的编码值；剩余的24位保存了4元组和值的散列值
  - 在采用syn cookies方法时，服务器总是以一个SYN+ACK报文段作为响应。在接收到ACK后，如果根据其中的t值可以计算出与加密的散列值相等的结果，服务器才会为该SYN重新构建队列
  - 缺点：由于需要对最大段大小进行编码，这种方法禁止使用任意大小的报文段；由于计时器会回绕，连接建立的过程会因周期非常长而无法工作




- 路径最大传输单元过程相关。在这种攻击中，攻击者伪造一个ICMP PTB消息，该消息包含了一个非常小的MTU的值，迫使受害者的TCP尝试采用非常小的数据包来填充信息
  - 比如简单地禁用主机的路径最大传输单元发现功能



- 还有一类攻击，使得两端正在通信的TCP节点失去同步，这样它们将使用不正确的序列号（序列号攻击）
- 比如说：在连接建立过程中引发不正确的状态传输，在ESTABLISHED状态下产生额外的数据
- 一旦两端不能再进行通信，攻击者就能够在连接中注入新的流量，而且这些注入的流量会被TCP认为是正确的



- 欺骗攻击：攻击者生成一个伪造的重置报文段并将其发送给一个TCP通信节点（假定四元组和校验和都是正确的），可能会使得连接的任意一端失败
- 解决：
  - 认证每一个报文段
  - 要求每一个重置报文段拥有一个特殊的序列号以代替处于某一个范围的序列号
  - 要求时间戳选项具有特定的数值