# 13.1 引言



# 13.2 TCP连接的建立与终止

- 三次握手
  - 主动开启者发送一个SYN报文段，并指明自己想要连接的端口号和它的客户端初始序列号
  - 服务器也发送自己的SYN报文段作为响应，并包含了它自己的初始序列号。此外，为了确认客户端的SYN，服务器将其收到的初始序列号加一作为ACK的返回值。（因此每发送一个SYN，序列号就会自动加一）ps：如果出现丢包的现象，就会重传
  - 为了确认服务器的SYN，客户端将收到的初始序列号加一作为返回的ACK数值
- 三次握手的目的：
  - 让通信双方了解一个连接正在建立，还在于数据包的选项来承载特殊的信息，交换序列号
- 四次挥手
  - TCP协议规定通过发送一个FIN段来发起关闭操作
  - 连接的主动关闭者发送一个FIN段指明接收者希望看到的自己的当前的序列号



13.2.1 TCP半关闭

- 应用程序表明：我已经完成了数据的发送工作，并发送一个FIN给对方，但是我仍然希望接受来自对方的数据直到它发送一个FIN给我
- <img src="半关闭.png" style="zoom:150%;" />



13.2.2 同时打开与关闭

- ![](同时打开.png)
- ![](同时关闭.png)
- 两者真正的区别在于报文段序列是交叉的还是顺序的



13.2.3 初始序列号

- 背景：TCP报文段在经过网络路由后可能会存在延迟抵达与排序混乱的情况
  - 如果连接由于某个报文段的长时间延迟而被关闭，然后又以相同的4元组被重新打开，那么可以相信延迟的报文段又会被视为有效数据重新进入新连接的数据流中
- 所以需要避免序列号重叠，降低风险
- 并且如果有人有合适的序列号，ip地址以及端口号，那么就可以伪造出TCP报文
- 现代系统通常采用半随机的方法选择初始序列号
  - linux采用基于时钟的方案，并且针对每个连接为时钟设置随机的偏移量（偏移量是在4元组基础上用加密散列函数得到的）



13.2.5 连接建立超时

- 如果服务器关闭了，那当客户端发送请求的时候，TCP为了建立连接频繁的发送SYN报文段，第一次间隔2s，第二次间隔4秒，第三次间隔8s，称为指数回退
- 同时报文段的发送有次数限制（linux下可以改变变量来控制）
- 注意要和保活机制的探测报文区分开来



# 13.3 TCP选项

13.3.1 最大段大小选项（MSS）

- 最大段大小是指TCP协议所允许的从对方接收到的最大的报文段
- 只记录TCP数据的字节大小，不包括头部
- 默认是536字节
- IPV4模式是1460字节
- 不是TCP通信双方的协商结果，而是一个限定的数值，当通信的一方将自己的最大段大小选项发送给对方时，它表明自己不愿意接受在整个连接过程中接受任何大于该尺寸大报文段



13.3.2 选择确认选项（SACK）

- 背景：采用累计ACK确认，TCP不能正确地确认之前已经接受的数据
  - 由于接收的数据是无序的，所以接收到数据的序列号也是不连续的
  - TCP接收方的数据队列中因此会发现空洞的情况
- 作用：如果TCP发送方能够了解接收方当前的空洞，它就能在报文段丢失或被接收方遗漏时更好地进行重传工作
- SACK包含了接收方已经成功接受的数据块的序列号范围，每一个范围被称作一个SACK块，由一对32位的序列号表示
- 长度是8n+2字节



13.3.3 窗口缩放选项

- 窗口缩放选项能够有效地将TCP窗口广告字段的范围从16位增加到30位；另外，使用另一个选项作为这16位数值的比例因子，该比例因子能够使窗口字段值有效地左移
- 该选项只能出现在一个SYN报文段中，因此当连接建立以后比例因子是与方向绑定的



13.4 时间戳选项与防回绕序列号

- 时间戳选项要求发送方在每一个报文段中添加2个4字节的时间戳数值，接收方将会在确认中反映这些数值，允许发送方针对每一个接收到的ACK估算TCP的往返时间
- 为了设置重传超时，重传超时用于告知TCP通信方何时应该重新发送可能已经丢失的报文段



13.3.5 用户超时选项

- 用户超时数值指明了TCP发送者在确认对方未能成功接受数据之前原因等待该数据ACK确认的时间



13.3.6 认证选项

- 选项在于增强与替换较早的TCP-MD5机制
- 目的：为了针对各种TCP欺骗攻击提供强有力的抵御策略，但是需要创建并分发一个共享母要，所以没有得到广泛使用



# 13.5 TCP状态转换

- 下图是TCP状态转换图，粗箭头表示客户端的行为，虚线箭头表示服务器的行为

- ![](TCP状态转换图.png)



- 在第二次握手的时候，如果收到了主动打开方发来的重置信息而非ACK，那么就会返回到LISTEN状态，并且等待另一个连接请求的到来



- 下图是三四次握手挥手的过程
- ![](三四次握手挥手.png)

13.5.2 TIME_WAIT 状态

- 在该状态中，TCP将会等待两倍于最大段生存期的时间，有时也被称为加倍等待
- 每个实现都必须为最大段生存期选择一个数值
- 它代表任何报文段在被丢弃前在网络中被允许存在的最长时间
  - 影响这个时间的两个因素：IP数据报拥有TTL字段和跳数限制字段
- 规定：当TCP执行一个主动关闭并发送最终的ACK时，连接必须处于TIME_WAIT状态并连续两倍于最大生存期的时间
- 原因一：因为这样能够让TCP重新发送最终的ACK以避免出现丢失的情况（即最后发送的ACK可能会超时无法到达被动关闭方，导致另一方重传了它的FIN）
- 原因二：当在2MSL的状态的时候，通信双方将该连接定义为不可重新使用（2MSL状态能够防止新的连接将前一个连接的延迟报文段解释成自身数据的状况）



13.5.3 静默时间的概念

- 背景：如果一台与处于TIME_WAIT状态侠的连接相关联的主机崩溃，然后在MSL内重新启动，那应该如何处理
- 静默时间：在崩溃或重启后TCP协议应当在创建新的连接之前等待相当于一个MSL的时间



13.5.4 FIN_WAIT_2 状态

- 只有当应用程序完成了这一关闭操作，正在关闭的TCP连接才会从FIN_WAIT_2状态转移至TIME_WAIT状态
- 防止连接进入FIN_WAIT_2这一无限等待状态：
  - 如果负责主动关闭的应用执行的是一个完全关闭操作，而不是用一个半关闭来指明它还期望接受数据，那么就会设置一个计时器
  - 如果当计时器超时时连接是空心啊的，那么TCP连接就会转移到CLOSED状态



# 13.6 重置报文段

- RST位字段，一个将该字段置位的报文段被称作“重置报文段”

- 一般来说，当发现一个到达的报文段对于相关连接而言是不正常的时候，TCP会发送一个重置报文段



13.6.1 针对不存在端口的连接请求

- 当一个连接请求到达本地却没有相关进程在目的端口侦听时就会产生一个重置报文段
- UDP协议规定，当一个数据报到达一个不能使用的目的端口时就会产生一个ICMP目的地不可到达（端口不可达）的消息
- TCP协议则使用重置报文段来代替相关工作
- 对于一个被TCP端接收的重置报文段而言，它的ACK位字段必须被置位，并且ACK号字段的数值必须在正确窗口的范围内
  - 原因：防止任何人都能生成一个与相应连接匹配的重置报文段



13.6.2 终止一条连接

- 有序释放：终止一条连接的正常方法是由通信一方发送一个FIN（因为FIN是在之前所有排队数据都已发送后才被发送出去，通常不会出现丢失数据的情况）
- 终止释放：任何时刻，发送一个重置报文段替代FIN来终止一条连接
- 终止连接的两大特性：
  - 任何排队的数据都将被抛弃，一个重置报文段会被立即发送出去
  - 重置报文段的接收方会说明通信另一方采用了终止的方式而不是依次正常的关闭

- SOCKET的实现：将SO_LINGER的数值设置为0来实现终止行为的方式来取代正常的关闭操作
  - 这意味着，socket不会在终止之前为了确定数据是否到达另一端而逗留任何时间

- 注意：
  - 重置报文段不会令通信另一端做出任何响应，即不会对重置报文段做出回应
  - 接收重置报文段的一端会终止连接并通知应用程序当前连接已被重置




13.6.3 半开连接

- 如果在未告知另一端的情况下通信的一端关闭或终止连接，那么就认为该条TCP连接处于半开状态（这种情况一般发生在通信一方的主机崩溃的情况下）
  - 所以如果不通过连接传输数据，正常工作的一端是不会检测出另一端崩溃了的
  - 发生的原因可能是某一台主机的电源被切断而不是正常关机

- 因此会导致有很多的半开连接（后续的保活机制会处理这些连接的）
- 如果服务器重开，我们重新连接以太网并且尝试从客户端向服务器发送一条命令；但是重启之后，服务器的TCP会丢失之前所有连接的记忆，因此它对数据段中指出的这台连接一无所知，此时TCP规定接收者将回复一个重置报文段作为响应，然后两端就会关闭
- 服务器主机被切断连接后重启，留给客户端一个半开的连接，当再次从这条连接上接收到其他数据时，服务器对其一无所知，在服务器回复一个重置报文段作为响应之后，两端之间的连接就会被关闭



13.6.4 时间等待错误

- 设计TIME_WAIT状态的目的是允许任何受制于一条关闭连接的数据包被丢弃（期间等待TCP不需要做任何操作）
- 但是如果它在这段时间内接收到来自这条连接的一些报文段，或者重置报文段，那么状态就会被破坏，称为时间等待错误
- 就四次握手以后，主动关闭的一方处于time_wait的状态，此时收到来自服务器发送的迟来的报文或重置报文，此时主动关闭方就发送ACK回应，而服务器已经没有了关于这条连接的任何信息，因此发送一个重置报文段响应，使得主动关闭方过早的从TIME_WAIT变为CLOSED状态
- 解决：处于TIME_WAIT状态时不对重置报文段做出反应，从而避免上述问题



# 13.7 TCP服务器选项



# 13.8 与TCP连接管理相关的攻击

- SYN泛洪是一种TCP拒绝服务孔家，在这种攻击中一个或多个恶意的客户端产生一系列TCP连接尝试，并将它们发送给一台服务器，它们通常采用伪造的源IP地址
- 而服务器会为每一条连接分配一定数量的连接资源，由于连接尚未完全建立，服务器为了维护大量的半打开连接会耗尽自身内存后拒绝为后续的合法连接请求服务
- 解决办法：引入SYN cookies，当一个SYN到达时，这条连接存储的大部分信息都会被编码并保存在SYN+ACK报文段的序列号字段，不需要为进入的连接请求分配任何存储资源（只有当SYN+ACK报文段本身被确认后才会分配真正的内存）
  - Linux采用的办法：服务器在接收到一个SYN后会采用下面的方法设置初始序列号（保存于SYN+ACK报文段，供于客户端）的数值：首5位时t mod 32的结果，其中t是一个32位的计数器，每隔64秒+1；接着3位是服务器最大段大小的编码值；剩余的24位保存了4元组和值的散列值
  - 在采用syn cookies方法时，服务器总是以一个SYN+ACK报文段作为响应。在接收到ACK后，如果根据其中的t值可以计算出与加密的散列值相等的结果，服务器才会为该SYN重新构建队列（缺点：）



- 路径最大传输单元过程相关。在这种攻击中，攻击者伪造一个ICMP PTB消息，该消息包含了一个非常小的MTU的值，迫使受害者的TCP尝试采用非常小的数据包来填充信息
  - 比如简单地禁用主机的路径最大传输单元发现功能



- 还有一类攻击，使得两端正在通信的TCP节点失去同步，这样它们将使用不正确的序列号（序列号攻击）



- 欺骗攻击：攻击者生成一个伪造的重置报文段并将其发送给一个TCP通信节点，可能会使得连接的任意一端失败