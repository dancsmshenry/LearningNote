# 14.1 引言



# 14.2 简单的超时与重传举例



# 14.3 设置重传超时

- TCP超时和重传的技术是怎样根据给定连接的RTT设置RTO
- TCP在收到数据后会返回确定信息，因此可在该信息中携带一个字节的数据来测量传输该确认信息所需的时间
- 每个TCP连接的RTT均独立估算，并且重传计时器会对任何占用序列号的在传数据计时



4.3.1 经典方法

- SRTT = α * (SRTT) + (1 - α) * RTT
- SRTT是基于现存值和新的样本值更新的结果，α是平滑因子
- 每次得到新的样本值，SRTT就会做出相应的更新
- 这种估算方法被称为指数加权移动平均或低通过滤器



14.3.2 标准方法

- 



时钟粒度与RTO边界

- TCP时钟通常为某个变量，该变量值随着始终而做出更新
- TCP时钟一个”滴答“的时间长度称为粒度，一般是500ms，linux下为1ms
- RTO有一个最小值的边界：RTO = max（srtt + max（G， 4（rttvar））， 1000）



初始值

- 系统预设初始值RTO为1s，而初始SYN报文段采用的超时间隔为3s



重传二义性与Karn算法

- 重传二义性：假设一个包的传输出现超时，该数据包就会被重传，接着收到一个确认信息，那么该信息是对第一次还是第二次传输的确认就存在二义性
- 解决办法：Karn算法：
  - 当接收到重复传输数据的确认信息时，不进行该数据包的RTT测量，可以避免重传二义性问题，另外，对该数据包之后的包采取退避策略，仅当接收到未经重传的数据时，该SRTT才用于计算RTO
  - 退避系数：每当重传计时器出现超时，退避系数增加，该过程一直持续至接收到非重传数据



# 14.4 基于计时器的重传



# 14.5 快速重传

- 概述：TCP发送端在观测到至少dupthresh个重复ACK后，即重传可能丢失的数据分组，而不必等到重传计时器超时。当然也可以同时发送新的数据
-  当失序数据到达时，重复ACK应立即返回，不能延时发送
- 重复ACK到达一般表明发送端先前发送的某个分组已丢失
- 根据重复ACK推断的丢包通常与网络拥塞有关，因此快速重传会伴随拥塞控制机制



# 14.6 带选择确认的重传

- TCP发送端的任务是通过重传丢失的数据来填补接收端缓存中的空缺，但同时也要尽可能保证不重传已正确接收到的数据
- 当采用SACK时，一个ACK可包含三四个告知失序数据的SACK信息，每个SACK信息包含32位的序列号，代表接收端存储的失序数据的其实至最后一个序列号



14.6.1 SACK接收端行为

- 导致数据失序的原因：传输过程中丢失，也可能是新数据先于旧数据到达
- 第一个SACK块内包含的是最近接收到的报文段的序列号范围（例如：当前已经接受了0-100，300-500的数据，那么sack就会使300-500，ack就会是200，三次ack之后发送方就会重传信息了）
- 其余的SACK块包含的内容也按照接收的先后依次排列，最新一块中包含的内容除了包含最近接收的序列号信息，还需重复之前的SACK块
- 在一个SACK内包含多个SACK块，并且在多个SACK中重复这些块信息的目的在于，为防止SACK丢失提供一些备份



14.6.2 SACK发送端行为

- 



# 14.7 伪超时与重传

- 伪重传：即使没有出现数据丢失也可能引发重传
- 伪超时：过早判定超时



# 14.8 包失序与包重复

14.8.1 失序

- 原因：IP层不能保证包传输是有序进行的（因为IP可以选择另一条传输路线，而不用担心新发送的分组会先于旧数据到达，这就导致了数据的接收顺序与发送顺序不一致）
- 如果失序发生在反向链路，就会使得TCP发送端窗口快速前移，接着又可能收到一些显然重复而应被丢弃的ACK（因为后面的ACK早到了，导致窗口快速前移），结果导致发送端出现不必要的流量突发
- 如果发生在正向链路，TCP可能无法正确识别失序和掉包，数据的丢失和失序都会导致接收端收到无序的包，造成数据间的空缺，严重的会造成伪重传
- ![](包失序.png)
- 左边是轻微的失序，右边是重度的失序



14.8.2 重复

- 背景：IP协议可能出现将单个包传输多次的情况，从而造成伪快速重传
- 解决：采用DSACK，每个A3的重复ACK都包含报文段已成功接收的信息，并且没有包含失序数据信息，意味着到达的包一定是重复数据



# 14.9 目标度量

- 