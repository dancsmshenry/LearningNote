# 第五章 运输层

- 运输层向它上面的应用层提供通信服务
- 两台主机之间的通信，是这台主机中的一个进程和另一台主机中的进程在交换数据
- 从运输层的角度看，通信的真正端点并不是主机而是主机中的进程
- 运输层的复用和分用
  - 复用：发送方不同的应用进程都可以使用同一个运输层协议传送数据（应用层所有的应用进程都可以通过运输层在传给IP层）
  - 分用：接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的进程（运输层从IP层受到发送给各应用进程的数据后，必须分别交付指明的各应用进程）
- 运输层提供应用进程间的逻辑通信，而网络层为主机之间提供逻辑通信
- 两种运输协议：面向连接的TCP（Transmission Control Protocol）和无连接的UDP（User Datagram Protocol）
  - 当采用TCP协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道
  - 采用UDP时，仍是一条不可靠信道
- 两个对等运输实体在通信时传送的数据单位叫运输协议数据单元
  - 在TCP中叫做TCP报文段，在UDP中叫做UDP用户数据报
- UDP在传送数据之前不需要先建立连接，TCP则提供面向连接的服务
- 协议端口号：
  - 软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址
  - 端口号只具有本地意义，他只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口
- 服务端使用的端口号
  - 熟知端口号，一些常用的端口号，如FTP，HTTP等
  - 登记端口号，为没有熟知端口号的应用程序设定
- 客户端使用的端口号
  - 仅在客户进程运行时才动态选择，又称为短暂端口号
  - 通信结束后，已使用过的客户端口号就不复存在了，这个端口号就可以供其他客户进程使用



## UDP

- 特点：
  - 是无连接的，即发送数据之前不需要建立连接（发送数据结束后也没有连接可释放）
  - 尽最大努力交付，即不保证可靠交付
  - 面向报文的，对于应用层交下来的报文，不合并也不拆分，保留报文的边界
  - 没有拥塞控制（实时应用的要求：允许在网络发生拥塞时丢失一些数据，不允许数据有太大的时延）
  - 支持一对一、一对多、多对一和多对多的交互通信
  - 首部开销小，只有八个字节
- UDP有两个字段：数据字段和首部字段
- 首部字段（八个字节，四个字段）：
  - 源端口（在需要对方回信时选用，不用可全部为0）
  - 目的端口（在终点交付报文时必须使用）
  - 长度（整个UDP数据报的长度，最小长度为8，因为有一个首部）
  - 检验和（检测UDP数据是否在传输中出错，有错就丢弃）
- 虽然用到端口号，但是udp是无连接的，所以不需要套接字连接
- **挖坑**：udp计算检验和的方法



## TCP

- 特点：
  - 面向连接的运输层协议（在使用之前，必须先建立TCP连接）
  - 每一条TCP连接只能有两个端点，每一条TCP连接只能点对点的
  - 提供可靠交付的服务，数据无差错不丢失不重复，并且按序到达
  - 提供全双工通信，允许双方的应用进程在任何时候都能发送数据，tcp连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据
  - 面向字节流（流：流入到进程或从进程流出的字节序列，大概意思是运输层不管你传进来的是几个运输块，我反正是按照字节流传入，传输由字节流组成的数据块，所以在数据的块数上是没有区别的）
- 与udp相比
  - tcp是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节
  - 而udp是根据应用进程来给出的
- 连接
  - 套接字：端口号拼接到IP地址（IP地址：端口号）
  - 每一条TCP连接唯一地被通信两端的两个端点（两个套接字）所确定
  - TCP连接的端点是个很抽象的套接字，即IP地址：端口号
  - 同一个IP地址可以有多个不同的TCP连接，同一个端口号也可以出现在多个不同的TCP连接中
- 可靠传输的工作原理
  - 理想的传输条件
    - 传输信道不产生差错
    - 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据
  - 停止等待协议（最简单的，已经不使用了）
    - 无差错情况（发送M1，确认接受M1）
    - 出现差错
      - 超时重传：发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组对视，因而重传前面发送过的分组
      - 超时计时器
      - 需要注意的三点：
      - 第一，发送方发送完分组以后，必须暂时保留已发送的分组副本（用于超时重传）
      - 第二，分组和确认分组都必须进行编号，这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认
      - 第三，超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些（重传时间的确认十分复杂，涉及网络的拥塞情况，时延等）
    - 确认丢失和确认迟到
      - 如果接收端发送的确认接受丢失了，那么发送方将重新发送一个M1给接收方，接收方就丢弃原来的M1，同时接受新的M1，并发回确认
      - 如果接收端发送的确认迟到了，发送端的操作同上；并且，发送端在接受到了迟来的确认以后，什么都不做
    - 像上述的这种可靠传输协议通常称为自动重传请求ARP（Automatic Repeat reQuest）
    - 信道利用率
      - 传统的停止等待协议的信道利用率太低了..
      - U = Td / Td + RTT + Ta（Td是发送分组的时间，RTT是分组到接收端在返回发送端的时间，Ta是接收端发送确认分组需要的时间）
      - 为了提供传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输
  - 连续ARQ协议
    - 发送窗口：连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置
    - 接收方一般都是采用积累确认的方式，即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认
    - 优点：容易实现，即使确认丢失也不必重传。缺点：不能向发送方反映接收方已经正确收到的所有分组的信息
    - 回退N：go back N
- TCP报文段的首部格式（其实还是没搞懂啥是面向字节流，啥是面向报文段..）
  - 分为首部和数据两部分
  - 首部的前20个字节是固定的（因此首部的最小长度就是20字节，1字节=8位）：
    - 源端口，目的端口：各占2个字节，分别写入源端口号和目的端口号
    - 序号（报文段序号）：占4个字节，在TCP连接中传送的字节流中的每一个字节都按顺序编号（实际上就是记录当前数据的第一个字段的位置，后面的分组再续上）；范围是[0，2^32 - 1]
    - 确认号：占4个字节，是期望收到对方下一个报文段的第一个数据字节的序号（我这次收到前700的数据，那么我的确认号就应该是701），总之：若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到
    - 数据偏移：占4位（半个字节），指出TCP报文段的数据起始处距离TCP报文段的起始处有多远（TCP报文段的首部长度），因为首部的长度是不确定的（数据偏移的最大值是60字节，这也是TCP首部的最大长度）
    - 保留，占6位，保留为今后使用，设置为0
    - 紧急
    - 确认ACK，仅当ACK = 1时确认号字段才有效。当ACK = 0时候，确认好无效
    - 还有好多好多，就后续补了，现在先全面的看一遍，就不纠结细节（面试不考的）了
- TCP可靠的传输
  - 以字节为单位的滑动窗口
    - 发送方维护一个发送窗口，窗口的内容表示再未收到确认信息之前，发送方可以连续把窗口内的数据都发送出去（凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便超时重传时使用）
    - 发送窗口的位置由窗口的前沿和后沿的位置共同确认
      - 后沿的变化情况：不动（没有收到新的确认）和前移（收到了新的确认），不可能向后移
      - 前沿的变化情况：不动（没有收到新的确认，对方通知的窗口大小不变）（不过也有可能向后收缩，发生在对方通知的窗口缩小了）
    - 发送窗口的三个指针：P1，P2，P3（P3-P1为发送窗口的长度，P2-P1为已发送但尚未收到确认的字节数，P3-P2为允许发送但当前尚未发送的字节数，又称为可用窗口或有效窗口）
    - 发送缓存存放：
      - 发送应用程序传送给发送方TCP准备发送的数据
      - TCP已发送出但尚未收到确认的数据
    - 接收缓存存放：
      - 按序到达的，但尚未被接收应用程序读取的数据
      - 未按序到达的数据
    - 虽然发送端的发送窗口是根据接收端的接收窗口设置的，但在同一时刻，A的发送窗口并不总是和B的接收窗口一样大（通过网络传送窗口值需要经历一定的时间滞后）
    - TCP对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，在按序交付上层的应用进程
    - TCP要求接收方必须有累积确认的功能，这样可以减少传输开销
  - 超时重传时间的选择
    - 挖坑，这里涉及不同的记录时间的算法
  - 选择确认SACK
    - 背景：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据
    - 解决办法：在首文字段中加上SACK
- TCP的流量控制
  - 利用滑动窗口实现流量控制
    - 流量控制：让发送方的发送速率不要太快，要让接收方来得及接收
    - 发送方的发送窗口不能超过接收方给出的接收窗口的数值
    - 持续计时器：只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期了，就发送一个零窗口探测报文段，而对方就在确认这个探测报文段时给出了现在的窗口值（防止死锁：即接收端发送一个窗口有关的报文，则发送端的窗口变为了0，同时开始等待接收端的非零窗口的通知，而此时接收端又有空间了，就发送rwnd=400的报文段，但报文段丢失了，以致于双方都陷入了等待的情况）
    - 解决过程：如果出现分组丢失或发送速率太快，就发送一个分组（包括ACK，ack，rwnd）用来调整窗口的大小
  - TCP的传输效率
    - 几种不同的机制传输数据
      - TCP维持一个变量，它等于最大报文段长度MSS，只要缓存中的数据达到MSS字节，就组装成一个TCP报文段发送出去
      - 由发送方的应用进程指明要求发送报文段，即TCP支持的推送操作
      - 发送方的一个计时器计时快结束了，这就把当前已有的缓存数据装入报文段发送出去
    - Nagle算法
      - 若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节发送出去
