## golang是否需要协程池

- goroutine的初衷就是轻量级的线程，为的就是让你随用随起，结果你又搞个池子来，这不是脱裤子放屁么？你需要的是限制并发，而协程池是一种违背了初衷的方法



- 池化要解决的问题一个是频繁创建的开销，另一个是在等待时占用的资源。goroutine 和普通线程相比，创建和调度都不需要进入内核，也就是创建的开销已经解决了。同时相比系统线程，内存占用也是轻量的。所以池化技术要解决的问题goroutine 都不存在，为什么要创建 goroutine pool 呢？



但是，是否需要协程池还需要看具体的场景

- 比如说，如果对每个client都起一个goroutine，很快机子的内存就会被耗尽的，所以需要用协程池对内存做出限制，也不能说是协程池，应该是goroutine池（gotoutine和传统的协程是有很大的区别的）
- 使用协程池将让多余的请求进入排队状态，等待池中有空闲协程的时候来处理，这是模拟的I/O多路复用机制
- 或者说，面对高并发低延时的情况，如网关，可能是go的调度还是有问题把，所以还是要省着用goroutine



- 额，我感觉我应该能够说一说这个问题。我以前也觉得Go是不需要复用goroutine，毕竟据说“非常轻量级”……但是，其实很多时候话不能说死了。应该是98.72531%的场景下，你不需要goroutine池，剩下不到2%的case，大多数人应该也遇不到，所以说“不需要协程池”，几乎是正确的。

  那剩下不到2%的case是啥呢？——超高并发低延时的case，比如做网关。我们的网关目前单机2W+的QPS，是非常极端的场景了。有人可能网上blog看多了，觉得2W好意思拿出来说，别人都是百万级，C100K。额，具体区别就不多说了，如果认识人，可以问问微博feed流，百度大搜等等高峰期单机有多大的QPS…

  说这个的意思就是，我用Go的生产环境中应对过大流量，所以知道Go的Scheduler还是不够好，Go的协程调度还是挺坑的，感兴趣可以搜搜TiDB的吐槽，他们也是重度用户，极端压力下的goroutine调度，真心让人抓狂。

  所以，这种case下，goroutine要省着用，不然你pprof里大部分时间就花在runtime.findRunableG上了。最简单的例子，假设你每秒new 5W个goroutine，但是每个goroutine至少运行2秒，你系统内的g就会堆积，越来越多，然后scheduler负担越来越重，导致每个goroutine耗时比2秒更长，导致堆积更加严重，然后你的系统就崩溃了。所以，这种时候goroutine一定要省着用。当然你说你可以限流，但是那也得保证goroutine回收的速率不高于生产的速率。

  不过以上case都是极端场景下才会遇到，对于98%几十几百QPS的服务，那肯定就不需要了





- 一般情况下，goroutine在操作系统上只要你的硬件资源够它是可以无限启动的。但是如果出现大规模的启动goroutine的情况会造成大量占用系统资源，我们知道普通的部署一个golang应用的时候操作系统不仅仅会运行golang程序还有其他辅助的程序运行，所以理论上讲工作池的目的就是为了限制golang的启动数量，保证不会出现硬件计算资源溢出的情况



# Golang 开发环境的配置

```shell
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
# 如果出现了问题，就需要使用 unset GO
```

# 4.1 数组

数组是具有固定长度且拥有零个或多个相同数据类型元素的序列

数组的长度是**固定**的，因此大多数用的是slice（切片）

```go
//	数组的建立
var arr1 [3]int
var arr2 [3]int = [3]int{1, 2, 3}
arr3 := [3]int{1, 2, 3}

//	返回数组的长度
length := len(arr1)

//	数组的长度由初始化数组的元素个数决定
arr4 := [...]int{1, 2, 3}

//	一种奇怪的定义方式
r := [...]int{99: - 1}	//	定义了一个拥有100个元素的数组r，除了最后一个元素值是-1外，该数组中的其他元素值都是0
```

默认情况下，一个新数组中的元素初始值为元素类型的零值

数组的长度是数组类型的一部分，所以`[3]int`和`[4]int`是两种不同的数组类型

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2 ,3 ,4}	//	错误的，类型不同不能赋值

//	因此，相同类型的数组才可以进行赋值和比较
a := [2]int{1, 2}
b := [...]int{1, 2}
fmt.Println(a == b)	//	类型相同的数组可以比较，不同的话就不行
```

如果把数组当做函数的参数进行传参的话，那么每个传入的参数都会是原数组的一个副本，而不是原始的数组参数

```go
//	如果想要传递原来的数组的话，就需要传递数组指针
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```





# 4.2 Slice

slice表示一个拥有相同类型元素的可变长度的序列，通常写为[]T

slice有三个属性：指针、长度和容量

指针指向数组的第一个可以从slice中访问的元素

长度是指slice中的元素个数

容量的大小通常是从slice的起始元素到底层数组的最后一个元素间元素的个数

内置函数len和cap用来返回slice的长度和容量

```go
//	slice的定义
var arr1 []int
arr2 := make([]int, 1, 1)	//	指定切片长度为1，容量为1
```

**一个底层数组可以对应多个slice**，这些slice可以引用数组的任何位置，彼此之间的元素还可以重叠

```cpp
var arr1 []int = []int{1,2,3,4,5,6,6,7,8}
//	使用操作符s[i:j]可以创建原slice的引用
s1 ：= arr1[1:2]	//	左开右闭，这里等价于原slice的部分引用
```

如果slice的引用超过了被引用对象的容量，即cap(s)，那么会导致程序宕机

但如果slice的引用超出了被引用对象的长度，即len(s)，那么最终slice会比原slice长

**由于slice包含的是数组元素的指针，所以将一个slice传递给函数的时候，可以去函数内部修改底层数组的元素**

```go
//	翻转切片数组
func reverse(s []int) {
    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

slice和数组的声明方式很像，但是slice是没有指定长度的

所以slice无法做比较，不能用==来测试两个slice是否拥有相同的元素

slice唯一允许的比较操作是和nil做比较，比如：

```go
if summer == nil {/*...*/}
//	值为nil的slice没有对应的底层数组，同时长度和容量都是零

//	以下slice的长度都是0
var s []int	//	s == nil
s = nil	//	s == nil
s = []int(nil)	//	s == nil
s = []int{}	//	s != nil
```

因此如果要判断一个slice是否为空，必须要用`len(s) == 0`，而不是`s == nil`

内置函数`make`可以创建一个具有指定元素类型、长度和容量的slice，其中容量参数可以省略

```go
arr1 := make([]int, 1)	//	长度len为1
arr2 := make([]int, 1， 3)	//	长度为1，容量为3
```



append函数

append用来将元素追加到slice的后面，并返回新的slice（好奇怪的用法）

```go
var ints []int
for i := 0; i < 10; i ++ {
    ints = append(ints, i)
}
```

如果slice的容量不够容纳增长的元素，``append`必须创建一个拥有足够容量的新的底层数组来存储新元素，然后将元素从slice x复制到这个新的数组中

同时将新元素y追加到数组后面

slice的扩容机制可以参考一下redis里面sds的扩容机制（前期按倍数扩容，后期按照固定大小扩容）

<br/>

因此，对于任何函数，只要有可能改变slice的长度或容量，抑或是使得slice指向不同的底层数组，都需要更新slice变量

<br/>

append也可以同时给slice添加多个元素