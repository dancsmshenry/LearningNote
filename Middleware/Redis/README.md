- redis的数据结构
  - 哈希表的扩容
  - 字符串，链表，集合，有序集合
- redis的哨兵
- 主从、哨兵和集群的部署方式，多个主库如何实现



跳表

- 为什么认为跳表相比b树更加适合高并发场景，因为
  - 我自己的理解是因为在新增节点时，跳表通过一个概率值来决定是否需要添加上层节点，实现起来，变化比较局部，不会有 B 树那样牵一发而动全身的变化，所以无论是加锁实现，还是无锁实现都对高并发支持更好。如果想要了解更多，请各位同学自行查阅。跳表的另一个优势在于实现中对于内存的需求相对于 B 树更少。可能这也是为什么内存数据库 MemSql 就支持跳表索引。其实跳表也有缺点，因为是用链表实现，所以对于缓存并不是很友好。另一个缺点是，要支持逆向查询，比如 (age < 40)，这就需要用双向链表实现，复杂度也会更高。





redis的优势，是开箱即用的cluster模式，丰富的数据结构
而多线程其实并没有提升多少（肯定是快的，因为能够上多核，但是瓶颈不在这
），因为它的bottleneck是在网络io上



redis的劣势是对于大key，持久化落盘会对性能有影响，所以要求value的大小不能超过150kb

