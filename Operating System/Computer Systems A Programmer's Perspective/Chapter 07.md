# 7.1 编译器驱动程序

- 编译器驱动程序：语言预处理器，编译器，汇编器和链接器
- 首先运行C预处理器，将main.c翻译成一个ASCII码的中间文件main.i
- 接着运行C编译器，将main.i翻译成一个ASCII汇编语言文件main.s
- 然后运行汇编器，将main.s翻译成一个可重定位目标文件main.o
- 最后运行链接器程序，将多个.o文件以及一些必要的系统目标文件组合起来，创建一个可执行目标文件
- 执行可执行目标文件
  - shell调用操作系统中一个叫做加载器的函数，它将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头





# 7.2 静态链接

- 静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出



链接器的两个任务

- 符号解析
  - 目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量
  - 目的是将每个符号引用正好和一个符号定义关联起来
- 重定位
  - 编译器和汇编器生成从地址0开始的代码和数据节
  - 链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置
  - 链接器使用汇编器产生的重定位条目的详细指令，执行重定位



- 目标文件纯粹时字节块的集合，这些块中有程序代码，有程序数据，其他的则包含引导链接器和加载器的数据结构
- 链接器将这些块链接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置





# 7.3 目标文件

- 可重定位目标文件：包含二进制代码和数据，可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件
- 可执行目标文件：包含二进制代码和数据，其形式可以被直接复制到内存并执行
- 共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到内存中并链接









# 7.7 重定位

- 符号解析之后，代码中的每个符号引用和正好一个符号定义关联起来
- 重定位：合并输入模块，并为每个符号分配运行时地址
  - 重定义节和符号定义：链接器将所有相同类型的节合并为同一类型的新的聚合节，然后将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号（此时程序中的每条指令和全局变量都有唯一的运行时内存地址）
  - 重定义节中的符号引用：链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址（依赖于可重定位目标模块中的重定位条目）



重定位条目

- 当汇编器生成一个目标模块时，它不知道数据和代码最终会在内存的什么位置，也不知道这个模块引用的任何外部定义的函数或者全局变量的位置
- 所以汇编器遇到对最终位置的目标引用，就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用
- 代码的重定位条目放在.rel，.text中，已初始化数据的重定位条目放在.rel，.data中





# 7.8 可执行目标文件

- <img src="ELF可执行目标文件.png" style="zoom:150%;" />
- 因为可执行文件是完全链接的，所以不需要.rel节







# 7.9 加载可执行目标文件

- ```shell
  ./prog
  ```

- shell会认为prog是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器的操作系统代码来运行它

- 任何Linux程序都可以通过调用execve函数调用加载器，加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序，这个将程序复制到内存并运行的过程叫做**加载**

- 每个linux程序都有一个运行时内存映像，代码段总时从地址0x400000处开始，后面是数据段

  - <img src="内存映像.png" style="zoom:150%;" />



- 当加载器运行时，在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段



- linux系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间，当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制
- 子进程通过execve系统调用启动加载器，加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段
- 新的栈和堆段都被初始化为零
- 通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件的内容（这一步可以认为是调整页表的指针方向）
- 最后加载器跳转到_strat地址，它最终会调用应用程序的main函数
- 在加载过程中，没有任何从磁盘到内存的数据复制，直到CPU引用一个被映射的虚拟页时才会进行复制，此时操作系统利用它的页面调度机制自动将页面从磁盘传送到内存





# 7.10 动态链接共享库

静态库的缺点

- 需要定期维护和更新
- 几乎每个C程序都是用标准IO函数，这些函数的代码会被复制到每个运行进程的文本段中，对稀缺的内存系统资源是一种浪费



- **共享库**是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程叫做**动态链接**，是由一个叫做**动态链接器**的程序来执行的
- 共享库也称为共享目标，在linux系统中通常用.so后缀来表示，微软的操作系统称为DDL（动态链接库）



- 在任何给定的文件系统中，对于一个库只有一个.so文件，所有引用该库的可执行目标文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行文件中
- 在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享



- <img src="动态链接共享库.png" style="zoom:150%;" />



- 基本思路：当创建可执行文件时，静态执行一些链接，然后再程序加载时，动态完成链接过程
- 此时没有任何libvector.so的代码和书局街真的被复制到可执行文件prog21中
- 反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对libvector.so中代码和数据的引用



动态链接的使用

- 当加载器加载和运行可执行文件prog2时，加载部分链接的可执行文件prog21
- 文件中的.interp节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标
- 加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器，然后动态链接器通过执行下面的重定位完成链接任务
  - 各种重定位
- 最后，动态链接器将控制传递给应用程序





# 7.11 从应用程序中加载和链接共享库

- 应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中
- 每个生成动态内容的函数打包在共享库中，当一个来自web浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用fork和execve在子进程的上下文中运行函数
- 函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求
- （有点像热更新了...）



- java定义了一个标准调用规则，叫做java本地接口，允许java程序调用本地的c/cpp函数
- 基本思想就是将本地c函数编译到一个共享库中（.so）
- 当一个正在运行的java程序试图调用函数foo时，java解释器利用dlopen接口动态链接和加载foo.so，然后再调用foo





# 7.12 位置无关代码

- 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码
- 一种不好的方法：每个共享库分配一个实现预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库
  - 缺点：浪费空间，并且对每个系统而言，库在内存中的分配都是不同的；每次库的修改必须确认已分配给它的片还适合它的大小
- 一种解决办法：使得无限多个进程可以共享一个共享模块的代码段的单一副本



- 可以加载而无需重定位的代码称为位置无关代码（PIC）
- 在一个x86-64系统中，对同一个目标模块中符号的引用时不需要特殊处理使之成为PIC
  - 可以用PC相对寻址来编译这些引用，构造文件时由静态链接器重定位



PIC数据引用（有点没看懂）

- 无论在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变
- 因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的
- 在数据段开始的地方创建一个表，叫做**全局偏移量表**（GOT）
- 每个被这个目标模块引用的全局数据目标都有一个8字节条目
- 编译器还为GOT中每个条目生成一个重定位记录
- 在加载时，动态链接器会重定位GOP中的每个条目，使得它包含目标的正确的绝对地址
- 每个引用全局目标的目标模块都有自己的GOT



PIC函数调用

- 





# 7.13 库打桩机制

- linux链接器支持库打桩，允许截获对共享库函数的调用，取而代之执行自己的代码





# 7.14 处理目标文件的工具







# 7.15 小结