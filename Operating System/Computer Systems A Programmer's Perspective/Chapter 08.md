# 8.1 异常

- 异常：控制流中的突变，用来响应处理器状态中的某些变化（感觉异常就是将控制权转移给其他逻辑流）
- 在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序），当异常处理程序完成处理后，根据引起异常的事件的类型，选择以下情况：
  - 处理程序将控制返回给当前指令，即当事件发生时正在执行的指令
  - 处理程序将控制返回给下一个指令，如果没有发生异常将会执行的下一条指令
  - 处理程序终止被中断的程序



8.1.1 异常处理

- 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号，其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核的设计者分配的
- 在系统启动时（当计算机重启或加电时），操作系统分配和初始化一张称为异常表的跳转表
  - 异常表时一张跳转表，其中表目k包含异常k的处理程序代码
- 异常表的起始地址放在一个叫做异常表基址寄存器中
- 异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限
- 一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成，在处理程序处理完事件之后，它通过执行一条特殊的”从中断返回“指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中



8.1.2 异常的类别

中断

- 来自处理器外部的I/O设备的信号的结果（例如网络适配器、磁盘控制器和定时器芯片）
- 硬件中断不是由任何一条专门的指令造成的，硬件中断的异常处理程序常常称为中断处理程序
- ![](中断.png)



陷阱和系统调用

- 陷阱是有意的异常，是执行一条指令的结果，就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令
- 用途：在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用
- ![](陷阱.png)



故障

- 由错误情况引起，可能被故障处理程序修正，当故障发生时，处理器将控制转移给故障处理程序
- 如果处理程序能够修正这个错误情况，就将控制返回到引起故障的指令
- 否则处理程序返回到内核中的abort例程，abort例程就会终止引起故障的应用程序
- 比如缺页异常
- ![](故障.png)



终止

- 是不可恢复的致命错误造成的结果，通常是一些硬件错误
- 终止处理程序从不将控制返回给应用程序



8.1.3 linux/x86-64系统中的异常





# 8.2 进程

- 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成的，这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合
- 抽象的进程
  - 提供一个独立的逻辑控制流
  - 一个私有的地址空间



8.2.1 逻辑控制流

- 逻辑控制流：程序计数器上的值（这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令）

- 进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程，对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占使用处理器
- 如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间，CPU好像会周期性停顿，然而每次处理器停顿，它随后会继续执行我们的程序，并不会改变程序内存位置或寄存器的内容



8.2.2 并发流

- 并发流：一个逻辑流的执行在时间上与另一个流重叠
- 并发：多个流并发执行的一般现象
- 多任务：一个进程和其他进程轮流运行的概念
- 时间片：一个进程执行它的控制流的一部分的每一时间段叫做时间片
- 并行流：两个流并发地运行在不同的处理器核或者计算机上



8.2.3 私有地址空间

- ![](进程地址空间.png)
- 尽管每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构
- 地址空间底部是保留给用户程序的，包括通常的代码，数据，堆和栈段
- 代码段总是从地址0x00400000开始
- 地址空间顶部保留给内核（操作系统常驻内存的部分）
- 地址空间的这个部分包含内核在代表进程执行指令时使用的代码



8.2.4 用户模式和内核模式

- 为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围
- 处理器通常是用某个控制寄存器中的一个**模式位**来提供这种功能，该寄存器描述了进程当前享有的特权



- 当设置了模式位时，进程就运行在**内核模式**中，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置



- 没有设置模式位时，进程就运行在**用户模式**中，用户模式中的进程不允许执行特权指令，比如停止处理器、改变模式位，或者发起一个I/O操作

  - 也不允许用户模式中的进程直接引用地址空间中内核区的代码和数据

  - 用户程序必须通过系统调用端口间接地访问内核代码和数据



- 运行应用程序代码的进程初始时是在用户模式中的，进程从用户模式变为内核模式的**唯一办法**是通过诸如中断、故障或者陷入系统调用这样的异常
- 当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式
- 处理器运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式



linux的一些实现

- /proc文件系统，允许用户模式进程访问内核数据结构的内容，/proc文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构



8.2.5 上下文切换

- 内核为每个进程维持一个上下文，上下文就是内核重新启动一个被抢占的进程所需的状态
  - 包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构
  - 比如描述地址空间的页表，包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表



- 调度：在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程
  - 是由内核中称为调度器的代码处理的
  - 当内核选择一个新的进程运行时，我们说内核调度了这个进程
- 在内核调度了一个新的进程后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程



步骤

- 保存当前进程的上下文
- 恢复某个先前被抢占的进程被保存的上下文
- 将控制传递给这个新恢复的进程



- 内核代表用户执行系统调用时，可能发生上下文切换
- 如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换进程



中断也可能引发上下文切换

- 比如：所有系统都有某种产生周期性定时器中断的机制，通常每1毫秒或每10毫秒
- 每次发生定时器中断时，内核就能判定当前进程已经运行了足够时间，并切换到一个新的进程





# 8.3 系统调用错误处理

- 封装unix系统函数





# 8.4 进程控制

8.4.1 获取进程ID

- pid getpid(void);，返回调用进程的PID
- 每个进程都有一个唯一的正数（非零）进程ID（PID）



8.4.2 创建和终止进程

- 进程的三种状态：
- 运行：进程要么在CPU上执行，要么在等待被执行且最终会被内核调度
- 停止：进程的执行被挂起，且不会被调度（当收到SIGCONT信号后再次开始执行）
- 终止：进程永远地停止，原因：
  - 收到一个信号，该信号的默认行为是终止进程
  - 从主程序返回
  - 调用exit函数



- 父进程通过调用fork函数创建一个新的运行的子进程
- 新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的一份副本，包括代码和数据段、堆、共享库以及用户栈
- 子进程与父进程任何打开文件描述符相同的副本，意味着子进程可以读写父进程中打开的任何文件
- 父子进程不同的就是PID不同



- fork函数第一次返回实在调用进程（父进程）中，一次是在新创建的子进程中
- 父进程中返回的是子进程的PID，子进程返回的是0（PID不是0）



- 父子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流中的指令



- 相同但是各自独立的地址空间
- 共享文件



8.4.3 回收子进程

- 当一个进程由于某种原因终止时，进程保持在一种已终止的状态中，直到被它的父进程挥手
- 当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程
- 僵尸进程：一个终止了但还未被回收的进程



- 如果一个父进程终止了，内核会安排init进程称为它的孤儿进程的养父
- 如果父进程没有回收它的僵尸进程就终止了，那么内核会安排init进程去回收它们



- 一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止
- 也可以用它的简化版wait



8.4.4 让进程休眠

- sleep函数将一个进程挂起一段指定的时间
- pause函数让调用函数休眠，直到该进程收到一个信号



8.4.5 加载并运行程序

- execve函数在当前进程的上下文中加载并运行一个新的程序
- main函数的三个参数
  - argc，它给出argc[]数组中非空指针的数量
  - argv，指出argv[]数组中的第一个条目
  - envp，指向envp[]数组中的第一个条目



- 程序是一堆代码和数据，程序可以作为目标文件存在于磁盘上，或者作为段存在地址空间中
- 进程是执行中程序的一个具体的实例，程序总时运行在某个进程的上下文中
- fork函数在新的子进程中运行相同的程序，新的子进程是父进程的复制品
- execve函数在当前进程的上下文加载并运行一个新的程序，它会覆盖当前进程的地址空间，但并没有创建一个新的进程
  - 新的程序仍然由相同的PID，并且继承了调用execve函数时已打开的所有文件描述符



# 8.5 信号

- linux信号，允许进程和内核中断其他进程
- 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件
- 低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是看不到的
- ctrl+c对应的是SIGINT信号



8.5.1 信号术语

- 发送信号：内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程
- 两个原因：
  - 内核检测到一个系统事件，比如除零错误或者子进程终止
  - 一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程
- 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号
  - 进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序的用户层函数捕获这个信号
  - ![](信号处理.png)



8.5.3 接收信号

- 当内核把进程p从内核模式切换到用户模式时，它会检查进程p的未被阻塞的待处理信号的集合
- 如果这个集合为空，那么内核将控制传递到p的逻辑控制流中的下一个指令
- 否则，那么内核选择集合中的某个信号k，并且强制p接收信号k
- ![](信号套娃.png)



# 8.6 非本地跳转



# 8.7 操作进程的工具



# 8.8 小结
