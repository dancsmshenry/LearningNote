# 第3章 进程管理

## 3.1 进程

- 进程的概念
  - 是处于执行期的程序
  - 是正在执行的程序代码的实时结果
- 线程，是在进程中活动的对象
  - 每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器
  - 内核调度的对象是线程
  - 在Linux张，线程就是进程
- 进程提供的两种虚拟机制：虚拟处理器和虚拟内存
- 程序本身并不是进程，进程是处于执行期的程序以及相关的资源的总称
- fork()：通过复制一个现有进程来创建一个全新的进程，父子进程（由clone()系统调用实现）
- exec()：创建新的地址空间，并把新的程序载入其中
- exit()系统调用退出执行，终结进程并将其占用的资源释放掉



## 3.2 进程描述符及任务结构

- 内核把进程的列表存放在任务队列的双向循环链表中，每一项都是类型为task_struct，称为进程描述符

- 进程描述符的存放

  - 内核通过一个唯一的进程标识值或PID来标识这个进程（实际上是int类型）
  - pid默认max为32768，可以修改（例：一些大型服务器）
  - 在内核中，可以通过current宏查找当前正在运行进程的pid

- 进程状态

  - TASK_RUNNING，运行，进程是可执行的，或者正在执行，或者在运行队列中等待
  - TASK_INTERRUPTIBLE，可中断，进程正在睡眠（被阻塞），等待某些条件的达成（等待io）
  - TASK_UNINTERRUPTIBLE，不可中断，除了就算是接收到信号也不会被唤醒或准备投入运行外，与可打断状态相同
  - _TASK_TRACES，被其他进程跟踪的进程
  - _TASK_STOPPED，停止，进程停止执行

- 设置当前进程状态

  - ```c
    set_task_state(task, state);/*将任务task的状态设置为state*/
    set_current_stae(state);/*等价*/
    task->state = state;
    ```

- 进程上下文

- 进程家庭树

  - 所有的进程都是pid为1的init进程的后代，内核在系统启动解读那的最后阶段启动init进程

  - 系统中的每个进程必有一个父进程，每个进程可以拥有零个或多个子进程

  - 每个task_struct都包含一个指向其父进程tast_struct，叫做parent的指针，还包含一个称为children的子进程链表

  - ```c
    /*指向init进程*/
    struct task_struct *task;
    for (task = current; task != &init_task; task = task -> parent);
    
    /*获取链表中的下一个进程*/
    list_entry(task->tasks.next, struct task_struct, tasks)
    ```



## 3.3 进程创建

- 进程的产生分为fork()和exec()两个函数
  - fork()通过拷贝当前进程创建一个子进程，子进程与父进程仅仅在pid、ppis和一些边边角角不一样
  - exec()函数负责读取可执行文件并将其载入地址空间开始运行
- 写时拷贝（copy-on-write，COW）
  - 写时拷贝，内核此时宾补复制整个进程地址空间，而是让父子进程共享同一个拷贝（读写方式共享）
  - 只有在需要写入的时候，数据才会被复制
  - fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符
- fork()
  - fork()调用clone()，clone()调用do_fork()，do_fork()调用copy_process()
  - 