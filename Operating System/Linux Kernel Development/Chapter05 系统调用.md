# 与内核通信

- 系统调用在用户空间进程和硬件设备之间添加了一个中间层
- 主要有三个作用：
  - 为用户空间提供了一种硬件的抽象接口，不管硬件层是如何实现的，只管使用接口得到结果即可
  - 系统调用保证了系统的稳定和安全（内核可以基于权限、用户类型和其他一些规则对需要进行的访问进行裁决，有点类似权限控制，资源控制一样）
  - 每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口



# API、POSIX和C库

- 应用程序通过在用户空间实现的API而不是系统调用来编程
- ![](image/api，posix和c库.png)



# 系统调用

- 系统调用用一个负的返回值表示错误，返回一个0通常表明成功
- 系统调用在出现错误的时候C库会把错误码写入error全局变量，通过调用perror函数，可以把该变量翻译为用户可以理解的错误字符串



定义一个系统调用

- asmlinkage，这是一个编译指令，通知编译器仅从栈中提取该函数的参数
- 所有的系统调用都需要这个限定词
- 其次，函数返回long
  - 为了保证32位和64位系统的兼容，系统调用在用户空间和内核空间有不同的返回值类型，在用户空间位int，在内核空间为long
- 系统调用函数前都会加上sys_的标记，这是linux中所有系统调用都应该遵循的命名规则



系统调用号

- 在linux中，每个系统调用被赋予一个系统调用号，这样通过这个独一无二的号就可以关联系统调用，当用户空间的进程执行一个系统调用时，这个系统调用号就用来指明到底是要执行哪个系统调用
- 进程不会提及系统调用的名称
- 如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用；否则以前编译过的代码就会调用这个系统调用，但事实上却调用的时另一个系统调用

- 内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在sys_call_table中



系统调用的性能

- linux系统调用比其他许多操作系统执行得要快，linux很短得上下文切换时间是一个重要原因；另一个原因是系统调用处理程序和每个系统调用本身也都很简洁



# 系统调用处理程序

- 用户空间无法直接执行内核代码，因为内核驻留在受保护得地址空间上
- 因此应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用
- 通知内核的机制是靠**软中断**实现的，通过引发一个异常来促使系统切换到内核态去执行异常处理程序，此时的异常处理程序实际上就是系统调用处理程序
- 在x86系统上预定义的软中断是中断号128，通过int 0x80指令触发该中断
  - 这条指令会触发一个异常导致系统切换到内核态并执行128号异常处理程序，而该程序正是系统调用处理程序
  - 名为system_call，x86-64的系统上在enrty_64.S文件中用汇编语言编写
- x86新加了一条sysenter的指令，能够更快的陷入内核执行系统调用的方式



指定恰当的系统调用

- 陷入内核空间是不够的，还要把**系统调用号**一并传给kernel
- 在x86上，系统调用号是通过**eax寄存器**传递给内核的
- 在陷入内核之前，用户空间就把相应系统调用号放在eax中



参数传递

- 发生内核态陷入时，要把外部参数从用户空间传入给内核
- 方法类似系统调用号，也是吧参数放在寄存器上
- 在x86-32上，ebx，ecx，edx，esi和edi按照顺序存放前五个参数
- 还需要用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针



# 系统调用的实现

实现一个新的系统调用

- 需要考虑系统调用的参数，返回值和错误码



函数参数验证

- 检验参数是否合法
- 比如说检查用户提供的指针是否有效
- 内核必须保证：
  - 指针指向的内存区域属于用户空间，进程不能哄骗内核去读内核空间的数据
  - 指针指向的内存区域在进程的地址空间里，不能哄骗内核去读其他进程的数据
  - 如果是读，该内存应被标记位可读；如果是写，该内存应被标记为可写，进程决不能绕过内存访问
- kernel提供了两种方法来完成必须的检查和内核空间和用户空间之间数据的拷贝
  - 为了向用户空间写入数据，提供了copy_to_user
  - 为了从用户空间读取数据，提供了copy_from_user
- 还有一个就是权限的检查，有些函数只能由超级用户权限才能用





# 系统调用上下文

- 当系统调用返回时，控制权仍然在system_call()中，它会最终切换到用户空间，并让用户进程继续执行下去



- 直接的系统调用用户空间是无法使用的，所以需要linux本身提供的一组宏，用于直接对系统调用进行访问，它会设置好寄存器调用陷入指令，这些宏就是_syscalln()