背景：

- 处理器的速度和外圈硬件设备的速度往往不在一个数量级上（因此内核就应该在此期间处理其他事务，等到硬件真正完成了请求的操作之后，再回过头来对它进行处理）
- 问题转化为：让处理器和外部设备协同工作，而不降低机器的性能
- 轮询吗（可能会做一些无用功，而dpdk就是在用户态轮询网卡...；可能kernel认为轮询不适合一般的情况吧）
- 因此选择的就是，让硬件在需要的时候再向内核发出信号，即**中断机制**



# 7.1 中断

- 中断使得硬件得以发出通知给处理器

- 中断本质是一种特殊的电信号，由硬件设备发向处理器，处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统负责处理这些新到来的数据
- 中断是随时发生的，**不考虑**与处理器的时钟同步



- 中断控制器是个简单的电子芯片，作用是将多路中断管线，采用复用技术只通过一个和处理器相连接的管线与处理器通信
- 当接收到一个中断后，中断控制器会给处理器发送一个电信号，处理器一经检测到此信号，便中断自己的当前工作转而处理中断



- 不同的设备对应的中断是不同的，每个中断都通过一个唯一的数字标志
- 这些中断值被称为中断请求线（IRQ）



- **异常**与中断不同，异常产生时必须要考虑与处理器时钟同步，因此也被称为**同步中断**
- 例如：处理器执行到由于编程失误而导致的错误指令（如被0整除）的时候
- 即处理器产生一个异常，给kernel对其进行处理
- 特殊的异常：在x86体系结构上通过软中断实现系统调用，即陷入内核，**系统调用处理程序异常**





# 7.2 中断处理程序

- 在响应一个特定中断，内核执行的函数



- 中断处理程序与其他内核函数的区别：中断处理程序是被内核调用来响应中断的，运行于中断上下文



- 设计的两个思考：操作系统能够迅速对中断进行服务，也要让中断处理程序在尽可能短的时间内完成运行







# 7.3 上半部与下半部的对比

- 矛盾：中断处理程序运行得快，中断处理程序完成得工作量多
- 所以把中断处理切为两个部分：
  - 中断处理程序是上半部：接收到一个中断，立即开始执行，但只做有严格时限的工作，例如对接收的中断进行应答或复位硬件，这些工作都是在所有中断被禁止的情况下完成的
  - 能够被允许稍后完成的工作会被推迟到下半部







# 7.4 注册中断处理程序

- 中断处理程序是管理硬件的驱动程序的组成部分，每一设备都有相关的驱动程序，如果设备使用中断，那么相应的驱动程序就要注册一个中断处理程序



- 驱动程序可以通过request_inq()函数注册一个中断处理程序，并且激活给定的中断线，以处理中断
- 后面都是说request_inq的细节，略





# 7.5 编写中断处理程序

- linux中的中断处理程序是无须重入的，当一个给定的中断处理程序正在执行时，相应的中断线在所有处理器上都会被屏蔽掉，以防止在同一中断线上接收另一个新的中断
- 通常，所有其他的中断都是打开的，所以这些不同中断线上的其他中断都能被处理，但当前中断线总是被禁止的





# 7.6 中断上下文

- 中断上下文不可以睡眠，，