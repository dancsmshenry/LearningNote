本节引入了16进制

- 即在原来的0-9的基础上，加上了a b c d e f



再回到原来的int中，一个int就可以用8个16进制的数来表示了

- PS：十六进制数最前面要加上一个0X
- 所以，0Xfffffffff就表示-1
- 0X7fffffff就表示2147483647，即当前最大的正整数



printf的参数

- %d，表示输出的是十进制的数
- %x，表示输出得是十六进制的数字



门电路

- 非，或，与
- ~a
- a & b
- a | b

segment array（树状数组）



获取一个数字的最后一个1

- num & (~num - 1)（前面是取反操作）
- 证明：
  - 原来的数字为aaa1，取反后为bbb0，取反后再加一为bbb1
  - 再对这两个数进行与运算，那么此时因为a和b是相互取反的，所以与操作后为0，而最后一个1和0进行与操作，得到的就是1
  - 如果原来的数字是aaa100，那么取反后得到的就是bbb011，再对其加一得到bbb100，所以

- 所以写了个函数名为lowbit



由此引申出一个**树状数组**的概念（参考lc 307）

- 一开始觉得树状数组求前缀和有点多余，但是发现，树状数组的好处，是可以随时修改数组的元素，而以最小的代价维护当前的前缀和



还有一个算法，求证一个十六进制数里面，是否存在位是字母的

- 算法好像是用卡诺图做的，有点难理解，后续要好好看看