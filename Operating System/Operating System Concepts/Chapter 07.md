# 7.2 死锁特征

## 7.2.1 必要条件

- 如果在一个系统中以下四个条件同时成立，那么就能引发死锁：

- **互斥**：至少有一个资源必须处于非共享模式，即**一次只有一个进程可使用**。如果另一进程申请该资源，那么申请进程应等到该资源释放为止
- **占有与等待**：**一个进程应占有至少一个资源，并等待另一个资源**，而该资源为其他进程所占有
- **非抢占**：资源不能被抢占，即**资源只能被进程在完成任务后资源释放**
- **循环等待**：有一组进程{P0,P1,P2,...}等待的资源为P1占有，P1等待的资源被P2占有，Pn-1等待的资源被Pn占有，Pn等待的资源为P0占有



## 7.2.2 资源分配图

- 通过**系统资源分配图**的有向图可以更精确地描述死锁
- 该图包括一个节点集合V和一个边集合E
  - 节点集合分为P（系统所有活动进程的集合），R（系统所有资源类型的集合）
  - 每一个有向边PI指向Rj，都代表某进程Pi申请了资源Rj，并且正在等待这个资源
  - 反之则是某个进程Pi拥有了资源Rj
- 如果上述分配图没有环，那么系统进程就没有死锁；如果分配图有环，那么**可能存在死锁**







# 7.3 死锁处理方式

三种方法：

- 通过协议来预防或避免死锁，确保系统不会进入死锁状态
- 可以允许系统进入死锁状态，然后检测它，并加以恢复
- 可以忽视这个问题，认为死锁不可能在系统内发生



- 死锁预防：确保至少有一个必要条件不成立
- 死锁避免：操作系统先得到有关进程申请资源和使用资源的额外信息，有了这些额外信息，系统可以确认：对于每个申请，进程是否应该等待
- 如果系统不使用死锁预防或死锁避免算法，那么系统提供一个算法来检查系统状态以确定死锁是否发生







# 7.4 死锁预防

- 确保至少一个死锁的必要条件不成立



## 7.4.1 互斥

- 可，发生死锁互斥是必须成立的
- 如果是只读文件这种，是不可能死锁的



## 7.4.2 持有且等待

- 保证：当每个进程申请一个资源时，它不能占有其他资源，有两种解决办法：	
  - 每个进程在执行前申请