# 6.1 背景

三个要求

- 互斥：如果Pi在其临界区内执行，那么其他进程都不能在其临界区内执行
- 进步：如果没有进程在其临界区内执行，并且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可以参加选择，以便确定谁能下次进入临界区，而且这种选择不能延迟（啥意思？？）
- 有限等待：从一个进程做出进入临界区的请求直到这个请求允许为止，其他进程允许进入其临界区的次数具有上限



# 6.2 临界区问题

- 临界区：当一个进程在临界区执行时，其他进程不允许在它们的临界区内执行，也就是说没有两个进程可以在它们的临界区内同时执行（每个进程都有一段代码，称为临界区）
- 在进入临界区前，每个进程应请求许可，实现这一请求的代码区就是进入区
- 临界区退出之后有退出区
- 其他代码称为剩余区



临界区问题的解决方案需要满足以下三个条件：

- 互斥：如果进程Pi在其临界区内执行，那么其他进程都不能在其临界区内执行
- 进步：如果没有进程在其临界区内执行，并且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可以参加选择，以便确定谁能下一次进入临界区，而且这种选择不能被无限推迟
- 有限等待：从一个进程做出进入临界区的请求直到这个请求允许为止，其他进程允许进入其临界区的次数具有上限



两种常用方式解决操作系统的临界区问题：

- 抢占式内核：允许处于内核模式的进程被抢占
- 非抢占式内核：不允许处于内核模式的进程被抢占
- 处于内核模式运行的进程会一直运行，直到退出内核模式、阻塞或资源放弃CPU控制
- 抢占式更适合实时编程





# 6.3 Peterson 解决方案



# 6.4 硬件同步

- 对于单处理器环境，在修改共享变量的时候只要禁止中断出现，这样就能确保当前指令流可以有序执行，且不会被抢占
  - 由于不可能执行其他指令，所以共享变量就不会被意外地修改
- 但多处理器是不行的，因为多处理器的中断禁止会很耗时，因为消息要传递到所有处理器，消息传递会延迟进入临界区，并降低小童效率





# 6.5 互斥锁

- 互斥锁：一个进程在进入临界区时应得到锁；它在退出临界区时释放锁

- ```cpp
  void acquire() {
      while (!available) ;
      available = false;//如果锁时可用的，那么调用acquire就会成功
  }
  
  //available应该是全局变量
  
  void release() {
      available = true;
  }
  ```

- 缺点：忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须循环调用acquire()，其实这种类型的互斥锁也被称为自旋锁，因为进程不停地旋转，以等待锁变得可用

- 优点：当进程在等待锁时，没有上下文切换，所以当使用锁的时间较短的时候，自旋锁还是比较有用的





# 6.6 信号量



# 6.7 经典同步问题



# 6.8 管程



# 6.9 同步例子



# 6.10 替代方法