### 第3章 进程

- 进程的组成

  - 文本段（代码段）
  - 程序计数器的值和处理器寄存器的内容
  - 进程堆栈（包括临时数据，如函数参数，返回地址和局部变量）
  - 数据段（包括全局变量）

- 进程是活动实体，具有一个程序计数器用于表示下一个执行命令和一组相关资源

- 进程的状态

  - 新的（new）：进程正在创建
  - 运行（running）：指令正在执行
  - 等待（waiting）：进程等待发生某个事件（如I/O完成或收到信号）
  - 就绪（ready）：进程等待分配处理器
  - 终止（terminated）：进程已经完成执行

- 操作系统的每个进程都用进程控制块表示（Process Control Block，PCB），也成为任务控制块（task control block）

  - 进程状态
  - 程序计数器（计数器表示进程将要执行的下一个指令的地址）
  - CPU寄存器（包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码信息寄存器，在发生终端的时候，这些状态信息与程序计数器一起需要保存，一遍进程正确地继续执行）
  - CPU调度信息（进程优先级，调度队列的指针和其他调度参数）
  - 内存管理信息（根据操作系统使用的内存系统，这类信息可以包括基地址和其他参数）
  - 记账信息（CPU时间，实际使用时间，时间期限，记账数据，作业或进程数量）
  - I/O状态信息（分配给进程的I/O设备列表，打开文件列表）

- Linux操作系统的进程控制块采用C语言结构task_struct来表示，它位于内核源码的头文件<linux/sched.h>（包含了所有的信息）

- 父进程（为创建它的进程），子进程（为它本身创建的进程），兄弟进程（具有同一个父进程的进程）

- 就绪队列：驻留在内存中的，就绪的，等待运行的进程保存在的队列（用链表实现，其头结点有两个指针，用于指向链表的第一个和最后一个PCB块）

- 设备队列

- 当进程分配到CPU执行的时候，可能发生一下事情：

  - 进程可能发出I/O请求，并被放到I/O队列
  - 可能创建一个新的子进程，并等待其终止
  - 可能由于中断而被强制释放CPU，并被放到就绪队列

- 长期调度程序/作业调度程序（在保存了大量进程的大容量存储设备的缓冲池中选择进程，加入到内存中），因为进程的创建速度慢，效率不高

- 短期调度程序/CPU调度程序（从准备执行的进程中选择进程，并分配给CPU），因为进程的执行速度快，所以短期的执行效率也要高

- I/O密集型进程：执行I/O比执行计算需要花费更多时间

- CPU密集型进程：更多时间执行计算

- 中期调度程序：可将进程从内存中移出，从而降低多道程序调度（之后，进程可被重新调入内存，并从终端处继续执行）

- 上下文切换：切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态

  - 当中断发生时，系统需要保存当前运行在CPU上的进程的上下文，以便在处理后能够恢复上下文，即先挂起进程，再恢复进程
  - 进程上下文使用PCB来表示 

- 进程树

- Linux的进程

  - 进程一般用pid来表示
  - 进程init作为所有用户进程的根进程或父进程

- 父进程可能向子进程传递初始化数据

- 当进程创建新进程时候

  - 可有两种执行操作：父进程与子进程并发执行     or    父进程等待，直到某个或全部子进程执行完
  - 地址空间也有两种可能：子进程是父进程的复制品（它具有与父进程同样的程序和数据）           or             子进程加载另一个程序

- 通过UNIX系统调用fork()来创建一个单独进程

  - ```c
    #include <sys/types.h>
    #include <stdio.h>
    #inlcude <unistd.h>
    
    int main(){
        pid_t pid;
        pid = fork();//fork a child process
        
        if (pid < 0){//erroe occurred
            fprintf(stderr, "Fork Failed");
            return 1;
        }else if (pid == 0){//is child process
            execlp("/bin/ls", "ls", NULL);//exec的一个版本
        }else{//is parent process
            wait(NULL);
            printf("Child Completa");
        }
        
        return 0;
    }
    ```

- 浅析fork调用

  - 用于创建新进程
  - 新进程的地址空间复制了原来进程的地址空间，使得父进程和子进程轻松通信
  - 对于新进程，系统调用fork()的返回值为0；而对于父进程，返回值为子进程的进程标识符

- 只有终止进程的父进程才可以执行系统调用终止该进程

- 父进程终止子进程的原因：

  - 子进程使用了超过它所分配的资源
  - 分配给子进程的任务，不再需要
  - 父进程正在退出，而且操作系统不允许无父进程的子进程继续执行

- 级联终止：如果一个进程终止，那么它的所有子进程也应终止

- 背景：当一个进程终止时，操作系统会释放其资源，不过它位于进程表的条目还是在的，直到它的父进程调用wait()

  - 僵尸进程：当进程已经终止，但是其父进程尚未调用wait()
  - 孤儿进程：如果父进程没有调用wait()就终止，以致于子进程成为孤儿进程

- 协作：如果一个进程能影响其他进程或受其他进程影响，那么该进程就是协作的

- 进程通信的两种基本模型：共享内存（建立起一块供协作进程共享的内存区域）和消息传递（在协作进程间交换消息来实现通信）

- 生产者-消费者问题：

  - 生产者进程生成信息，消费者进程消费信息
  - 解决办法：采用共享内存

- 共享内存：

  - 为了允许生产者进程和消费者进程并发执行，应有一个缓冲区
  - 无界缓冲区（没有限制缓冲区的大小），有界缓冲区（假设固定的缓冲区）
  - 有界缓冲区的实现：两个指针，in和out

- 消息传递系统：

  - 直接通信：send(P,message)和receive(Q,message)
    - 在需要通信的每对进程之间，自动建立链路，进程仅需直到对方身份就可进行交流
    - 每个链路只与两个进程相关
    - 每对进程之间只有一个链路
    - 发送和接收进程必须指定对方，以便通信（或只要发送方指定接收者，而接收者不需要指定发送者）
  - 间接通信：通过邮箱或端口来发送和接受消息（send(A,message)，receive(A,message)）
    - 一个进程可以通过多个不同邮箱与另一个通信，但是两个进程只拥有一个共享邮箱时才通信
    - 只有在两个进程共享一个邮箱时，才能建立通信链路
    -  一个链路可以与两个或更多进程相互关联
    - 两个通信进程之间可有多个链路，每个链路对应于一个邮箱
    - 邮箱可以分为进程所有或操作系统所有
  - 消息传递分为阻塞和非阻塞，即同步和非同步
    - 阻塞：发送（接受）进程阻塞，直到消息由接收进程或邮箱所接受（信息可用）
    - 非阻塞：发送进程发送消息，并且恢复操作
  - 缓存：
    - 零容量：队列的最大长度为0，因此链路中不能有任何消息处于等待
    - 有限容量：队列长度为有限n，因此最多只能由n个消息驻留其中（如果链路已满，发送者应该阻塞，直到队列空间有可用的为止）
    - 无线容量：队列长度无限长，不管多少消息都可在其中等待

- 客户机/服务器通信

  - 套接字
    - 每个套接字由一个IP地址和一个端口号组成
    - 服务器通过监听指定端口，来等待客户请求，服务器在收到请求后，接收来自客户套接字的连接，从而完成连接
    - Java的三种不同类型的套接字：面向对象的TCP套接字，无连接的UDP套接字，MulticastSocket类
    - 是一种低级形式的通信，套接字只允许在通信线程之间交换无结构的字节流
  - 远程过程调用（RPC）
    - RPC允许客户调用位于远程主机的过程，就如调用本地过程一样，通过客户端提供的存根，RPC系统隐藏通信细节
    - 以下几个细节需要注意：
    - 客户机和服务器系统的不同数据的表示，大端结尾和小端结尾
    - 有可能会调用失败，所以需要保证每个消息执行正好一次
  - 管道
    - 普通管道
      - 生产者向管道的一段写入，消费者从管道的另一端读出



### 第4章 多线程编程





### 第6章 同步

- 临界区问题
  - 三个要求
    - 互斥：如果Pi在其临界区内执行，那么其他进程都不能在其临界区内执行
    - 进步：如果没有进程在其临界区内执行，并且有进程需要进入临界区，那么只有那些不在剩余区内执行的进程可以参加选择，以便确定谁能下次进入临界区，而且这种选择不能延迟（啥意思？？）
    - 有限等待：从一个进程做出进入临界区的请求直到这个请求允许为止，其他进程允许进入其临界区的次数具有上限