# 第二章 编译和链接



## 2.1 被隐藏了的过程

- 代码的编译分为以下四个步骤：预处理，编译，汇编，链接
- 预编译
  - 将所有的“#define”删除，并且展开所有的宏定义
  - 处理所有条件预编译指令，比如“#if”、“#ifdef”
  - 处理“#include”预编译指令，将被包含的文件插入到该预编译指令的位置（这个过程可能是递归执行的，被包含的文件可能还包含其他文件）
  - 删除所有的注释“//”和“/**/”
  - 添加行号和文件名标识，比如#2“hello.c”，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号
  - 保留所有的#pragma编译器指令（编译器需要使用）
  - ps：得到文件名为.ii或.i，不包含任何宏定义
- 编译
  - 把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件
  - ps：得到的文件名为.s
- 汇编
  - 将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令，只是根据汇编指令和机器指令的对照表一一翻译即可
  - ps：得到的文件名为.o
- 链接
  - 把文件链接起来可以得到“a.out”



## 2.2 编译器做了什么

- 编译过程分为六个步骤：扫描，语法分析，语义分析，源代码优化，代码生成和目标代码优化
- 词法分析（扫描）
  - 源代码程序被输入到扫描器，进行词法分析，运用一种类似于有限状态机的算法将源代码的字符序列分割成一系列的记号
- 语法分析
  - 对产生的记号进行语法分析，从而产生语法树
  - 由语法分析器生成的语法树就是以表达式为节点的树
- 语义分析
  - 前提：语法分析仅仅是完成了对表达式的语法层面的分析，但不了解这个语句是否真正有意义
  - 比如：C里面，两个指针做乘法运算是没有意义的，但是这个语句在语法上是合法的
  - 静态语义：编译器所能分析的，在编译器可以确定的语义
  - 动态语义：只有在运行器才能确定的语义
  - 语法分析的过程：浮点型的表达式赋值给一个整型的表达式时，其中隐含的一个浮点型到整型转换的过程；而如果语义分析程序发现类型不匹配，就会报错
  - ps：感觉就是检查语义上是否符合要求，类型转换是否有错误之类的
- 中间语言生成
  - 背景：源码级优化器，会在源代码级别进行优化，但是实际有优化上很困难，所以源代码优化器往往将整个语法树转换成中间代码
  - 比较常见的中间代码：三地址码，P-代码
  - 中间代码使得编译器可以分为前端和后端，编译器前端负责产生机器无关的中间代码，编译器后端负责将中间代码转换成目标机器代码
- 目标代码生成与优化
  - 背景：中间代码标志着之后的过程都属于编译器后端，后端包括代码生成器和目标代码优化器
  - 代码生成器：将中间代码转换成目标机器代码（由于字长、寄存器、整数数据类型等，对目标机器十分依赖）
  - 目标代码优化器：对上述生成的代码进行优化
- PS：以上的操作都是进行代码层面的优化，但是都没有涉及到真正的内存地址的部分



## 2.3 链接器比编译器长

- 机器语言->汇编语言->高级语言
- 背景：面对大型工程，程序被分割成多个模块；模块之间的通信需要解决的两个问题，模块间的函数调用，模块间的变量访问
- 而这种模块之间的拼接过程便是链接（Linking）



## 2.4 模块拼装—静态链接

- 链接过程主要包括了地址和空间分配、符号决议和重定位等步骤
- 当跨模块调用函数的时候，编译器是不知道其他模块的某个函数的地址的，所以需要用链接器，因为链接器在链接的时候，会根据你所引用的符号foo，自动的去相应的模块去查找具体函数的地址，然后到main文件中对该函数的指令进行修正
- 重定位的背景：由于在编译目标文件的时候不知道某个变量的地址，所以编译器在没法确定地址的情况下，将这条mov指令的目标地址置为0，等待链接器在将目标文件A和B链接起来再将其进行修正
- 重定位：这个地址修正的过程叫做重定位，每个要被修正的地方叫一个重定位入口，所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址



## 2.5 本质小结

- 程序源代码 -> 最终可执行文件的4个步骤：预编译，编译，汇编，链接
- 编译的步骤：词法分析、语法分析、语义分析、中间代码生成、目标代码生成与优化





- 