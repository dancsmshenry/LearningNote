# 并发编程的两种模型

- message passing
- shared memory



# 线程同步的四项原则

- 首要原则是尽量最低限度地共享对象，减少需要同步的场合
  - 一个对象能不暴露给别的线程就不要暴露
  - 优先考虑immutable对象
  - 实在不行才暴露可修改的对象，并用同步措施来充分保护它
- 使用高级的并发编程构件：TaskQueue，Producer-Consumer Queue，CountDownLatch等
- 最后不得已必须使用底层同步原语时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量
- 除了使用atomic整数之外，不自己编写lock-free代码，也不要用内核级同步原语，不凭空猜测"哪种做法性能会更好"







可重入与不可重入mutex

- 可重入mutex：某个线程已经获得某个mutex，可以在其获取该mutex而不会出现死锁



死锁很大原因是拿锁的方向出现了问题：如果大家拿锁都遵守同一个规则，就可以解决大部分dead mutex的问题



dead lock的2种：

- 同一个线程拿2次锁
- 拿锁的顺序出现了问题