# 背景

- CPU的工作原理
- 控制单元要取下一条待运行的指令，该指令的地址在程序计数器 PC 中，在 x86CPU 上，程序计数器就是 cs： ip。于是读取 ip 寄存器后，将此地址送上地址总线， CPU 根据此地址便得到了指令，并将其存入到指令寄存器 IR 中
- 这时候轮到指令译码器上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应操作数从内存中取回放入自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程
- 操作码有了，操作数也齐了，操作控制器给运算单元下令，开工，于是运算单元便真正开始执行指令了
- ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址



# 保护模式

- 是相对于实模式而言的,它首次出现是在Intel 80286 CPU中首次出现的，紧跟着8086，为了克服在实模式下的种种问题，处理器厂商开发出保护模式，这样，物理地址不能直接被程序访问，程序内部的地址（虚拟地址）需要被转化成物理地址之后再去访问，程序对此一无所知，它只需要老老实实运行就是





# 实模式

- 实模式是指8086CPU的寻址方式，寄存器大小，指令用法等，是用来反应CPU在该环境下如何工作的概念
- “实”体现在程序中用到的地址都是真实的物理地址，“段基址:段内偏移地址”产生的逻辑地址就是物理地址，即程序员可见的地址完全是真实的内存地址
- 段地址+偏移地址=物理地址



缺点

- 实模式下操作系统和用户程序属于同一特权级，没有区别对待
- 用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地指哪打哪
- 用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住
- 总结：不安全



# 区别

- 实模式可以直接访问物理地址；保护模式下不是你想访问哪个物理地址就能访问哪个物理地址，要通过分页，GDT等来进行间接访问
- 实模式没有特权级的概念，人人都可以占山为王，攻伐不断；保护模式有严格的权限保护（虽然这里没讲）
- 实模式下不可能用平坦模型（寄存器的锅），而保护模式 可以直接过渡到平坦模型



# 参考

- https://blog.csdn.net/Treeback/article/details/106414832