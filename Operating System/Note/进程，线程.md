# 进程和线程的区别

- 进程有自己的独立地址空间，线程没有
- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 线程的通信比较方便（同一进程的线程可以共享数据，例如全局变量或者静态变量）
- 进程上下文切换的开销比线程上下文切换的开销要大
- 一个进程挂了不会影响其他进程，而线程挂了会影响其他线程



# 为什么说进程上下文切换比线程上下文切换代价高

- 进程的切换分为两步：
  - 切换页目录以使用新的地址空间
  - 切换内核栈和硬件上下文
- 进程切换比线程切换成本大的地方在需要切换地址空间
- 切换地址空间会导致TLB刷新，导致一段时间内的内存访问相当低效

- 线程的切换是不会切换内存的（https://pluscb.xyz/2021/10/04/%E7%BB%93%E5%90%88%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E8%B0%88%E8%B0%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%AF%94%E8%BF%9B%E7%A8%8B%E5%BF%AB/）







我理解的用户态线程和内核态线程的关系

- 用户一般使用的都是用户态线程，如果我们要用到系统调用（read，write等）或中断，就会切换到内核态线程（这里就是黄成b博客里面所说的，线程的页表的切换）
- 而用户态线程和内核态线程的对应关系有很多的模型，例如一对一模型，多对一模型，多对多模型
- 一般我们用的就是一对一模型
- 这有点类似于线程池的感觉了.....



# 用户线程

- 用户线程的切换由用户态程序自己控制切换，不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu,目前Linux pthread大体是这么做的
- 指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应 用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线 程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少





# 内核线程

- 由操作系统创建和销毁，内核维护进程及线程的上下文信息以及线程切换，一个内核线程由于IO操作而阻塞，不会影响其他（内核）线程的运行
- 切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的





我对用户态线程和内核态线程的理解

- 我们一般用的就是用户态线程
- 如果需要用到printf或者read或者write的话，就会陷入内核态，这个用户态线程就会陷入内核态（因为有些操作是需要进入内核，获取更大的权限才可以操作的）
- 而用户态线程如果阻塞了的话，整个进程就会被阻塞，那么就需要给线程定时，不要让它阻塞太久；也会导致平均每个线程分配的时间片很少，并且不能被同进程的线程抢占
- 而操作系统中，内核自己使用的叫做内核线程，具有更高的特权，例如epoll就是用内核线程来实现的（而内核线程是以线程为单位调度的不会阻塞）