- read系统调用，并不是直接从物理设备把数据读取到内存中
  - 调用操作系统的read，是把数据从**内核缓冲区**复制到**进程缓冲区**
- wtite系统调用，也不是把数据直接写入到物理设备中
  - 而write系统调用，是把数据从**进程缓冲区**复制到**内核缓冲区**



解释一个read的过程

- 首先，该进程通过进行read()系统调用来填充其缓冲区
- 而read系统调用会导致内核向磁盘控制器硬件发出命令以从磁盘获取数据
- 磁盘控制器通过DMA将数据直接写入内核缓冲区
- 磁盘控制器完成缓冲区的填充后，内核将数据从内核空间中的临时缓冲区复制到进程指定的缓冲区中



# 为什么要那么多的缓冲区？

- 缓冲区的目的，是为了减少频繁地与设备之间的物理交换
- 背景：大家都知道，外部设备的直接读写，涉及操作系统的中断。发生系统中断时，需要保存之前的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息
- 为了减少这种底层系统的时间损耗、性能损耗，于是出现了内存缓冲区



- 有了内存缓冲区，上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到上层应用的缓冲区（进程缓冲区）；上层应用使用write系统调用时，仅仅把数据从进程缓冲区复制到内核缓冲区中
- 底层操作会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作，这种机制提升了系统的性能。至于什么时候中断（读中断、写中断），由操作系统的内核来决定，用户程序则不需要关心



- 所以，用户程序的IO读写操作，在大多数情况下，并没有进行实际的IO操作，而是在进程缓冲区和内核缓冲区之间直接进行数据交换



- 硬盘的读取速度是小于CPU的，它们之间有好几个数量级的差距，当向硬盘写入数据时，程序需要等待，不能做任何事情，就好像卡顿了一样，用户体验非常差。计算机上绝大多数应用程序都需要和硬件打交道，例如读写硬盘、向显示器输出、从键盘输入等，如果每个程序都等待硬件，那么整台计算机也将变得卡顿
- 但是有了缓冲区，就可以将数据先放入缓冲区中（内存的读写速度也远高于硬盘），然后程序可以继续往下执行，等所有的数据都准备好了，再将缓冲区中的所有数据一次性地写入硬盘，这样程序就减少了等待的次数，变得流畅起来
- 另一个好处就是，可以减少硬件设备的读写次数。其实我们的程序并不能直接读写硬件，它必须告诉操作系统，让操作系统内核（Kernel）去调用驱动程序，只有驱动程序才能真正的操作硬件

- 参考：https://blog.csdn.net/C1664510416/article/details/80868824
- https://zhuanlan.zhihu.com/p/79504011