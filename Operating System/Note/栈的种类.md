# 线程栈

- 是用户栈，和进程虚拟地址空间密切相关



- linux内核将这4G字节的空间分为两部分，将最高的1G字节（0XC0000000-0CFFFFFFF）供内核使用，称为内核空间
- 而将较低的3G字节（0x00000000-0xBFFFFFFF）供各个进程使用，称为用户空间
- 空间布局：
  - 程序段 (Text Segment)：可执行文件代码的内存映射
  - 数据段 (Data Segment)：可执行文件的已初始化全局变量的内存映射
  - BSS段 (BSS Segment)：未初始化的全局变量或者静态变量（用零页初始化）
  - 堆区 (Heap) : 存储动态内存分配，匿名的内存映射
  - 栈区 (Stack) : 进程用户空间栈，由编译器自动分配释放，存放函数的参数值、局部变量的值等
  - 映射段(Memory Mapping Segment)：任何内存映射文件



- 其中进程虚拟地址空间的栈区，就是进程栈
- 进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小不是固定的，Linux 内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）
- 但是并不是说栈区可以无限增长，它也有最大限制**RLIMIT_STACK (一般为 8M)**，我们可以通过 ulimit 来查看或更改 RLIMIT_STACK 的值



# 线程栈

背景

- 从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 task_struct 中
- 线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别。线程创建的时候，加上了 CLONE_VM 标记，这样 线程的内存描述符 将直接指向 父进程的内存描述符



- 对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长
- 然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的，使用 mmap 系统调用



- 由于线程栈是从进程的地址空间中 map 出来的一块内存区域，原则上是线程私有的。但是同一个进程的所有线程生成的时候浅拷贝生成者的 task_struct 的很多字段，其中包括所有的 vma，如果愿意，其它线程也还是可以访问到的，于是一定要注意





# 进程内核栈

- 在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作**进程内核栈**
- 进程内核栈在进程创建的时候，通过 slab 分配器从 thread_info_cache 缓存池中分配出来，其大小为 THREAD_SIZE，一般来说是一个页大小 4K





# 中断栈

- 进程陷入内核态的时候，需要内核栈来支持内核函数调用。中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关
- X86 上中断栈就是独立于内核栈的；独立的中断栈所在内存空间的分配发生在 arch/x86/kernel/irq_32.c 的 irq_ctx_init() 函数中 (如果是多处理器系统，那么每个处理器都会有一个独立的中断栈)，函数使用 __alloc_pages 在低端内存区分配 2个物理页面，也就是8KB大小的空间
- ARM架构没有独立的中断栈