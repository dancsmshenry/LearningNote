# 背景

- avl树：自平衡二叉查找树
- 红黑树
- B+树/B树
  - 它们特点是一样的，是多路查找树，一般用于数据库系统中，为什么，因为它们分支多层数少呗，都知道磁盘IO是非常耗时的，而像大量数据存储在磁盘中所以我们要有效的减少磁盘IO次数避免磁盘频繁的查找
  - B+树主要应用于文件系统中，最大的原因是它高度平衡，branch factor较大，这样可以减少磁盘IO

- 针对大量数据，如果在内存中作业就优先考虑红黑树（map，set，RB-tree实现），如果在硬盘中作业就优先考虑B系列（B+树，B-树）





### 红黑树和AVL树

- 红黑树类似AVL树，但提供更快的实时性，插入和删除有界最坏情况性能（最多两个分别旋转和三次旋转以平衡树），但查询时间稍慢（logn）
- 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度
- 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高
- map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的
- 总的来说，是功能性能空间开销的折中结果
  - AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大
  - 红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL
- 红黑树虽然定义复杂，但是它的限制条件是相对AVL宽松的。所以在进行插入删除操作的时候出现违反限制条件的状况较少，因而重平衡操作出现的机会比AVL少。基于上述原因，许多需要进行频繁删插操作的场景都使用来红黑树
- avl树平衡度高，调整频率高，适合查询多，增删少的场景
- 红黑树平衡度低，调整频率低，适合增删多的场景





### 红黑树和B树

- 红黑树多用在内部排序，即全放在内存中的，微软STL的map和set的内部实现就是红黑树
- B树多用在内存里放不下，大部分数据存储在外存上时。因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少
- 在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度





### 红黑树的应用场景

- 为什么要用RB-tree
  - 二叉查找树在大多数情况下查找和插入在效率上是没有问题的，但是在最坏的情况下效率比较低，但是平衡二叉树能够保证在最坏的情况下也能达到lgN，要实现这一目标，我们就要保证在插入完成后始终保持平衡状态。在一棵具有N个节点的树中，我们希望该树的高度能够维持在lgN左右，这样我们就能保证只需要lgN次比较操作就可以查找到想要的值。不幸的是，每次插入元素之后维持树的平衡状态太昂贵。所以就出现一些新的数据结构来保证在最坏的情况下插入和查找效率都能保证在对数的时间复杂度内完成。而我们所讲的红黑树就属于此新的数据结构之一，除此之外还有B树等数据结构
- Linux的的进程调度，用红黑树管理进程控制块，进程的虚拟内存空间都存储在一颗红黑树上，每个虚拟内存空间都对应红黑树的一个节点，左指针指向相邻的虚拟内存空间，右指针指向相邻的高地址虚拟内存空间
- epoll
- stl中的map，set
- java中的treemap
- nginx中用红黑树管理定时器，因为红黑树是有序的，所以可以很快的得到距离当前最小的定时器





### AVL树的应用场景

- 最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树
- 适合插入删除次数比较少，但查找多的情况





### B/B+树的引用场景

- 用在磁盘文件组织，数据索引和数据库索引





### 红黑树的性质

- 一种自平衡的二叉查找平衡树
- 节点要么是红色，要么是黑色
- 根节点是黑色
- 所有叶子节点都是黑色
- 每个红色节点的两个子节点都是黑色（每个叶子到根的所有路径上不能有两个连续的红色节点）
- 从任一节点到每个叶子节点的所有路径都包含相同树木的黑色节点
- 红黑树的具体操作实现（http://www.akathink.com/2016/08/08/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E7%BA%A2%E9%BB%91%E6%A0%91/）







# Epoll



### 为什么支持百万句柄

- 不用重复传递，调用epoll_wait时相当于以往调用





为什么用红黑树

- 早期使用hashmap效率高，但是内存空间占用大，就改为了红黑树
- 同时kernel中有现有的rbtree，而没有通用的hashtable