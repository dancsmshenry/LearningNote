# 系统调用

## 背景

- CPU上下文

  - CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存

  - 程序计数器，则是用来存储 CPU 正在执行的指令位置以及即将执行的下一条指令位置



## 过程

- 为了切换到内核态，需要先保存 CPU 寄存器中用户态的指令位置，然后更新 CPU 寄存器为内核态指令的新位置，最后跳转到内核态运行内核任务
- 而系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程
- 所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换







# process

## mmap

- 用法一：将磁盘文件映射到内存中（io的时候可以这样用）
- 用法二：向映射区申请一块内存

- 原子指令本身存在开销



## wait



## excve

- 得到的子进程中，与父进程一同指向的fd是不会改变的



## fork


- fork()系统调用用来生成子进程，而现有Linux系统运行在写时拷贝的机制下，于是fork()函数在为子进程建立内核中各种管理结构的时候，并没有将真实的物理资源分配给子进程，而只是将父进程的物理资源共享给子进程

- 比如：

  - fork()函数会将父进程的物理内存共享给子进程，即将父进程多级页表的内容复制到子进程新建立的多级页表中。
  - 然而在这种机制下，对于父进程中那些原本可读可写的页，一旦被共享给子进程之后，两个进程中任何一个对该物理页内容进行了修改，将会影响另外一个进程的正常使用
  - 于是，内核解决此问题的方法是：在将父进程的多级页表复制到子进程的多级页表中时，会将之前对于父进程来说可写的物理页对应的页表项，在父子进程的多级页表中都设置为只读
  - 因此，一旦两个进程中的任何一个对某个写保护（只读）的物理页发生了写操作，就会导致pagefault，相应的内核函数会处理并识别出这种写时拷贝机制导致的错误，并复制该物理页的内容到一个新的物理页，并将新的物理页链接到发生写操作的进程的多级页表中
  - 最后恢复该物理页对应表项的写权限，恢复进程对该物理页的写操作，做到进程无感知的处理

- 刚才做了个实验，发现fork子进程后，修改了子进程中的数据，再分别打印子进程和父进程的数据，这两个数据的地址都是不会变的（虚拟地址不变）

  - 由此可以推测，可能父子进程的页表差不多（即数据的虚拟内存都是一样的），但是实际上映射到的物理内存上都是不同的

  - ```cpp
    #include <iostream>
    #include <unistd.h>
    #include <stdlib.h>
    #include <sys/types.h>
    #include <sys/wait.h>
    
    using namespace std;
    
    int main() {
        int a = 100;
        cout << "before address a = " << (&a) << endl;
        pid_t pid;
        pid = fork();
    
        cout << "current pid = " << getpid() << endl;
        // sleep(10);
        
        if (pid != 0) {
            a = 1111;
        }
        cout << "after address a = " << (&a) << endl; // 发现修改前后的数据地址都是一样的
    }
    ```

- 当子进程先于父进程结束，子进程的状态变为 Z，又称“僵尸态”，即虽然结束了，但是还占有一些资源。子进程的资源回收由其父进程负责。

- 背景
  - 从概念上来说，可以将fork()认做是对父进程程序段、数据段、堆段以及栈段创建拷贝。早期的Unix实现中，此类复制确实是如此：将父进程内存拷贝至交换空间，以此创建新进程映像，而在父进程保持自身内存的同时，将换出映像置为子进程。不过，真要是简单地将父进程虚拟内存页拷贝到新的子进程，那就太浪费了。原因有很多，其中之一是：fork()之后尝尝伴随着exec()，这会用新程序替换进程的代码段，并重新初始化其数据段、堆段和栈段。
- 大部分现代Unix实现中采用两种技术来避免这种浪费：
  - 内核将每一进程的**代码段**标记为自读，从而使进程无法修改自身代码。这样，父子进程可以共享同一代码段。系统调用fork()在为子进程创建代码段时，其所构建的一系列进程级页表项均指向与父进程相同的物理内存页帧
  - 对于**父进程数据段、堆段和栈段中的各页**，内核采用写时复制技术来处理。
    - 最初，内核做了一些设置，令这些段的页表项指向与父进程相同的物理内存页，并将这些页面自身标记为只读。
    - 调用 fork()之后，内核会捕获所有父进程或子进程针对这些页面的修改企图，并为将要修改的（about-to-be-modified）页面创建拷贝
    - 系统将新的页面拷贝分配给遭内核捕获的进程，还会对子进程的相应页表项做适当调整。从这一刻起，父、子进程可以分别修改各自的页拷贝，不再相互影响

- 当使用fork函数创建一个子进程时，父子进程共享父进程的内存（不为子进程复制一份父进程的内存），并且将父进程的内存区域访问权限置为只读（父子进程都是只读），这样只要父/子进程其中任何一个打算向这块内存中写数据时，就会引发写保护异常（权限是只读），然后操作系统处理这个异常，把页面复制一份给进程写操作的进程，然后重新执行写操作

- 页出错分为两种
  - 页保护（写时复制）
  - 缺页（需求加载，可能要换页，参考lru算法）

- 上面是fork函数的原型，它有三个返回值

  - 该进程为父进程时，返回子进程的pid

  - 该进程为子进程时，返回0

  - fork执行失败，返回-1

fork的实现

- 第一步：复制进程资源
  - 进程pcb
  - 程序体，即代码段数据段等
  - 用户栈
  - 内核栈
  - 虚拟内存池
  - 页表
- 第二步：执行该进程

- fork的执行过程：
  - 为新进程在进程表中分配一个空项；
  - 为子进程赋予一个唯一的进程标识符
  - 给进程分配空间，做一个父进程上下文的逻辑副本，不包括共享内存区；
  - 初始化进程控制块
  - 增加父进程拥有的所有文件的计数器
  - 把子进程置为就绪态
  - 向父进程返回子进程的进程号；对子进程返回0；
  - 设置正确的连接，把新进程放置在就绪/挂起链表中。

系统为进线程提供了以下几个spi：

- fork是重量级调用， 因为它建立了父进程的一个完整副本， 然后作为子进程执行。为减少与该调用相关的工作量， Linux使用了写时复制（copy-on-write） 技术（sys_fork）
- vfork类似于fork， 但并不创建父进程数据的副本。 相反， 父子进程之间共享数据。这节省了大量CPU时间（如果一个进程操纵共享数据， 则另一个会自动注意到）（sys_vfork）
- clone产生线程， 可以对父子进程之间的共享、 复制进行精确控制（sys_clone）







# thread

- ```cpp
  #include <cpthread>
  
  // 创建线程
  int pthread_create(pthread_t *tidp, const pthread_attr_t *attr, void *(*start_rtn)(void), void *arg);
  /*
  tidp：线程 id
  attr： 线程属性（通常为NULL）
  start_rtn：线程函数（该形参填写：（void *）函数名 ）
             线程函数：（线程函数形参：（void *）或 void； return 值 传给 pthread_join函数的第二个形参 ）
  arg：start_rtn函数的参数（线程函数的形参，自定义值）
  返回值：成功：0；失败：-1
  */
  
  // 终止调用线程
  void pthread_exit(void *rval_ptr);
  /*
  Rval_ptr:线程退出返回值的指针（该形参会传给 pthread_join函数的第二个形参）
  */
  
  // 等待线程结束（阻塞调用线程，直到指定的线程终止）
  int pthread_join(pthread_t tid, void **rval_ptr);
  /*
  Tid :等待退出的线程id
  Rval_ptr：线程退出的返回值的指针（来源：线程函数的return 值；pthread_exit()函数的形参）
  */
  ```

- 