# 背景

- 进程间切换计算机资源开销很大，切换效率非常低
- 进程间数据共享的开销也很大（通信效率差，或是不方便）
- 进程占用空间较大，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段
- 多进程消耗太大







# 定义

- 只有两种线程，一种是用户态实现的用户线程（切换不需要进入kernel），另一种就是内核态实现的线程（切换需要进入kernel）
- 二者的区别，是由谁来调度线程
- 而用户线程本质上是需要内核线程支持的，所以才会有1:1（**KLT**），N:1（**ULT**），N:M（**LWP**）三类模型
  - 1:1的模型，比较知名的就是cpp pthread(也就是linux实现的)，windows NT内核以及jvm中的线程（一些blog书中的LWP就是这个）
  - N:M的模型，比较知名的就是go的goroutine（算是一种加强版的LWP）
  - 1:N的模型，比如libco或者项目里实现的




## 用户线程

- 用户线程的切换由用户态程序自己控制切换，不需要内核干涉，少了进出内核态的消耗
- 优点是能够有效的应对IO密集的场景
- 缺点是不能很好的利用多核CPU



- 一般来说，针对KLT，ULT模型，如果一个用户线程发生了阻塞，那么就会直接造成整个内核线程对应的所有用户线程阻塞（当然如果对系统调用使用了hook，就另外说）
- 所以准确的说，是导致了内核线程阻塞，才会整体的阻塞
- 之前说的多对一模型，之所以我们的项目还在用，就是hook了系统调用（因为多对一的时候，其中一个用户线程阻塞，就会造成整体的阻塞）



## 内核线程

- 由操作系统创建和销毁，内核维护线程及线程的上下文信息以及线程切换
- 一个内核线程由于IO操作而阻塞，不会影响同一个进程下其他（内核）线程的运行
- 内核线程的切换：由用户态转化为内核态，切换完毕要从内核态返回用户态
- PS：Linux2.4版本之前pthread用的LinuxThread实现，和Linux2.5以后pthread用的NPTL，他们都是系统级别的1:1线程模型
- 缺点：创建成本高（需要系统调用才能创建）；切换成本高







# 组成

## 线程栈

- 对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长
- 然而对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的，使用 mmap 系统调用

- 由于线程栈是从进程的地址空间中 map 出来的一块内存区域，原则上是线程私有的
- 但是同一个进程的所有线程生成的时候浅拷贝生成者的 task_struct 的很多字段，其中包括所有的 vma，如果愿意，其它线程也还是可以访问到的



## 其他

- 一些寄存器及PC







# 线程的创建

- fork()函数就是调用系统调用clone()来实现父进程拷贝的从而创建一个新进程的
- clone()里有一个flag参数，这个参数有很多的标志位指定了克隆时需要拷贝的东西，其中标志位CLONE_VM就是定义拷贝时是否使用相同的内存空间
- fork()调用clone()时没有设置CLONE_VM，所以在内核看来就是产生了两个拥有不同内存空间的进程
- 而pthread_create()里调用clone()是设置了CLONE_VM，所以在内核看来就产生了两个拥有相同内存空间的进程，即生成了一个内核态的线程







# 线程的通信

- 互斥量（pthread_mutex_t）
- 条件变量（pthread_cond_t）







# 八股

## 为什么单线程比多线程快

- 多线程慢可能是因为上下文切换导致tlb失效，导致访问页数的时候命中率下降，从而浪费了效率
- 并且，如果执行的任务的瓶颈主要在io上面的话，在单核的情况下，明显单线程更高效一点
- 参考redis此前一直是单线程，6.0才改为多线程的



## 为什么cpp中线程崩溃整个都down，而java中线程崩溃不会down

背景

- 同一个进程中，线程间是共享地址空间的
- 所以如果某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程
- 这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是让整个进程崩溃



崩溃的种类

- 针对只读内存写入数据（对char*进行写入）
- 访问了进程没有权限访问的地址空间（比如访问kernel的空间）
- 访问了不存在的内存（比如访问null）



过程

- 线程发生了上述的事情，kernel发现了有线程崩溃，于是向当前进程发送信号来终止该进程
- 如果进程没有注册自己的信号处理函数，那么操作系统会执行默认的信号处理程序（一般是发送kill信号，一般最后会让进程退出），但如果注册了，则会执行自己的信号处理函数

- 所以，本质上是**jvm注册了信号处理函数，对此进行了捕获**；而cpp则没有实现，需要自己去实现信号捕获
