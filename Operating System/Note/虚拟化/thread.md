# 为什么会有进程

- IO很慢，为了提高CPU的使用率，不能让进入IO的进程一直阻塞在IO阶段，做无用功，所以就需要在别的进程进入IO阻塞的时候，将其切出CPU
- 用户可能在某一时刻运行进程A，下一时刻运行进程B，在下一时刻又运行进程A，那么我们就需要保存进程A的上下文，方便后续使用



# 进程和线程的区别

- 进程有自己的独立地址空间，线程没有
- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 线程的通信比较方便（同一进程的线程可以共享数据，例如全局变量或者静态变量）
- 进程上下文切换的开销比线程上下文切换的开销要大
- 一个进程挂了不会影响其他进程，而线程挂了会影响其他线程（一般是指cpp和c）



# 为什么说进程上下文切换比线程上下文切换代价高

- 同样的问题：为什么进程切换比线程切换要慢
- 进程的切换分为两步：
  - 切换页目录以使用新的地址空间
  - 切换内核栈和硬件上下文
- 原因：
  - 进程切换比线程切换成本大的地方在需要切换地址空间
  - 进程的切换会涉及虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的 TLB 只有一个啊，这就尴尬了，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢；而线程的切换不会修改页表
  - 还有就是寄存器的修改
- [线程的切换是不会切换内存的](https://pluscb.xyz/2021/10/04/%E7%BB%93%E5%90%88%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E8%B0%88%E8%B0%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%AF%94%E8%BF%9B%E7%A8%8B%E5%BF%AB/)



# 线程

- 如果是pthread的话，那就是内核线程，由OS管理
- 但如果是go的goroutine，那就是用户线程，由用户态管理
- 而用户态的线程是基于内核态的线程构建的，所以就会有很多的模型，例如一对一模型，多对一模型，多对多模型
  - 存在一个线程中有多个协程




## 用户线程

- 用户线程的切换由用户态程序自己控制切换，不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu
- 就是go里面的goroutine



## 内核线程

- 由操作系统创建和销毁，内核维护进程及线程的上下文信息以及线程切换，一个内核线程由于IO操作而阻塞，不会影响其他（内核）线程的运行（因为linux是以task_struct作为调度的）
- 切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的
- 注意Linux2.4版本之前pthread用的LinuxThread实现，和Linux2.5以后pthread用的NPTL（据说比较好支持了POSIX线程标准）,都是系统级别的1:1线程模型，都是系统级线程
- LinuxThread的内核对应的管理实体就是进程，又称LWP（轻量级进程），每个线程的pid是不一样的（但是getpid返回的都是其进程的pid）



## 线程的创建

- fork()函数就是调用系统调用clone()来实现父进程拷贝的从而创建一个新进程的
- clone()里有一个flag参数，这个参数有很多的标志位指定了克隆时需要拷贝的东西，其中标志位CLONE_VM就是定义拷贝时是否使用相同的内存空间。
- fork()调用clone()时没有设置CLONE_VM，所以在内核看来就是产生了两个拥有不同内存空间的进程
- 而pthread_create()里调用clone()时设置了CLONE_VM，所以在内核看来就产生了两个拥有相同内存空间的进程，即生成了一个内核态的线程



- 另外，看到网上很多文章说，POSIX线程是混合模型，有用户级和系统级线程，通过一个参数来选择。等等。我是这样理解的：
- POSIX只是一个协议，各个系统的实现不一样。我只知道LInux的线程是系统级线程，是内核参与调度的，是操作系统可见的。不管LinuxThread还是NPTL都是这样的







# 进程阻塞

- 进程阻塞是不会消耗CPU资源，但是会消耗系统资源（系统资源包括cpu，内存，磁盘io）
  - 卧槽，这对网络编程又有了更深的理解了！
  - 进程阻塞固然不会占用cpu，cpu还是会继续干活去处理其他的进程（只要来的连接够多的话），但是啊，进程是非常大的（这句话也可以换成是线程），如果我们每个连接都创建一个进程或者线程来连接的话，就会导致系统资源的浪费（更不要说每次创建一个进程或者线程需要浪费的时间了，虽然这可以用池化技术解决），所以才会有了epoll技术和后续的网络设计的范式
- 进程阻塞是不会消耗cpu资源的
  - 背景：
    - 时间片轮转机制
    - linux内核维护的工作队列和等待队列：假如现在进程 A 里跑的程序有一个对象执行了某个方法将当前进程阻塞了，内核会立刻将进程A从工作队列中移除，同时在该对象里创建等待队列
    - 阻塞是人为安排的，让程序走到这里就阻塞（实现方式时系统将进程挂起）
    - 当对象收到中断或者某件事情触发之后，操作系统将该对象等待队列上的进程重新放回到工作队列上就绪，等待时间片轮转到该进程
  - os不会尝试运行被阻塞的进程，而是由对象去等待某个条件的触发
    - 这个“条件”有的时候是说来就来的。操作系统在跑进程时，会有优先级的区别。而硬件产生的信号，CPU 收到后往往会直接中断正在执行的程序，去做出响应，执行中断程序，这个优先级是很高的。这也很好理解，我们的鼠标、键盘一有动作，计算机会立即给出反应，就是这个道理







# 等待解决的问题

- 进线程，协程的切换，快慢，代价https://blog.csdn.net/weixin_37841366/article/details/109237089
- 进程，线程同步，通信的各种方式
- linux下进线程的调度都是一样的，因为其底层都是task_struct，kernel只要调度task_struct就可以了



# 为什么cpp中线程崩溃整个都down，而java中线程崩溃不会down

背景

- 各个线程的地址空间是共享的
- 既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃



崩溃的种类

- 针对只读内存写入数据（对char*进行写入）
- 访问了进程没有权限访问的地址空间（比如访问kernel的空间）
- 访问了不存在的内存（比如访问null）



- 线程发生了上述的事情，kernel发现了有线程崩溃，于是向当前进程发送信号来终止该进程
- 如果进程没有注册自己的信号处理函数，那么操作系统会执行默认的信号处理程序（一般是发送kill信号，一般最后会让进程退出），但如果注册了，则会执行自己的信号处理函数



- 所以，本质上是jvm注册了信号处理函数，对此进行了捕获；而cpp则没有实现，需要自己去实现信号捕获





# 进程创建后的写时复制机制

- 



# 为什么单线程比多线程快

- 我认为，多线程慢可能是因为上下文切换导致tlb失效，导致访问页数的时候命中率下降，从而浪费了效率
- 并且，如果执行的任务的瓶颈主要在io上面的话，在单核的情况下，明显单线程更高效一点



# 进程的地址空间是什么样的

- 要详细到寄存器







# 进程的挂起，阻塞和睡眠

- **阻塞**是进程的几种状态之一，正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）暂时无法继续执行。此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态（**被动**）
  - **阻塞恢复**：需要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行
  - 进程由于提出系统服务请求（如I/O操作），但因为某种原因未得到操作系统的立即响应，或者需要从其他合作进程获得的数据尚未到达等原因
- **挂起**：由于系统和用户的需要引入了挂起的操作，进程被挂起意味着该进程处于静止状态。如果进程正在执行，它将暂停执行，若原本处于就绪状态，则该进程此时暂不接受调度（**主动**）
  - 需要用户主动控制，挂起时线程不会释放对象锁
  - 挂起的进程会被换出到磁盘中
  - 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。
         父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。
         负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
         操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。
         对换的需要。为了缓和[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)紧张的情况，将内存中处于阻塞状态的进程换至外存上。
- **睡眠**：用户主动暂停执行的进程，将进行睡眠于内存中
  - **睡眠恢复**：是自动完成的，睡眠时间到了则恢复到就绪态，睡眠时线程不会释放对象锁



- 阻塞分为被动阻塞（IO）和主动阻塞（即睡眠）



共同点

- 都导致进程暂停执行。
- 进程都释放CPU，即两个过程都会涉及上下文切换



不同点

- 对系统资源占用不同：虽然都释放了CPU，但阻塞的进程仍处于内存中，而挂起的进程通过“对换”技术被换出到磁盘中。
- 发生时机不同：阻塞一般在进程等待资源（IO资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘
- 恢复时机不同：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活



阻塞IO和非阻塞IO

- 阻塞IO和非阻塞IO都是同步IO，当有数据到来的时候，它们都要进入阻塞状态，通过DMA将数据读入
- 二者不同的地方，是非阻塞IO调用时如果没有数据可读的话，就会直接返回
- 而阻塞IO会一直阻塞，直到有数据可读为止



- 而异步IO无论如何都不会进入阻塞状态



- ![](../image/进程状态图.png)

实现线程的三种模式：KLT（内核线程），ULT（用户线程），LWP（轻量级线程，用户级线程加轻量级进程混合）

- 一个理解：os中只有内核线程，所谓的用户线程都是在用户态代码库上实现的
- 因此就会衍生为1 v 1，1 v n，n v m的线程模式







# 参考

- https://blog.csdn.net/qq_41489540/article/details/109261692
- https://www.cnblogs.com/wanglulu/p/5522809.html
- https://blog.csdn.net/lxq19980430/article/details/102764018
- https://blog.csdn.net/ctthuangcheng/article/details/8914309
- http://www.cnitblog.com/tarius.wu/articles/2277.html
- https://blog.csdn.net/gatieme/article/details/51481863
- https://kernel.blog.csdn.net/article/details/51482122
- https://www.cnblogs.com/charlesblc/p/6242518.html
- https://blog.csdn.net/qq_42011541/article/details/102711196
- https://blog.csdn.net/gatieme/category_6225543.html?spm=1001.2014.3001.5482
- https://kernel.blog.csdn.net/article/details/52384965
- https://blog.csdn.net/ctthuangcheng/article/details/8914444
- https://blog.csdn.net/gatieme/category_6225543.html?spm=1001.2014.3001.5482
- https://blog.csdn.net/gatieme/category_6393814.html?spm=1001.2014.3001.5482
- https://blog.csdn.net/gatieme/category_1840439.html
- https://www.nowcoder.com/discuss/821457
- https://www.zhihu.com/question/19732473/answer/241673170
- https://www.zhihu.com/question/492983429/answer/2264063636
- https://blog.csdn.net/qq_41055045/article/details/118885500
- https://blog.csdn.net/mccand1234/article/details/118465728