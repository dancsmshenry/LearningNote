# 堆破坏

常见原因：

- 数组越界，这是最常见的原因char *stuff = new char[10]; stuff[10] = 3;
- 强制转换到一个错误的类型
- 未初始化的指针
- 错误使用. 和 ->
- 错误使用& 和 .
- delete & new 和 delete[] new[] 不配套
- 缺少或者不完整的拷贝构造
- 指向已回收内存的指针
- 重复delete同一块内存
- 多重基类，但是没有虚析构函数



定义：

- 没控制好指针，把不属于你分配的那块内存给写覆盖了，这块内存可能是你程序的数据，可能是堆的数据



结果：

- 导致程序crash
- 堆数据莫名其妙被修改，第二天被crash







# 大页内存







- 如果没有虚拟地址，直接把程序放在物理内存上跑，首先coding的时候就会非常的麻烦，因为如果有下面的程序不用了要移除了，就要重新移动程序的位置
- 其次，程序的安全性就很难保证，因为你是直接在物理内存上跑的，是可以直接访问别的进程的代码的（同时代码空间权限的设置也是十分的麻烦）