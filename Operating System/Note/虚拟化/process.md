进程退出后，线程是如何处理的：

- 主线程以 return 的方式退出：那么此时main() 执行完 return 之后，实际上会调用 exit() 函数，该函数除了执行关闭IO等操作之外，还会执行关掉其他子线程的操作

- 主线程以pthread_exit退出的：在主线程中执行 pthread_exit() ，实际上是提前结束了 main 的主线程，也就无法执行后续的 exit() 函数了。所以，这种方法是可以达到主线程退出子线程继续运行的目的

- ```cpp
  #include <iostream>
  #include <pthread.h>
  #include <unistd.h>
  
  void *func(void *args)
  {
      while (true)
      {
          std::cout << "I am func." << std::endl;
          sleep(3);
      }
  }
  
  int main()
  {
      pthread_t pid = 0;
      pthread_create(&pid, nullptr, func, nullptr);
      pthread_detach(pid);
      pthread_exit(nullptr);
      return 0;
  }// 在linux中可以轻松验证：g++ test.cpp -o test -pthread;上面的线程在主线程
  ```

- 



**进程的切换一定发生在中断/异常/系统调用处理过程中**

- 其实这里我是存疑的，因为，处理中断异常或是系统调用，本质上页表都是没有更换的，只是将栈换为了内核栈，并且执行内核的代码与硬件进行交互
- 当然，上面有点纰漏的就是，kernel会通过中断来切换时间片，这应该算是进程的切换了...
- 或者说是进程被阻塞了，挂起，也会造成进程的切换



说到底，进程的切换，要围绕进程的调度图来思考

https://blog.csdn.net/a745233700/article/details/120866618



![](../image/process的地址空间.jpg)



- 进程的数据结构：
  - 标识符： 跟这个进程相关的唯一标识符，用来区别其他进程
  - 状态: 进程的几个状态（等待、运行、停止）
  - 优先级: 进程的优先级
  - 程序计数器: 程序中即将被执行的下一条指令的地址。
  - 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
  - 上下文数据：进程执行时处理器的寄存器中的数据
  - I/O状态信息：包括显示的I/O请求,分配给进程的I/O设备和被进程使用的文件列表
  - 记账信息：可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等-
- 这些所有的信息都存放在一个进程的数据结构中task_struct, 也叫PCB。每个进程在内核中都有一个进程控制块(PCB)来维护进程相关的信息,Linux内核的进程控制块是task_struct结构体. 它在进程的运行时会被加载到RAM中





- 对task_struct结构体的分析

  - ```cpp
    /* Open file information: */
    struct files_struct   *files;
    //	是一个指针，指向被打开了的文件表
    ```

  - ```cpp
    /* Signal handlers: */
      struct signal_struct    *signal;
      struct sighand_struct __rcu   *sighand;
      sigset_t      blocked;
      sigset_t      real_blocked;
      /* Restored if set_restore_sigmask() was used: */
      sigset_t      saved_sigmask;
      struct sigpending   pending;
    //	信号处理字段
    ```

  - ```cpp
    //	进程的状态
    volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
    
    #define TASK_RUNNING        0//进程要么正在执行，要么准备执行
    #define TASK_INTERRUPTIBLE  1 //可中断的睡眠，可以通过一个信号唤醒
    #define TASK_UNINTERRUPTIBLE    2 //不可中断睡眠，不可以通过信号进行唤醒
    #define __TASK_STOPPED      4 //进程停止执行
    #define __TASK_TRACED       8 //进程被追踪
    /* in tsk->exit_state */ 
    #define EXIT_ZOMBIE     16 //僵尸状态的进程，表示进程被终止，但是父进程还没有获取它的终止信息，比如进程有没有执行完等信息。                     
    #define EXIT_DEAD       32 //进程的最终状态，进程死亡
    /* in tsk->state again */ 
    #define TASK_DEAD       64 //死亡
    #define TASK_WAKEKILL       128 //唤醒并杀死的进程
    #define TASK_WAKING     256 //唤醒进程
    ```

  - ```cpp
    //	进程的唯一标识
    pid_t pid;//进程的唯一标识
    pid_t tgid;// 线程组的领头线程的pid成员的值
    //在Linux系统中，一个线程组中的所有线程使用和该线程组的领头线程（该组中的第一个轻量级进程）相同的PID，并被存放在tgid成员中。只有线程组的领头线程的pid成员才会被设置为与tgid相同的值。注意，getpid()系统调用返回的是当前进程的tgid值而不是pid值。（线程是程序运行的最小单位，进程是程序运行的基本单位。）
    ```

  - ```cpp
    //	进程的亲属关系
    struct task_struct *real_parent; /* real parent process */ // 指向其父进程，如果创建它的父进程不再存在，则指向PID为1的init进程
    struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */ // 指向其父进程，当它终止时，必须向它的父进程发送信号。它的值通常与real_parent相同
    struct list_head children;    /* list of my children */ // 表示链表的头部，链表中的所有元素都是它的子进程（进程的子进程链表）
    struct list_head sibling;    /* linkage in my parent's children list */ // 用于把当前进程插入到兄弟链表中（进程的兄弟链表）
    struct task_struct *group_leader;    /* threadgroup leader */ // 指向其所在进程组的领头进程
    ```

  - [参考](https://blog.csdn.net/qq_52703909/article/details/123664176)

# 进程的地址空间是什么样的

- 要详细到寄存器







# 进程的挂起，阻塞和睡眠

- **阻塞**是进程的几种状态之一，正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）暂时无法继续执行。此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态（**被动**）
  - **阻塞恢复**：需要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行
  - 进程由于提出系统服务请求（如I/O操作），但因为某种原因未得到操作系统的立即响应，或者需要从其他合作进程获得的数据尚未到达等原因
- **挂起**：由于系统和用户的需要引入了挂起的操作，进程被挂起意味着该进程处于静止状态。如果进程正在执行，它将暂停执行，若原本处于就绪状态，则该进程此时暂不接受调度（**主动**）
  - 需要用户主动控制，挂起时线程不会释放对象锁
  - 挂起的进程会被换出到磁盘中
  - 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。
        父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。
        负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
        操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。
        对换的需要。为了缓和[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)紧张的情况，将内存中处于阻塞状态的进程换至外存上。
- **睡眠**：用户主动暂停执行的进程，将进行睡眠于内存中
  - **睡眠恢复**：是自动完成的，睡眠时间到了则恢复到就绪态，睡眠时线程不会释放对象锁



- 阻塞分为被动阻塞（IO）和主动阻塞（即睡眠）



共同点

- 都导致进程暂停执行。
- 进程都释放CPU，即两个过程都会涉及上下文切换



不同点

- 对系统资源占用不同：虽然都释放了CPU，但阻塞的进程仍处于内存中，而挂起的进程通过“对换”技术被换出到磁盘中。
- 发生时机不同：阻塞一般在进程等待资源（IO资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘
- 恢复时机不同：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活



阻塞IO和非阻塞IO

- 阻塞IO和非阻塞IO都是同步IO，当有数据到来的时候，它们都要进入阻塞状态，通过DMA将数据读入
- 二者不同的地方，是非阻塞IO调用时如果没有数据可读的话，就会直接返回
- 而阻塞IO会一直阻塞，直到有数据可读为止



- 而异步IO无论如何都不会进入阻塞状态



- ![](F:\Code\LearningNote\Operating System\Note\image\进程状态图.png)

实现线程的三种模式：KLT（内核线程），ULT（用户线程），LWP（轻量级线程，用户级线程加轻量级进程混合）

- 一个理解：os中只有内核线程，所谓的用户线程都是在用户态代码库上实现的
- 因此就会衍生为1 v 1，1 v n，n v m的线程模式



# 进程创建后的写时复制机制

# 进程阻塞

- 进程阻塞是不会消耗CPU资源，但是会消耗系统资源（系统资源包括cpu，内存，磁盘io）
  - 卧槽，这对网络编程又有了更深的理解了！
  - 进程阻塞固然不会占用cpu，cpu还是会继续干活去处理其他的进程（只要来的连接够多的话），但是啊，进程是非常大的（这句话也可以换成是线程），如果我们每个连接都创建一个进程或者线程来连接的话，就会导致系统资源的浪费（更不要说每次创建一个进程或者线程需要浪费的时间了，虽然这可以用池化技术解决），所以才会有了epoll技术和后续的网络设计的范式
- 进程阻塞是不会消耗cpu资源的
  - 背景：
    - 时间片轮转机制
    - linux内核维护的工作队列和等待队列：假如现在进程 A 里跑的程序有一个对象执行了某个方法将当前进程阻塞了，内核会立刻将进程A从工作队列中移除，同时在该对象里创建等待队列
    - 阻塞是人为安排的，让程序走到这里就阻塞（实现方式时系统将进程挂起）
    - 当对象收到中断或者某件事情触发之后，操作系统将该对象等待队列上的进程重新放回到工作队列上就绪，等待时间片轮转到该进程
  - os不会尝试运行被阻塞的进程，而是由对象去等待某个条件的触发
    - 这个“条件”有的时候是说来就来的。操作系统在跑进程时，会有优先级的区别。而硬件产生的信号，CPU 收到后往往会直接中断正在执行的程序，去做出响应，执行中断程序，这个优先级是很高的。这也很好理解，我们的鼠标、键盘一有动作，计算机会立即给出反应，就是这个道理



# 为什么会有进程

- IO很慢，为了提高CPU的使用率，不能让进入IO的进程一直阻塞在IO阶段，做无用功，所以就需要在别的进程进入IO阻塞的时候，将其切出CPU
- 用户可能在某一时刻运行进程A，下一时刻运行进程B，在下一时刻又运行进程A，那么我们就需要保存进程A的上下文，方便后续使用



# 进程和线程的区别

- 进程有自己的独立地址空间，线程没有
- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 线程的通信比较方便（同一进程的线程可以共享数据，例如全局变量或者静态变量）
- 进程上下文切换的开销比线程上下文切换的开销要大
- 一个进程挂了不会影响其他进程，而线程挂了会影响其他线程（一般是指cpp和c）



# 为什么说进程上下文切换比线程上下文切换代价高

- 同样的问题：为什么进程切换比线程切换要慢
- 进程的切换分为两步：
  - 切换页目录以使用新的地址空间
  - 切换内核栈和硬件上下文
- 原因：
  - 进程切换比线程切换成本大的地方在需要切换地址空间
  - 进程的切换会涉及虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的 TLB 只有一个啊，这就尴尬了，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢；而线程的切换不会修改页表
  - 还有就是寄存器的修改
- [线程的切换是不会切换内存的](



# 进程阻塞

- 进程阻塞，是进程主动让出cpu，同时挂载到内核的某个等待队列下面，等待某个时间的到来，引发进程调度切换
  - 这时候占用cpu是不合适的，因为没事干了，让出来最好
- 任何一个会引起阻塞的接口，最终都会落到内核去，内核会进入调度程序

- 协程是对执行流的调度
- 内核的阻塞态只分为：阻塞可被打断，阻塞不可打断
- 问题是，如果进程阻塞了，把cpu让出来，此时的时间片是否保留和内核的调度策略有关系