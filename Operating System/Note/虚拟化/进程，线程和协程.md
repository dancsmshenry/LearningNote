# 为什么会有进程

背景

- cpu的执行，可以认为是不断的读取指令，然后执行，这个循环不断的重复下去的
- 而在现代 X86 系列处理器中，给程序计数器（英语：Program Counter，PC）一个初值，CPU 就以该初值（地址）在内存中对应的内容作为指令来逐条的往下执行
- 问题就出在，io的速度非常非常的慢
  - 从磁盘上读信息的时间为毫秒级，比从 DRAM 读慢了 10 万倍，比从 SRAM 读慢了 100 万倍
  - 以机械硬盘读为例，电机带动盘片不断旋转，在读操作时，传动臂带动磁头沿着半径轴前后移动，这个操作称为寻道（seek），直到找到期望的磁道
  - 而 CPU 与内存则不同于机械构件，它们是固态的，是电子级的，自然要比机械硬盘快非常多。机械硬盘读写，95%的时间都花费在机械运动上
- 总结：可能执行了十万+的指令，只花费数毫秒，而当下一个指令是 IO 操作时，可能也花费了数毫秒
  - 但实际上，很有可能执行数条指令后就执行了 IO 操作，例如 IO 密集型程序
  - 这就导致，CPU 大部分时间都在等待 IO 操作，CPU 利用率非常低，几乎等于 0



- 所以我们想到了交替执行程序（有人被io阻塞了就换别的程序来执行）
- 而为了交替执行，就需要保存当前进程的内容，以便下次使用的时候继续执行，从而有了进程的概念
- 参考：https://lookcos.cn/archives/1195.html



小结

- 一个方面，其实cpu是可以一次一直运行一个程序的，但是，如果一个程序被阻塞在了io上，我们相当于cpu在做无用功浪费了资源，同时对于使用者来说一次只运行一个程序非常的低效（可能有人会说那就多核运行代码就行了）



# 进程和线程的区别

- 进程有自己的独立地址空间，线程没有
- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 线程的通信比较方便（同一进程的线程可以共享数据，例如全局变量或者静态变量）
- 进程上下文切换的开销比线程上下文切换的开销要大
- 一个进程挂了不会影响其他进程，而线程挂了会影响其他线程



# 为什么说进程上下文切换比线程上下文切换代价高

- 进程的切换分为两步：
  - 切换页目录以使用新的地址空间
  - 切换内核栈和硬件上下文
- 进程切换比线程切换成本大的地方在需要切换地址空间
- 切换地址空间会导致TLB刷新，导致一段时间内的内存访问相当低效

- 线程的切换是不会切换内存的（https://pluscb.xyz/2021/10/04/%E7%BB%93%E5%90%88%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E8%B0%88%E8%B0%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%AF%94%E8%BF%9B%E7%A8%8B%E5%BF%AB/）







我理解的用户态线程和内核态线程的关系

- 用户一般使用的都是用户态线程，如果我们要用到系统调用（read，write等）或中断，就会切换到内核态线程（这里就是黄成b博客里面所说的，线程的页表的切换）
- 而用户态线程和内核态线程的对应关系有很多的模型，例如一对一模型，多对一模型，多对多模型
- 一般我们用的就是一对一模型
- 这有点类似于线程池的感觉了.....



# 用户线程

- 用户线程的切换由用户态程序自己控制切换，不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu,目前Linux pthread大体是这么做的
- 指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应 用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线 程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少





# 内核线程

- 由操作系统创建和销毁，内核维护进程及线程的上下文信息以及线程切换，一个内核线程由于IO操作而阻塞，不会影响其他（内核）线程的运行
- 切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的





















- 线程一直是分系统级线程和用户级线程，也就是所谓的 1:1线程模型和 1:n线程模型。
- 注意Linux2.4版本之前pthread用的LinuxThread实现，和Linux2.5以后pthread用的NPTL（据说比较好支持了POSIX线程标准）,都是系统级别的1:1线程模型，都是系统级线程
- LinuxThread的内核对应的管理实体就是进程，又称LWP（轻量级进程），每个线程的pid是不一样的（但是getpid返回的都是其进程的pid）



- 重要的是系统调用clone()，大家熟知的fork()函数就是调用clone()来实现父进程拷贝的从而创建一个新进程的。
- 系统调用clone()里有一个flag参数，这个参数有很多的标志位指定了克隆时需要拷贝的东西，其中标志位CLONE_VM就是定义拷贝时是否使用相同的内存空间。
- fork()调用clone()时没有设置CLONE_VM，所以在内核看来就是产生了两个拥有不同内存空间的进程。
- 而pthread_create()里调用clone()时设置了CLONE_VM，所以在内核看来就产生了两个拥有相同内存空间的进程。所以用户态创建一个新线程，内核态就对应生成一个新进程（所以这里的意思是，当生成一个线程，实际上会在用户态生成一个用户态线程，然后通过lwp映射到内核的内核线程，然后实际上内核的调度管理就是调度这个轻量级线程）



- 另外，看到网上很多文章说，POSIX线程是混合模型，有用户级和系统级线程，通过一个参数来选择。等等。我是这样理解的：
- POSIX只是一个协议，各个系统的实现不一样。我只知道LInux的线程是系统级线程，是内核参与调度的，是操作系统可见的。不管LinuxThread还是NPTL都是这样的



# 进程切换为什么比线程慢

- 进程的切换会涉及虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的 TLB 只有一个啊，这就尴尬了，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢
- 而线程的切换就不涉及虚拟地址空间的切换，就不存在问题了



- 还有就是寄存器的修改





# 误区解答

- 进程阻塞是不会消耗CPU资源，但是会消耗系统资源（系统资源包括cpu，内存，磁盘io）
  - 卧槽，这对网络编程又有了更深的理解了！
  - 进程阻塞固然不会占用cpu，cpu还是会继续干活去处理其他的进程（只要来的连接够多的话），但是啊，进程是非常大的（这句话也可以换成是线程），如果我们每个连接都创建一个进程或者线程来连接的话，就会导致系统资源的浪费（更不要说每次创建一个进程或者线程需要浪费的时间了，虽然这可以用池化技术解决），所以才会有了epoll技术和后续的网络设计的范式
- 进程阻塞是不会消耗cpu资源的
  - 背景：
    - 时间片轮转机制
    - linux内核维护的工作队列和等待队列：假如现在进程 A 里跑的程序有一个对象执行了某个方法将当前进程阻塞了，内核会立刻将进程A从工作队列中移除，同时在该对象里创建等待队列
    - 阻塞是人为安排的，让程序走到这里就阻塞（实现方式时系统将进程挂起）
    - 当对象收到中断或者某件事情触发之后，操作系统将该对象等待队列上的进程重新放回到工作队列上就绪，等待时间片轮转到该进程
  - os不会尝试运行被阻塞的进程，而是由对象去等待某个条件的触发
    - 这个“条件”有的时候是说来就来的。操作系统在跑进程时，会有优先级的区别。而硬件产生的信号，CPU 收到后往往会直接中断正在执行的程序，去做出响应，执行中断程序，这个优先级是很高的。这也很好理解，我们的鼠标、键盘一有动作，计算机会立即给出反应，就是这个道理





# 等待解决的问题

- 进线程，协程的切换，快慢，代价https://blog.csdn.net/weixin_37841366/article/details/109237089
- 进程，线程同步，通信的各种方式
- linux下进线程的调度都是一样的，因为其底层都是task_struct，kernel只要调度task_struct就可以了



# 为什么cpp中线程崩溃整个都down，而java中线程崩溃不会down

背景

- 各个线程的地址空间是共享的
- 既然是共享，那么某个线程对地址的非法访问就会导致内存的不确定性，进而可能会影响到其他线程，这种操作是危险的，操作系统会认为这很可能导致一系列严重的后果，于是干脆让整个进程崩溃



崩溃的种类

- 针对只读内存写入数据（对char*进行写入）
- 访问了进程没有权限访问的地址空间（比如访问kernel的空间）
- 访问了不存在的内存（比如访问null）



- 线程发生了上述的事情，kernel发现了有线程崩溃，于是向当前进程发送信号来终止该进程
- 如果进程没有注册自己的信号处理函数，那么操作系统会执行默认的信号处理程序（一般是发送kill信号，一般最后会让进程退出），但如果注册了，则会执行自己的信号处理函数



- 所以，本质上是jvm注册了信号处理函数，对此进行了捕获；而cpp则没有实现，需要自己去实现信号捕获





# 参考

- https://blog.csdn.net/qq_41489540/article/details/109261692
- https://www.cnblogs.com/wanglulu/p/5522809.html
- https://blog.csdn.net/lxq19980430/article/details/102764018
- https://blog.csdn.net/ctthuangcheng/article/details/8914309
- http://www.cnitblog.com/tarius.wu/articles/2277.html
- https://blog.csdn.net/gatieme/article/details/51481863
- https://kernel.blog.csdn.net/article/details/51482122
- https://www.cnblogs.com/charlesblc/p/6242518.html
- https://blog.csdn.net/qq_42011541/article/details/102711196
- https://blog.csdn.net/gatieme/category_6225543.html?spm=1001.2014.3001.5482
- https://kernel.blog.csdn.net/article/details/52384965
- https://blog.csdn.net/ctthuangcheng/article/details/8914444
- https://blog.csdn.net/gatieme/category_6225543.html?spm=1001.2014.3001.5482
- https://blog.csdn.net/gatieme/category_6393814.html?spm=1001.2014.3001.5482
- https://blog.csdn.net/gatieme/category_1840439.html
- https://www.nowcoder.com/discuss/821457
- https://www.zhihu.com/question/19732473/answer/241673170
- https://www.zhihu.com/question/492983429/answer/2264063636