# 非抢占式内核

- 高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占CPU运行
- 进程一旦处于核心态（例如用户进程执行系统调用），则除非进程自愿放弃CPU，否则该进程将一直运行下去，直至完成或退出内核
- 中断服务可以使一个高优先级的任务由挂起状态变为就绪状态。但中断服务以后控制权还是回到原来被中断了的那个任务，直到该任务主动放弃CPU的使用权时，那个高优先级的任务才能获得CPU的使用权



优点：

- 中断响应快（与抢占式内核比较）
- 允许使用不可重入函数
- 几乎不需要使用信号量保护共享数据。运行的任务占有CPU，不必担心被别的任务抢占。这不是绝对的，在打印机的使用上，仍需要满足互斥条件



缺点：

- 任务响应时间慢。高优先级的任务已经进入就绪态，但还不能运行，要等到当前运行着的任务释放CPU
- 非抢占式内核的任务级响应时间是不确定的，不知道什么时候最高优先级的任务才能拿到CPU的控制权，完全取决于应用程序什么时候释放CPU





# 可抢占式内核

- 当进程位于内核空间时，有一个更高优先级的任务出现时，如果当前内核允许抢占，则可以将当前任务挂起，执行优先级更高的进程
- 如果是中断服务子程序使一个高优先级的任务进入就绪态，中断完成时，中断了的任务被挂起，优先级高的那个任务开始运行（与非抢占式相比完全不同）



优点

- 使用抢占式内核，最高优先级的任务什么时候可以执行，可以得到CPU的使用权是可知的。使用抢占式内核使得任务级响应时间得以最优化



缺点

- 不能直接使用不可重入型函数。调用不可重入函数时，要满足互斥条件，这点可以使用互斥型信号量来实现。如果调用不可重入型函数时，低优先级的任务CPU的使用权被高优先级任务剥夺，不可重入型函数中的数据有可能被破坏



意义

- 首先，这是将Linux应用于实时系统所必需的。实时系统对响应时间有严格的限定，当一个实时进程被实时设备的硬件中断唤醒后，它应在限定的时间内被调度执行。而Linux不能满足这一要求，因为Linux的内核是不可抢占的，不能确定系统在内核中的停留时间。事实上当内核执行长的系统调用时，实时进程要等到内核中运行的进程退出内核才能被调度，由此产生的响应延迟，在如今的硬件条件下，会长达100ms级。这对于那些要求高实时响应的系统是不能接受的。而可抢占的内核不仅对Linux的实时应用至关重要，而且能解决Linux对多媒体（video， audio）等要求低延迟的应用支持不够好的缺陷
- linux的内核都是可抢占式的



# 区别

- 二者的区别在于，内核是否有权力强行夺回用户进程的执行权（非抢占式的只会让中断的任务进行就绪的状态，当前任务执行完后才执行这个就绪的任务；抢占式的是中断后直接执行任务）



# 为什么可以抢占正在执行的进程

- 中断！
- 不管是嵌入式架构还是 x86 桌面架构在这一点上的原理都是一样的，CPU(或 MCU) 都会提供一系列硬件中断，这些中断的优先级总是高于一切进程（包括 Kernel 进程），那么内核便可以通过中断，比如设定定时器定时引发中断，然后在中断处理时将执行权交给 Kernel 进程便完成了抢占的过程。也有的抢占是来自于硬件中断，比如网卡硬件接收到网络数据包，这时硬件触发数据包到达中断，内核就会将执行权交给网卡驱动（运行在 Kernel）