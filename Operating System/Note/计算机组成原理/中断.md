中断指令 int 指令

- 中断是可以屏蔽的，异常是不可以屏蔽的（中断可以屏蔽是因为cpu上有个地方，可以关闭中断）
- 而异常其实是cpu执行的时候，遇到了有问题的指令，这是无法屏蔽的，因为如果执行了有问题的指令，就会导致程序语义的错误（对于机器来说，只要执行了错误的指令，就一定认为程序语义发生了错误，这和人的思路不一样的）
- 异常只是借用中断跳转到另外一个地方的机制
- int 汇编中断指令



为什么会划分用户态和内核态

- 如果只是单一用户，单一任务运行的话，那其实没必要划分用户态和内核态，因为不需要来回切换任务，那没有那么多的任务，就不需要虚拟化，不需要并发并行，那os还能帮我们做什么呢？即啥都不用做（）
- 而正是有了后来的发展，所以需要os帮我们做这些事情，同时又不能让用户肆意修改内核代码，所以要这样划分
- 同时，这里有一点，就是区分内核态也能够避免应用程序直接访问甚至修改寄存器会导致严重的bug
- 换句话说，用户态和内核态的划分也是硬件cpu和os的相互配合产生的一种解决方案
- 通过硬件手段（也只能硬件手段才能做到），限制某些代码，使其无法控制整个物理硬件，进而使各个不同用户，不同任务的代码，无权修改整个物理硬件，再进而保护操作系统的核心底层代码和其他用户的数据不被无意或者有意地破坏和盗取
- 操作系统一般使用CPU提供的两个级别运行系统—— ring0和ring3，你也可以叫它们内核态和用户态。操作系统将很多资源的使用权限从用户态剥离，限制用户态访问和执行。一般我们使用操作系统都在用户态下，而内核以及其内的各种驱动拥有内核态的级别可以使用所有计算机资源。用户态程序想要使用计算机资源，如某个设备、某种IO等，是不能自己直接去使用的，需要告诉内核，让内核去做。这个主动告诉内核让它去做的方法就是系统调用。（当然还有被动的异常和外部中断等）
- 即如果我想走系统调用，或者要使用io设备的话，就需要进入内核态，而要让内核知晓的方式之一就是中断
- 为了保护系统资源，不让用户程序可以随意使用系统资源，操作系统只让内核提供规范化的对外接口——系统调用。系统调用通过一个体系结构设定的软中断进入，如Intel的int 0x80。系统调用是不同于普通的函数调用的，普通的函数调用只涉及到栈空间的操作
- 但是系统调用影响的是整个当前进程的上下文。使用一个中断来陷入中断上下文，中断上下文是高级别权限，这个中断上下文很短，主要就是保存现场、获取系统调用号和参数，交给内核对应的系统调用函数去继续执行。但是这个时候这个进程上下文已经是处于高级别的内核态执行权限了。待到系统调用执行结束后返回到用户态权限下继续执行。这是一次陷入内核来执行保护权限操作的过程。至于为什么要使用中断，已经很明了了，就是为了先从用户态进内核态，而中断是最有效的手段，CPU也提供了专门使用的软中断来做这件事。
- 中断是唯一的，可以让非当前执行程序戳下CPU，让其强制跳到别的地方执行的机制。

