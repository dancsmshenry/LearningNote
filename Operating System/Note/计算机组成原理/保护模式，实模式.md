# 背景

- （也就是CPU的工作原理）
- 控制单元要取下一条待运行的指令，该指令的地址在程序计数器 PC 中，在 x86CPU 上，程序计数器就是 cs： ip。读取 ip 寄存器后，将此地址送上地址总线， CPU 根据此地址便得到了指令，并将其存入到指令寄存器 IR 中
- 这时候轮到指令译码器上场了，它根据指令格式检查指令寄存器中的指令，先确定操作码是什么，再检查操作数类型，若是在内存中，就将相应操作数从内存中取回放入自己的存储单元，若操作数是在寄存器中就直接用了，免了取操作数这一过程
- 操作码有了，操作数也齐了，操作控制器给运算单元下令，开工，于是运算单元便真正开始执行指令了
- ip 寄存器的值被加上当前指令的大小，于是 ip 又指向了下一条指令的地址
- 接着控制单元又要取下一条指令了，流程回到了本段开头







# 实模式

- 是指8086CPU的寻址方式，寄存器大小，指令用法等
- **实**体现在程序中用到的地址都是真实的物理地址
- “**段基址**：段内偏移地址” 产生的逻辑地址就是物理地址，即用户使用的地址是真实的物理内存地址
- 物理地址 = 段地址 + 偏移地址



缺点

- 实模式下操作系统和用户程序属于同一特权级，没有区别对待
- 用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址
- 用户程序可以自由修改段基址（不安全）
- 访问超过 64KB 的内存区域时要切换段基址
- 一次只能运行一个程序，无法充分利用计算机资源
- 共 20 条地址线，最大可用内存为 1MB，这即使在 20 年前也不够用





# 保护模式

- 为了克服在实模式下的种种问题，处理器厂商开发出保护模式，保护模式是相对于实模式而言的
- 首次出现是在Intel 80286 CPU中首次出现的，紧跟着8086
- **物理地址不能直接被程序访问，程序内部的地址（虚拟地址）需要被转化成物理地址之后再去访问**







# 区别

- 实模式可以直接访问物理地址；保护模式下需要通过分页，GDT等来进行间接访问
- 实模式没有特权级的概念；保护模式有严格的权限保护
- 实模式下不可能用平坦模型（寄存器的问题），而保护模式可以直接过渡到平坦模型
  - 因为在平坦模式中，实模式访问超过64KB的内存地址，就要重新指定不同的段基址
  - 而保护模式访问的内存地址大小是32位的，寻址范围就有4GB







# 两种内存模型

## 分段模型

- 当我们使用汇编语言编写程序时，我们要自己定义好数据段，代码段，栈段之类的东西，这就定义了多个段
- 而当我们使用它们的时候（就像使用栈，都要指定栈基址，再根据需要给sp（栈顶指针寄存器）赋予相应的值，才能对数据进行正确的操作）
- 多个段可能在不同的内存分段中存在，大小不一，所以才需要进行相应的跳转访存
- 像汇编这种低级语言，我们可以允许程序员对程序进行分段，能灵活编排布局，属于人为将程序分成段，这就是采用分段模型编程



优点

- 程序分段能赋予程序段不同属性，按此执行不同的安全策略（代码段read only之类的）
- 能提高cpu缓存命中，按照局部性原理，在分段的基础下对不同的段采取不同策略
- 还能节省内存，例如在一个程序的多个副本一同执行时，没必要在内存中有多个相同的代码块，把代码段共享就好了



## 平坦模型

背景

- 在内存分段的环境下，8086(实模式)CPU的16位寄存器最多只能在一个内存段（内存分段）的64kb空间内寻址，要是超过64kb，它只能先变换段基址：CS，来达到长距离取指的目的
- 一个程序肯定包括多个段（这是程序分段），这样它就要花跟多功夫去寻址，访存
- 而平坦模式则可以不变换段基址，实现对内存地址的直接访问



- 现代操作系统一般都是在平坦模型下工作(整个4GB空间为一个段)，编译器也是按照平坦模型为程序布局，程序中的代码和数据都在同一个段中整齐排列

- 相对于多段模式来说，平坦模式就只有一个段（可能是因为觉得多段的情况下，转换特别的麻烦）



优点

- 平坦模型在程序分段的基础上将多个段统筹管理，在上面做了很多努力，让我们不用操心代码分段的事儿，解放生产力
