# 特权级

- Intel x86架构的cpu一共有0～4四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查
- 硬件已经提供了一套特权级使用的相关机制，软件自然要好好利用，这属于操作系统要做的事情
- 对于UNIX/LINUX来说，只使用了0级特权级别和3级特权级。也就是说在UNIX/LINUX系统中，一条工作在0级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权的指令具有CPU提供的最低或者说最基本权力







# 内核栈

- Linux中每个进程有两个栈，分别用于用户态和内核态的进程执行，其中的内核栈就是用于内核态的堆栈，它和进程的task_struct结构，更具体的是thread_info结构一起放在两个连续的页框大小的空间内



- 当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态
- 当程序运行在0级特权级上时，就可以称之为运行在内核态



- 用户运行一个程序，该程序所创建的进程开始是运行在用户态的
- 如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作
- 这时，必须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作
- 完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用



- 保护模式，通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据
- 在内核态下，CPU可执行任何指令，在用户态下CPU只能执行非特权指令
- 当CPU处于内核态，可以随意进入用户态；而当CPU处于用户态，只能通过中断的方式进入内核态
- 一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入内核态







# 为什么会划分用户态和内核态

- 如果只是单一用户，单一任务运行的话，那其实没必要划分用户态和内核态，因为不需要来回切换任务，那没有那么多的任务，就不需要虚拟化，不需要并发并行，那os还能帮我们做什么呢？即啥都不用做（）
- 而正是有了后来的发展，所以需要os帮我们做这些事情，同时又不能让用户肆意修改内核代码，所以要这样划分
- 同时，这里有一点，就是区分内核态也能够避免应用程序直接访问甚至修改寄存器会导致严重的bug
- 换句话说，用户态和内核态的划分也是硬件cpu和os的相互配合产生的一种解决方案
- 通过硬件手段（也只能硬件手段才能做到），限制某些代码，使其无法控制整个物理硬件，进而使各个不同用户，不同任务的代码，无权修改整个物理硬件，再进而保护操作系统的核心底层代码和其他用户的数据不被无意或者有意地破坏和盗取
- 操作系统一般使用CPU提供的两个级别运行系统—— ring0和ring3，你也可以叫它们内核态和用户态。操作系统将很多资源的使用权限从用户态剥离，限制用户态访问和执行。一般我们使用操作系统都在用户态下，而内核以及其内的各种驱动拥有内核态的级别可以使用所有计算机资源。用户态程序想要使用计算机资源，如某个设备、某种IO等，是不能自己直接去使用的，需要告诉内核，让内核去做。这个主动告诉内核让它去做的方法就是系统调用。（当然还有被动的异常和外部中断等）
- 即如果我想走系统调用，或者要使用io设备的话，就需要进入内核态，而要让内核知晓的方式之一就是中断
- 为了保护系统资源，不让用户程序可以随意使用系统资源，操作系统只让内核提供规范化的对外接口——系统调用。系统调用通过一个体系结构设定的软中断进入，如Intel的int 0x80。系统调用是不同于普通的函数调用的，普通的函数调用只涉及到栈空间的操作
- 但是系统调用影响的是整个当前进程的上下文。使用一个中断来陷入中断上下文，中断上下文是高级别权限，这个中断上下文很短，主要就是保存现场、获取系统调用号和参数，交给内核对应的系统调用函数去继续执行。但是这个时候这个进程上下文已经是处于高级别的内核态执行权限了。待到系统调用执行结束后返回到用户态权限下继续执行。这是一次陷入内核来执行保护权限操作的过程。至于为什么要使用中断，已经很明了了，就是为了先从用户态进内核态，而中断是最有效的手段，CPU也提供了专门使用的软中断来做这件事。
- 中断是唯一的，可以让非当前执行程序戳下CPU，让其强制跳到别的地方执行的机制。







# 用户态切换到内核态的三种方式

- 系统调用：
  - 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制，其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如lx86的int 80h， powerpc的sc  
  - 可以认为是用户自己主动发起的切换
- 异常：
  - 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关的程序中，也就是转到了内核态，比如缺页异常
- 外围设备的中断
  - 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作的完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等





- ![](../image/内核态和用户态.jpg)