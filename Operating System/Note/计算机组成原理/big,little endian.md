# 定义

- 大端存储：**数据的高字节保存在内存的低地址中**

  - | 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
    | -------- | ------ | ------ | ------ | ------ |
    | 存放内容 | 0x12   | 0x34   | 0x56   | 0x78   |

- 小端存储：**数据的高字节保存在内存的高地址中**

  - | 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
    | -------- | ------ | ------ | ------ | ------ |
    | 存放内容 | 0x78   | 0x56   | 0x34   | 0x12   |



对于数字12345678

- **大端**的存储方式是，12345678，从左到右位数依次变小，即**最小的一位放在最右边**
- **小端**的存储方式是，87654321，从左到右位数依次变大，即**最小的一位放在最左边**



- **网络传输一般是大端传输，人们常用数字读取方式也是大端**
  - 网络传输中只有bind的时候需要把port和ip进行字节序转换，而发送的数据又不需要进行字节序转换
  - 原因是: RFC定于了网络协议中使用的是大端字节序，而port、ip是要在协议栈中进行封包、解包用的，自然要进行大端转换；而传输的数据只是字节流，最后都是传到对端的应用层，交给应用层自己处理的，每个架构平台怎么处理，那就不是协议栈需要考虑的问题了
  - https://zhuanlan.zhihu.com/p/458836074

- **主机存储一般是小端存储**







# 优缺点分析

从以下几个方面分析（bg：计算机读数据的顺序是从左到右的）

**1、检查奇偶性**

- 对于小端，读第一个就可以判断是否为偶数
- 对于大端，要读到最后一个才能判断



**2、检查正负号**

- 大端读第一个数据就可以判断是不是正负数
- 小端要读到最后一个才行



**3、比较大小**（进行数字比较，对下列数字进行比较）

43662576

594

2

- 对于大端，必须要把每一位数据都读到才能比较（即要把全部数据都读完才能够进行比较）
- 而对于小端只要从左往右读数据，谁最先没有数据了，谁就最小
  - 如果长度相同，就往回走




**4、乘法**

- 大端的乘法，必须要等到每一轮的结果都出来了，才能统一写入内存
- 而小端则不用，每次计算完了就直接放入内存，不用缓存数据



**5、任意精度的整数**

- 如果是大端，数字一旦需要进位（比如99，再加一），后面所有的位都会发生移动
- 而小端就不用，只需要在后面加上一位即可
  - 小端序的另一个好处是，如果逐字节的运算从个位数开始（比如乘法和加法），可以从左到右依次运算一个个 u64，算完上一个再读取下一个。大端序就不行，必须读取整个数以后再进行运算



**6、更改类型**（bg：强制改变变量的数据类型，比如32位变16位）

- 大端需要移动指针的位置，即往后移
- 而小端不需要移动指针（因为指针的类型变了，访问的区间也会变）







# 如何检测

- 通过强制转换检测大小端（我的主机默认是小端）

- ```cpp
  #include <iostream>
  using namespace std;
  int main()
  {
      int a = 0x1234;
      //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
      char c = (char)(a);
      if (c == 0x12)
          cout << "big endian" << endl;
      else if (c == 0x34)
          cout << "little endian" << endl;
  }
  ```



- 利用union体

- ```cpp
  #include <iostream>
  using namespace std;
  // union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值
  union endian
  {
      int a;
      char ch;
  };
  int main()
  {
      endian value;
      value.a = 0x1234;
      // a和ch共用4字节的内存空间
      if (value.ch == 0x12)
          cout << "big endian" << endl;
      else if (value.ch == 0x34)
          cout << "little endian" << endl;
  }
  ```