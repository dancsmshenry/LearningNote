# 哲学家就餐问题

定义

- 假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西
- 哲学家从不交流，容易产生死锁



解决办法

方法一

- 用一把全局的mutex，然后每次只有抢到锁的人才能开始拿左右的筷子
- 每次先看自己左右两边的筷子是否为可使用的
  - 如果可以使用，就去抢全局的mutex
  - 否则就要重新去判断当前两边的筷子是否可用
- 有效解决死锁饥饿的问题，但是效率低下（没抢到锁的人只能一直自旋，浪费cpu）
- 而且，如果有人吃的很频繁的话，就可能造成有人会饿死，即抢不到锁



方法二

- 奇数号哲学家先拿他左边的筷子，然后再去拿他右边的筷子
- 偶数号哲学家则先拿右边的筷子，然后再去拿他左边的筷子
- 但感觉并发度有点差...



方法三

- 限制就餐人员，最多只有4个人就餐（这里假设总共就5个哲学家）
- 那么必然有个人能够吃上饭，死锁的问题就能够解开







# 银行家问题







# 八股

## 两线程并发问题

- 两个及两个以上的线程实现for循环，每次循环实现+1，循环100次，问最小sum为多少

- ```cpp
  int sum = 0;
  
  void count() {
      for (int i = 0; i < 10; ++ i) {
          ++ sum;  // 假设这里的sum是volititle的
      }
  }
  
  int main() {
      int n = 0;
      cin >> n; // n > 1
      for (int i = 0; i < n; ++ i) {
      	creat_thread(count());
      }
  }
  ```

- 答案最小为2（是一种非常极端的情况）

- 下述假设读到的内容是t，同时下面每一步每一次加法都是先从内存读入数据，然后操作，放回内存，这样的循环的

- | thread01                            | thread(2).....thread(n-1)                          | thread(n)                                  |
  | ----------------------------------- | -------------------------------------------------- | ------------------------------------------ |
  | 从内存中读入sum，t=sum=0            |                                                    |                                            |
  |                                     | 中间所有的线程都重复的将sum读入，将sum写至(n-2)*10 |                                            |
  |                                     |                                                    | 同样的读入sum，将sum写至(n-2)*10+9         |
  | 此时执行t++，写入sum=t，则此时sum=1 |                                                    |                                            |
  |                                     |                                                    | 读入sum（此时t=sum=1），执行t++，则此时t=2 |
  | 执行操作，使得最后写入sum的为11     |                                                    |                                            |
  |                                     |                                                    | 写入此时的t，则此时的sum为2                |




## 进，线程的通信方式

- 管道：是kernel中的一串缓存
  - 管道传输的数据是单向的，若相互进行通信的话，需要进行创建两个管道才行的
- 消息队列：是保存在内存中的消息链表，在发送数据的时候，会分成一个独立的数据单元，即就是数据块
  - 不适合大数据的传输
  - 因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 `MSGMAX` 和 `MSGMNB`，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度
  - **消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程
- 共享内存：
  - 共享内存的机制就是拿出一块虚拟化的地址空间来，映射到相同的物理内存中。这样这个进程写入东西，另外一个进程就可以看到了，大大提高了进程间通信的速度
  - 是**速度最快**的[访问机制](https://blog.csdn.net/weixin_39802020/article/details/112814928)
- 信号量机制：
  - **信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。
    信号量表示资源的数量，控制信号量的方式有两种原子操作：
    - 一个是 **P 操作**，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
    - 另一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程
- 信号：
  - 对于异常的情况下的工作模式，需要用信号的方式来进行通知进程。
    信号是进程间通信机制中的唯一的异步通信机制，任何时候给某一进程发送信息，一旦信号产生，就会有这几种的方式：
    1、执行默认的操作
    2、扑捉信号
    3、忽略信号
- socket：可以用于不同网络，也可以用于本主机



## 使用信号量实现并发

- 操作系统导论里面有例子，可以参考
  - 大于等于0表示可以进入，小于零表示不可进入，要等待
- 百度面经：设计一个线程间同步的场景：多个线程之间轮流输出东西，需要保证输出的顺序。用信号量怎么做？