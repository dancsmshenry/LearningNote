# 哲学家就餐问题

定义

- 假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西
- 哲学家从不交流，容易产生死锁



解决办法

方法一

- 用一把全局的mutex，然后每次只有抢到锁的人才能开始拿左右的筷子
- 每次先看自己左右两边的筷子是否为可使用的
  - 如果可以使用，就去抢全局的mutex
  - 否则就要重新去判断当前两边的筷子是否可用
- 有效解决死锁饥饿的问题，但是效率低下（没抢到锁的人只能一直自旋，浪费cpu）
- 而且，如果有人吃的很频繁的话，就可能造成有人会饿死，即抢不到锁



方法二

- 奇数号哲学家先拿他左边的筷子，然后再去拿他右边的筷子
- 偶数号哲学家则先拿右边的筷子，然后再去拿他左边的筷子
- 但感觉并发度有点差...



方法三

- 限制就餐人员，最多只有4个人就餐（这里假设总共就5个哲学家）
- 那么必然有个人能够吃上饭（所以只要这个人吃完饭，就可以unlock，从而解决死锁）







# 银行家算法

- 是一种避免死锁的方法







# 八股

## 两线程并发问题

- 两个及两个以上的线程实现for循环，每次循环实现+1，循环100次，问最小sum为多少

- ```cpp
  int sum = 0;
  
  void count() {
      for (int i = 0; i < 10; ++ i) {
          ++ sum;  // 假设这里的sum是volititle的
      }
  }
  
  int main() {
      int n = 0;
      cin >> n; // n > 1
      for (int i = 0; i < n; ++ i) {
      	creat_thread(count());
      }
  }
  ```

- 答案最小为2（是一种非常极端的情况）

- 下述假设读到的内容是t，同时下面每一步每一次加法都是先从内存读入数据，然后操作，放回内存，这样的循环的

- | thread01                            | thread(2).....thread(n-1)                          | thread(n)                                  |
  | ----------------------------------- | -------------------------------------------------- | ------------------------------------------ |
  | 从内存中读入sum，t=sum=0            |                                                    |                                            |
  |                                     | 中间所有的线程都重复的将sum读入，将sum写至(n-2)*10 |                                            |
  |                                     |                                                    | 同样的读入sum，将sum写至(n-2)*10+9         |
  | 此时执行t++，写入sum=t，则此时sum=1 |                                                    |                                            |
  |                                     |                                                    | 读入sum（此时t=sum=1），执行t++，则此时t=2 |
  | 执行操作，使得最后写入sum的为11     |                                                    |                                            |
  |                                     |                                                    | 写入此时的t，则此时的sum为2                |





## 使用信号量实现并发

- 操作系统导论里面有例子，可以参考
  - 大于等于0表示可以进入，小于零表示不可进入，要等待
- 百度面经：设计一个线程间同步的场景：多个线程之间轮流输出东西，需要保证输出的顺序。用信号量怎么做？