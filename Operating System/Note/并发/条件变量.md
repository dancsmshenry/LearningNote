# Condition Variable

- 也就是之前说的管程...

- 使我们可以睡眠等待某种条件出现
- 是利用线程间共享的全局变量进行同步的一种机制
- 主要包含两个动作
  - 一个线程等待“条件变量”的条件成立而挂起（阻塞）
  - 另一个线程使“条件变量”成立，给出条件成立的信号
- 为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起
- 条件变量是用来等待线程而不是上锁的，条件变量通常和互斥锁一起使用。条件变量之所以要和互斥锁一起使用，主要是因为互斥锁的一个明显的特点就是它只有两种状态：锁定和非锁定，而条件变量可以通过允许线程阻塞和等待另一个线程发送信号来弥补互斥锁的不足，所以互斥锁和条件变量通常一起使用
- 当条件满足的时候，线程通常解锁并等待该条件发生变化，一旦另一个线程修改了环境变量，就会通知相应的环境变量唤醒一个或者多个被这个条件变量阻塞的线程。这些被唤醒的线程将重新上锁，并测试条件是否满足。一般来说**条件变量被用于线程间的同步；**当条件不满足的时候，允许其中的一个执行流挂起和等待
- 可以用它mutex和条件变量来实现生产者消费者模型







# 虚假唤醒

- 多个线程同时等待同⼀个条件满⾜时，当唤醒线程时，可能会唤醒多个线程，但是如果对应的资源只有⼀个线程能获得，其余线程就⽆法获得该资源，因此其余线程的唤醒是⽆意义的（有时甚⾄是有危害的），其余线程的唤醒则被称为虚假唤醒
- 所以，为了防止虚假唤醒，就必须要用while循环来判断
- https://blog.csdn.net/anwh9295/article/details/120444596







# 参考

https://blog.csdn.net/qq_39736982/article/details/82380689