# 进程和线程的区别

- 进程有自己的独立地址空间，线程没有
- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 线程的通信比较方便（同一进程的线程可以共享数据，例如全局变量或者静态变量）
- 进程上下文切换的开销比线程上下文切换的开销要大
- 一个进程挂了不会影响其他进程，而线程挂了会影响其他线程



# 为什么说进程上下文切换比线程上下文切换代价高

- 进程的切换分为两步：
  - 切换页目录以使用新的地址空间
  - 切换内核栈和硬件上下文
- 进程切换比线程切换成本大的地方在需要切换地址空间
- 切换地址空间会导致TLB刷新，导致一段时间内的内存访问相当低效

- 线程的切换是不会切换内存的（https://pluscb.xyz/2021/10/04/%E7%BB%93%E5%90%88%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E8%B0%88%E8%B0%88-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E6%AF%94%E8%BF%9B%E7%A8%8B%E5%BF%AB/）







我理解的用户态线程和内核态线程的关系

- 用户一般使用的都是用户态线程，如果我们要用到系统调用（read，write等）或中断，就会切换到内核态线程（这里就是黄成b博客里面所说的，线程的页表的切换）
- 而用户态线程和内核态线程的对应关系有很多的模型，例如一对一模型，多对一模型，多对多模型
- 一般我们用的就是一对一模型
- 这有点类似于线程池的感觉了.....



# 用户线程

- 用户线程的切换由用户态程序自己控制切换，不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu,目前Linux pthread大体是这么做的
- 指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应 用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线 程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少





# 内核线程

- 由操作系统创建和销毁，内核维护进程及线程的上下文信息以及线程切换，一个内核线程由于IO操作而阻塞，不会影响其他（内核）线程的运行
- 切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的





















- 线程一直是分系统级线程和用户级线程，也就是所谓的 1:1线程模型和 1:n线程模型。
- 注意Linux2.4版本之前pthread用的LinuxThread实现，和Linux2.5以后pthread用的NPTL（据说比较好支持了POSIX线程标准）,都是系统级别的1:1线程模型，都是系统级线程
- LinuxThread的内核对应的管理实体就是进程，又称LWP（轻量级进程），每个线程的pid是不一样的（但是getpid返回的都是其进程的pid）



- 重要的是系统调用clone()，大家熟知的fork()函数就是调用clone()来实现父进程拷贝的从而创建一个新进程的。
- 系统调用clone()里有一个flag参数，这个参数有很多的标志位指定了克隆时需要拷贝的东西，其中标志位CLONE_VM就是定义拷贝时是否使用相同的内存空间。
- fork()调用clone()时没有设置CLONE_VM，所以在内核看来就是产生了两个拥有不同内存空间的进程。
- 而pthread_create()里调用clone()时设置了CLONE_VM，所以在内核看来就产生了两个拥有相同内存空间的进程。所以用户态创建一个新线程，内核态就对应生成一个新进程（所以这里的意思是，当生成一个线程，实际上会在用户态生成一个用户态线程，然后通过lwp映射到内核的内核线程，然后实际上内核的调度管理就是调度这个轻量级线程）



- 另外，看到网上很多文章说，POSIX线程是混合模型，有用户级和系统级线程，通过一个参数来选择。等等。我是这样理解的：
- POSIX只是一个协议，各个系统的实现不一样。我只知道LInux的线程是系统级线程，是内核参与调度的，是操作系统可见的。不管LinuxThread还是NPTL都是这样的



# 进程切换为什么比线程慢

- 进程的切换会涉及虚拟地址空间的切换，这就导致内存中的页表也需要进行切换，一个进程对应一个页表是不假，但是 CPU 中的 TLB 只有一个啊，这就尴尬了，页表切换后这个 TLB 就失效了。这样，TLB 在一段时间内肯定是无法被命中的，操作系统就必须去访问内存，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢
- 而线程的切换就不涉及虚拟地址空间的切换，就不存在问题了



- 还有就是寄存器的修改





# 等待解决的问题

- 进线程，协程的切换，快慢，代价https://blog.csdn.net/weixin_37841366/article/details/109237089
- 进程，线程同步，通信的各种方式



# 参考

- https://blog.csdn.net/qq_41489540/article/details/109261692
- https://www.cnblogs.com/wanglulu/p/5522809.html
- https://blog.csdn.net/lxq19980430/article/details/102764018
- https://blog.csdn.net/ctthuangcheng/article/details/8914309
- http://www.cnitblog.com/tarius.wu/articles/2277.html
- https://blog.csdn.net/gatieme/article/details/51481863
- https://kernel.blog.csdn.net/article/details/51482122
- https://www.cnblogs.com/charlesblc/p/6242518.html
- https://blog.csdn.net/qq_42011541/article/details/102711196
- https://blog.csdn.net/gatieme/category_6225543.html?spm=1001.2014.3001.5482
- https://kernel.blog.csdn.net/article/details/52384965
- https://blog.csdn.net/ctthuangcheng/article/details/8914444
- https://blog.csdn.net/gatieme/category_6225543.html?spm=1001.2014.3001.5482
- https://blog.csdn.net/gatieme/category_6393814.html?spm=1001.2014.3001.5482
- https://blog.csdn.net/gatieme/category_1840439.html