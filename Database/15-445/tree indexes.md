# 索引

- DBMS的工作是找出用于执行每个查询的最佳索引，对于每个数据库要创建的索引数量有一个权衡
  - 存储开销
  - 维护开销



# B-tree family

- ![](image/B-tree family.png)
- B+树是一种自平衡的树状数据结构，它保持数据的排序，并允许在O(log n)范围内进行搜索、顺序访问、插入和删除
- B+树是完全平衡的
- 除了根节点外的所有结点至少是半满的
- ![](image\B+tree example_01.png)
- 每个B+树结点都是由一个键/值对的数组组成的
- 键是从索引所基于的属性中派生出来的
- 值将根据节点是内部节点还是叶节点而不同
- 数组通常按照键顺序保存



# B+树的叶子结点

- ![](image/B+tree leaf nodes_01.png)
- ![](image/B+tree leaf nodes_02.png)

- 主要存储的内容有：
  - 记录id：指向索引项对应的元组位置的指针
  - 元组数据：元组的实际内容存储在叶子节点中，二级索引必须存储记录id作为它们的值
  - 相比B-树，B+树只在叶子节点存储数据







# B+树的插入

- 先找到要插入的叶子节点
  - 如果叶子节点有空间的话，按照顺序放入数据
  - 否则，将叶子节点拆分为两个节点，平均分配键值对
  - 在当前节点的父子节点中插入新增节点的索引







# B+树的删除

- 先要找到要删除的数据所在的叶子节点
  - 如果删除该节点后数据仍然大于一半，则可以直接删除，后续不用理了
  - 否则
    - 尝试重新分配，从相同父节点的相邻节点借数据合并
    - 如果分配直白，就合并父节点和其他兄弟节点
  - PS：如果发生了合并，就要从父节点中删除当前节点的索引







# 聚簇索引

- DBMS会按照主键指定的排序顺序存储数据
  - 可以是堆或者索引阻止的存储
- 很多DBMS会使用聚集索引
- 如果一个表不包含主键，DBMS会为他们生成一个隐藏的row id主键





# B+树的数据设计



### 节点的大小

- 存储设备越慢，B+树的最佳节点大小就越大
- 根据工作负载的不同，最佳大小可能有所不同
- 需要权衡的是对于叶子节点的扫描和根节点到叶子节点的遍历



### 触发合并条件的阈值

- 存在DBMS在节点未满的时候不会合并节点
- 延迟合并操作可能会减少重组的数量





### key的长度设定

- 方法一：将键存储为指向元组属性的指针
- 方法二：设定每个节点的长度为可变长度，但是麻烦的是需要对其进行内存管理
- 方法三：始终给每个键选择的大小为最大值
- 方法四：嵌入一个数组，数组的指针指向最终的key+value





### 非唯一索引

- 方法一：多次存储重复的键值
- ![](image/non-unique_01.png)
- 方法二：每个键只存储一次，并维护唯一值的链接列表
- ![](image/non-unique_02.png)



### 节点的搜索

- 方法一：线性搜索，从头到尾扫描节点键
- 方法二：二分查找
- 方法三：插值法（根据已知的几个数据的位置，推断要查询的数据在哪儿）





# 一些索引上的优化



### 前缀索引

- Prefix Compression
- 同一个叶子节点中排序的键可能会用重复的前缀
- 所以，与其每次存储整个键值，不如提取前面通用的前缀，然后只存储每个键不同的后缀



### 后缀截断

- Suffix Truncation
- 有一种情况，前面几个前缀就足以区分不同的数据了，没必要把全部的数据都保存
- 所以可以把多余的后缀去掉



### Bulk Insert

- 构造B+ 树最快的方式，先将所有key排序，然后自下向上建树



### Pointer Swizzling

- 背景：
  - 节点使用页面id来引用索引中的其他节点。DBMS必须在遍历期间从页表中获取内存位置

- 但，如果已知的page在内存中，那么就不需要先去查页表再得到数据，而是直接记录其在内存中的地址，用的时候直接查就行了