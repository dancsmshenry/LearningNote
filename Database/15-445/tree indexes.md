# index

- DBMS的工作是找出用于执行每个查询的最佳索引
- 定义：是表中一部分数据的副本
  - 比如有一个公司内部人员的表，要按照年龄建立索引，一般来说将年龄和用户的id抽取出来单独做一个副本，这个小表只有两列，一个是年龄，一个是id
  - 同时这个小表是有排序的，即按照年龄进行排序
  - 把大表的某些列作为小表

- 这个小表和大表逻辑上是同步的
  - 如果在大表上添加了一个新的员工的信息，那么小表上也要同步上来

- 目的：执行的时候能够加速查找插入删除
- 权衡：存储的开销（索引本身的大小）；维护的开销（对于大表的增删改查也要同步到索引上去，维护的效率权衡；如果建立的索引太多，那么任何一个写操作都会需要更多的成本去维护）







# B+tree overview

- <img src="image/B-tree family.png" style="zoom:150%;" />
- B+树是一种自平衡的树状数据结构，它保持数据的排序，并允许在O(log n)范围内进行搜索、顺序访问、插入和删除
- 并且B+树也支持线性遍历
- B+树是完全平衡的
- 对于在磁盘上读取一整页一整页的数据是有优势的
- 除了根节点外的所有结点至少是半满的
- 是一个多路查找树，是一棵M路查找树
- 它的每个结点的数据的数量的范围是m/2-1到m-1之间
- 一般来说B+树的非叶子结点存储的是一个数对，first是指向一个新的结点，表示这个结点的所有值都小于当前的值，second就是当前结点的值
- 而叶子结点，first一般存放的是主键id，second存放的是具体的数值
- B+树的最底层是一个分了块的链表
- ![](image\B+tree example_01.png)
- 每个B+树结点都是由一个键/值对的数组组成的
- 键是从索引所基于的属性中派生出来的
- 值将根据节点是内部节点还是叶节点而不同
- 数组通常按照键顺序保存



# B+树的叶子结点

- ![](image/B+tree leaf nodes_01.png)
- ![](image/B+tree leaf nodes_02.png)

- 主要存储的内容有：
  - 记录id：指向索引项对应的元组位置的指针
  - 元组数据：元组的实际内容存储在叶子节点中，二级索引必须存储记录id作为它们的值
  - 相比B-树，B+树只在叶子节点存储数据







# B+树的插入

- 先找到要插入的叶子节点
  - 如果叶子节点有空间的话，按照顺序放入数据
  - 否则，将叶子节点拆分为两个节点，平均分配键值对
  - 在当前节点的父子节点中插入新增节点的索引







# B+树的删除

- 先要找到要删除的数据所在的叶子节点
  - 如果删除该节点后数据仍然大于一半，则可以直接删除，后续不用理了
  - 否则
    - 尝试重新分配，从相同父节点的相邻节点借数据合并
    - 如果分配直白，就合并父节点和其他兄弟节点
  - PS：如果发生了合并，就要从父节点中删除当前节点的索引







# 聚簇索引

- DBMS会按照主键指定的排序顺序存储数据
  - 可以是堆或者索引阻止的存储
- 很多DBMS会使用聚集索引
- 如果一个表不包含主键，DBMS会为他们生成一个隐藏的row id主键





# design choices



### 节点的大小

- 存储设备越慢，B+树的最佳节点大小就越大
- 根据工作负载的不同，最佳大小可能有所不同
- 需要权衡的是对于叶子节点的扫描和根节点到叶子节点的遍历



### 触发合并条件的阈值

- 存在DBMS在节点未满的时候不会合并节点
- 延迟合并操作可能会减少重组的数量





### key的长度设定

- 方法一：将键存储为指向元组属性的指针
- 方法二：设定每个节点的长度为可变长度，但是麻烦的是需要对其进行内存管理
- 方法三：始终给每个键选择的大小为最大值
- 方法四：嵌入一个数组，数组的指针指向最终的key+value





### 非唯一索引

- 方法一：多次存储重复的键值
- ![](image/non-unique_01.png)
- 方法二：每个键只存储一次，并维护唯一值的链接列表
- ![](image/non-unique_02.png)



### 节点的搜索

- 方法一：线性搜索，从头到尾扫描节点键
- 方法二：二分查找
- 方法三：插值法（根据已知的几个数据的位置，推断要查询的数据在哪儿）





# optimizations



### 前缀索引

- Prefix Compression
- 同一个叶子节点中排序的键可能会用重复的前缀
- 所以，与其每次存储整个键值，不如提取前面通用的前缀，然后只存储每个键不同的后缀



### 后缀截断

- Suffix Truncation
- 有一种情况，前面几个前缀就足以区分不同的数据了，没必要把全部的数据都保存
- 所以可以把多余的后缀去掉



### Bulk Insert

- 构造B+ 树最快的方式，先将所有key排序，然后自下向上建树



### Pointer Swizzling

- 背景：
  - 节点使用页面id来引用索引中的其他节点。DBMS必须在遍历期间从页表中获取内存位置

- 但，如果已知的page在内存中，那么就不需要先去查页表再得到数据，而是直接记录其在内存中的地址，用的时候直接查就行了