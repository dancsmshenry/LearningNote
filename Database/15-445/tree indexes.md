# index

- DBMS的工作是找出用于执行每个查询的最佳索引
- 定义：是表中一部分数据的副本
  - 比如有一个公司内部人员的表，要按照年龄建立索引，一般来说将年龄和用户的id抽取出来单独做一个副本，这个小表只有两列，一个是年龄，一个是id
  - 同时这个小表是有排序的，即按照年龄进行排序
  - 把大表的某些列作为小表
- 这个小表和大表逻辑上是同步的
  - 如果在大表上添加了一个新的员工的信息，那么小表上也要同步上来
- 目的：执行的时候能够加速查找插入删除
- 权衡：存储的开销（索引本身的大小）；维护的开销（对于大表的增删改查也要同步到索引上去，维护的效率权衡；如果建立的索引太多，那么任何一个写操作都会需要更多的成本去维护）
  - 其实就是牺牲一定的空间复杂度，降低查询时的时间复杂度








# B+tree overview

- <img src="image/B-tree family.png" style="zoom:150%;" />
- B+树是一种自平衡的树状数据结构，它保持数据的排序，并允许在O(log n)范围内进行搜索、顺序访问、插入和删除
  - 搜索时间的增长是慢于数据的增长的
  - 是二叉树的一个变种

- 并且B+树也支持线性遍历
- B+树是完全平衡的
- 对于在磁盘上读取一整页一整页的数据是有优势的
- 除了根节点外的所有结点至少是半满的
- 是一个多路查找树，是一棵M路查找树
- 它的每个结点的数据的数量的范围是m/2-1到m-1之间
- 一般来说B+树的非叶子结点存储的是一个数对，first是指向一个新的结点，是叶子结点的地址，表示这个子结点的所有值都小于当前的值，second就是当前结点的值
- 而叶子结点，first一般存放的是主键id，second存放的是具体的数值（用于做索引的数值，可以认为是行id）（first是key，second是value）
- 一个叶子结点有多个数据
- B+树的最底层是一个分了块的链表
- ![](image\B+tree example_01.png)
- 每个B+树结点都是由一个键/值对的数组组成的
- 键是从索引所基于的属性中派生出来的
- 值将根据节点是内部节点还是叶节点而不同
- 数组通常按照键顺序保存
- 思考：
  - B+树对于在硬盘上按页进行数据的存取，有一个巨大的优势：如果一个节点中有很多的数据，那么就可以刚好控制整个结点的数据刚好是一个页；即按照结点为单位存储数据，B+树的结点，对应到磁盘的存取就是一页（或者一个结点就是好几个页）
  - hash表天然不是分块，如果要存放到硬盘中，就要想怎么把数据分块，以此方便的存储到硬盘中，因为磁盘是按照页数存储到硬盘中的




# use in a DBMS

- ![](image/B+tree leaf nodes_01.png)
- ![](image/B+tree leaf nodes_02.png)
- 叶子结点前后各有一个指针，指向前一个叶子节点和后一个叶子节点；如果是按照page存储的话，那么结点存储的就是pageid
- 而中间则存储的是一对kv对，k是索引的值（要索引的列），v是行的id
  - v的两种取值：记录的行id（比如说公司员工表中的员工id，感觉有点像是二级索引的味道了....，也可以是记录的行id，查找数据就是拿到了记录的行id，然后去内存中查找）
  - 整个行数据（主键索引，很多数据表本身就是按照B+树存的...，不用回表之类的）
  - ![](image/leaf node values.png)

- 主要存储的内容有：
  - 记录id：指向索引项对应的元组位置的指针
  - 元组数据：元组的实际内容存储在叶子节点中，二级索引必须存储记录id作为它们的值
  - 相比B-树，B+树只在叶子节点存储数据
- B树会将数据存储在非叶子节点上，空间上更加的高效；而且每个键值只出现了一次；但是缺点就是，如果先要进行范围查找的话，就要进行中序遍历，时间（遍历、读取数据页的时间）空间（可能会将一些不要的磁盘页读入）上比较差





## selection conditions

- ![](image/selection conditions_01.png)
- ![](image/selection conditions_02.png)
- 这里在第一个叶子结点查到A之后，就会往右边，即下一个叶子结点继续找
- 而如果要找的是find key = (*,B)的话，他就会跳着搜索，你比如说先找AB，再找BB，再找CB，一直这样找下去，这个叫做skip scan条约搜索，虽然比全表扫描好很多，但是效率还是不如普通的二分查找
  - 所以，一般模糊搜索都建议要走右模糊，因为要尽量确定做左边的值，这样就可以把要查询的范围收窄







## B+tree - insert

- 先按照索引遍历，然后把数据按照索引的位置插入

- 先找到要插入的叶子节点
  - 如果叶子节点有空间的话，按照顺序放入数据
  - 否则，将叶子节点拆分为两个节点，平均分配键值对
  - 在当前节点的父子节点中插入新增节点的索引







## B+tree - delete

- 先要找到要删除的数据所在的叶子节点
  - 如果删除该节点后数据仍然大于一半，则可以直接删除，后续不用理了
  - 否则
    - 尝试重新分配，从相同父节点的相邻节点借数据合并
    - 如果分配失败，就合并父节点和其他兄弟节点
  - PS：如果发生了合并，就要从父节点中删除当前节点的索引
- 有些时候可能会出现那删除数据后延迟合并的现象，因为可能现在留有了空位，但是不久后又会放入新的数据进来，所以会延迟合并





## B+tree - duplicate keys

- 如果两个逐渐的值相同了该怎么办
- 方法一：给这个排序的key后面加上行id
  - ![](image/B+tree append record id.png)
- 方法二：给当前的页后面外界一个新的页，把重复值的页放到外界的页上边
  - ![](image/B+tree - overflow leaf nodes.png)





## clustered indexs

- 聚集索引，聚簇索引
- 判断：数据是不是按照主键索引去阻止的（行的数据是集成在了主键索引中，此时的索引就是聚簇索引，即索引本身把数据给阻止起来了，例如mysql）
- 不是聚簇索引的：数据的kv对中，v存储的是数据的页号和对应的slot号，即要进行回表才能获取到具体的数据

- DBMS会按照主键指定的排序顺序存储数据
  - 可以是堆或者索引阻止的存储
  
- 很多DBMS会使用聚集索引

- 如果一个表不包含主键，DBMS会为他们生成一个隐藏的row id主键

- ![](image/聚簇索引.png)

  - 数据的组织方式和存储方式是一致的（范围扫描上是非常的方便的）

- ![](image/非聚簇索引.png)

  - 在非聚簇索引中相邻的数据，在物理存储中位置都不一定是相邻的
  - 优化：记录好要读取的页有哪些，然后一次性把他们都预读出来

- intra-node search

  非唯一索引

  - 方法一：多次存储重复的键值
  - ![](image/non-unique_01.png)
  - 方法二：每个键只存储一次，并维护唯一值的链接列表
  - ![](image/non-unique_02.png)







# B+tree design choices

- B+树的一些优化改进的设计



## node size

- 存储设备读取数据的速度越慢，B+树的最佳节点大小就越大
  - 存取一次，尽量把更多的数据读会内存（提高效率）
  - 一些直接在内存中的数据库要求在内存中结点要求要小（读到的冗余数据越少，查询效率更高）

- 根据工作负载的不同，最佳大小可能有所不同（取决于用户）
- 需要权衡的是对于叶子节点的扫描和根节点到叶子节点的遍历
  - 如果经常是全表遍历的话，B+树的结点最好大一点，因为这样存储的数据更多（比如OLAP型）
  -  而如果是点查询多的话，比如OLTP型的话，就需要小一点的B+树结点，因为点查询会在结点之间跳跃，如果page比较小的话，可以降低开销

- 最好和文件页的大小一致，或者等于文件页大小的倍数



## merge threshold

- 触发合并条件的阈值

- 存在DBMS在节点未满的时候不会合并节点
- 延迟合并操作可能会减少重组的数量
  - 因为两个结点的合并，可能会引起上层的变化




## variable-length keys

- 变长的key的处理

- 方法一：将键存储为指向元组属性的指针，保证每个值都一样长
- 方法二：设定每个节点的长度为可变长度，但是麻烦的是需要对其进行内存管理（不太推荐）
- 方法三：始终给每个键选择的大小为最大值（给不够最大值的补上padding）
- 方法四：嵌入一个数组，数组的指针指向最终的key+value（存入的是slot）



## intra-node search

- 在节点内部搜索具体的数据
- 一个节点是16K，而一行数据也就几百字节，则一个节点可以存储几百上千条数据

- 方法一：线性搜索，从头到尾扫描节点键
- 方法二：二分查找
- 方法三：插值法（根据已知的几个数据的位置，推断要查询的数据在哪儿）







# optimizations

- 相关的优化



## Prefix Compression

- 前缀压缩

- 同一个叶子节点中排序的键可能会用重复的前缀
- 所以，与其每次存储整个键值，不如提取前面通用的前缀，然后只存储每个键不同的后缀
- ![](image/prefix compression.png)



## deduplication

- 有一种情况，前面几个前缀就足以区分不同的数据了，没必要把全部的数据都保存
- 所以可以把多余的后缀去掉
- ![](image/deduplication.png)
- 我理解就是，发现这几个不同的value对应的key都是一样的，所以就把它们都压缩到一起



## Bulk Insert

- 构造B+ 树最快的方式，先将所有key排序，然后自下向上建树
- 按批插入
  - 因为我们知道一个一个插入值到B+树里面是非常低效的，所以就把这些数据先排序组成一个b+树
  - 然后把这个b+树merge到主b+树里面




## Pointer Swizzling

- 背景：
  - 节点使用页面id来引用索引中的其他节点。DBMS必须在遍历期间从页表中获取内存位置

- 但，如果已知的page在内存中，那么就不需要先去查页表再得到数据，而是直接记录其在内存中的地址，用的时候直接查就行了







# conclusion

- B+树几乎一直都是做数据库索引的准则