# multi version concurrency control

- 乍一看好像是第三种并发控制，但是实际上并不是的，它经常和前面几种方法联合在一起做并发控制（例如mysql就是利用mvcc和2PL做并发控制的）

- DBMS在数据库中对每个数据都维护多个版本
- 当事务对数据进行修改的时候，DBMS会创建该数据的一个新的版本
- 当事务要读取数据时，会读取在当前事务启动时，当前事务存在的最新的版本



## 宗旨

- 为什么会有MVCC的思路
  - 你把数据更新了以后，别的事务就无法读取了（因为更新了数据，数据变成了新的版本，别的事务读这个数据就会发生冲突，所以只能等到其他事务提交了以后才能够继续读），所以2PL的操作就是把它锁住（但是这里的问题就是会降低并发度）
- 由此mvcc的思路就是，留下数据的历史版本，即 就算给了数据，但本地读的时候还是可以留下历史版本对数据进行读写
- 即把数据改了，是不会阻塞其他事务去读它的历史版本的，换言之，要留下历史版本给其他事务读取
- 总结：writers do not block readers
- 2PL中读数据会加上S锁，而S锁会导致数据无法修改
- 而有了mvcc的话，数据的写入只是给它加了一个新的版本，并没有真正的修改数据
- 总结：readers do not block writers



## 推论

- 我们的事务可以去读一个一致性的快照snapshot（相当于无锁读）
  - 即数据库的读数据不受其他事务的影响
  - 因为数据库读到的当时需要到的版本，就像是读一个静态的数据库一样
- 所以需要用时间戳记录版本号
- 因此mvcc也实现了一个类似时间旅行的效果
  - 如果没有mvcc，那么读取三分钟之前的数据，就很难；有了mvcc的话，就可以直接读取版本号





## example

- example1
  - 事务一读数据会检查当前的版本，而此时的版本是T0，所以可以直接读取；而事务二写数据，发现当前版本小于自身，因此在table中添加一条新的记录，该记录的begin为当前记录的版本号
  - 此时的全局会维护一个txn table（方便互相查明事务的状态）
  - 而此时事务一又要去读数据，就要找到当前事务对于的版本读取数据
  - 这样就达到无锁的串行化的执行事务
- example2（快照隔离）
  - 其实这里事务二的读取很关键，首先，事务一是发生在事务二之前，那么按照可串行化的意思，事务二的数据应该是基于事务一的操作基础上的；但是呢，如果事务一发生了abort，那么事务二读到的数据就是虚空了的，其实从这里就可以看出mvcc的一个缺点，就单单mvcc是无法实现串行化的..
  - 而mvcc的处理就是，让事务二读到的数据是事务一修改之前的（因为认为此时的数据是脏数据，所以就不能读）
  - 而此时事务二要修改数据，发现事务一有一个未提交的事务数据，所以会wait到事务一结束，才能继续修改
  - 而这其实是oracle的最高隔离级别快照隔离snapshot 隔离，不是串行化（需要用2PL或TO去实现串行化）
  - 只依赖mvcc是无法实现串行化的，而oracle用mvcc实现的是快照隔离，即使用多版本的数据对不同的事务进行隔离



- MVCC不仅仅是并发控制的手段，更是DBMS管理事务的手段
- 几乎所有的DBMS都实现了mvcc







# concurrency control protocol

- 只使用mvcc无法实现可串行化的
- mvcc和多种方法结合，比如TO，OCC，2PL
- 其实我有一个问题，其实2PL、严格2PL + 间隙锁就可以实现很多的隔离级别，但是这里为什么不行
  - 我觉得的一个解释就是，使用mvcc可以提高并发度，即一定程度的不阻塞读（依靠的就是本地保留这个数据）
  - 即2PL其实是可以实现的，但是会减损一些并发度，所以要使用mvcc（使得原本的范围变得宽松而合理一些）








# version storage

- 新老的数据库的版本是如何存储的

- DBMS用一个记录的指针
- 在数据库里面建立一个版本的链表，记录版本号（在链表上寻找版本）



## append only storage

- 简单追加
- 新版本被追加到同一个表中，单独把数据放到一个表中

- 有一个数据表，如果要追加一条数据的话，其实相当于往数据表里面追加了一条数据
- 每一行的每一个版本都在同一个数据表里面，就打比方说table里面存了十条记录，但其实这存了比十条数据更多的数据，因为要存储每个历史的版本
- 即每一行的每个版本，都是放在同一个数据表里面，每行记录是版本的数据以及指针
  - 对于一条要新追加的记录，首先插入一条新的数据记录，然后找到此时除去当前记录外最新的版本，将该版本的指针指向这个新的数据记录



两种实现思路

- 第一种是将新的数据追加到链表后面（Oldest-to-Newest）
  - 如果索引要查找数据，那么索引就要从头开始查找，从老的版本一直直到新的版本位置
  - 即追加的开销小，查找的开销大
- 第二种是将新的数据追加到链表前面（Newest-to-Oldest）
  - 如果索引要查找数据，那么从头开始找即可
  - 问题是追加的开销大，查找的开销小



## time-travel storage

- 存在两张表，main table和tiem-travel table
- main table存储的是当前最新的数据，time-travel table存储的是历史的数据
  - table的组成是数据本身和指向数据的指针
  - main table的指针指向的是time-travel table中的数据（因为历史数据必然都放在time-travel table中）
- 插入新的数据的话，首先把当前的数据copy到time-travel table中，然后调整好指针的指向，最后在放入新的数据
- 如果总共有十行记录，那么main table就只有十行记录的最新版本，而time-travle table中就可能会存放很多的历史版本



## delta storage

- 增量存储
- 发现time-travel把整个行记录都存下来，是有点浪费的，于是转变为存储每次的增量变化

- 和time-travel storage类似，不过另外一个表上存储的是数据记录的具体修改
  - 上面存储的数据，都是整条的行数据，有点浪费空间，所以这里就只记录数据修改了哪些位置
- 即如果想要看历史版本，就要调用delta storage segment中的记录逐步回滚
- mysql的做法
- 存储的是每条记录的增量，回滚就按照增量回滚即可
- 优点：可以节约历史版本大小
- 缺点：回滚有点麻烦







# garbage collection

背景

- 不能无限存储历史的版本，所以要删除掉一些历史版本



回收的宗旨

- 如果任何活着的事务都看不到这个版本了，那么这个版本就直接删掉了（如果有一个事务的版本是1，但当前活着的事务的版本都是10以上的，那么事务1的版本就可以删除了）
  - 在快照版本，如果所有的事务都不要他了，就要把它删掉
- 如果一个事务发生了abort，就删掉版本



实现的难题

- 如何发现这些版本
- 什么时候删掉历史版本



## tuple level

- 以行记录为单位
- 去遍历行记录，以此找到哪些没有用的行记录



方法一：background vacuuming

- 后台清理
- 后台的线程对当前发生的事务和历史版本进行扫描对比，如果有数据的版本是小于当前所有的活跃事务的版本，就要清理掉
- 有一个优化，就是如果当前的数据页被更新过了就标记一下，后续就扫描那些被标记过的数据页即可，而不是全表扫描



方法二：cooperative cleaning

- 合作清理
- 执行事务的语句在检索版本的时候顺便查看一下，有哪些版本是没有用的，就把该版本的数据





## transaction-level

- 以事务为单位的垃圾回收
- 记录历史版本，以事务为单位进行回收
- 每个事务记录了当前事务对那些数据进行了读写
- 过了一段时间，DBMS会决定哪些事务的数据版本清理
- 具体操作：
  - 每次修改数据，然后记录修改数据之前的旧版本
  - 然后过一段时间，DBMS决定多少版本号之前的事务都可以干掉了，那么就可以遍历事务，然后把数据的老版本给干掉
- 以事务为单位，清理掉老事务的数据版本







# index management

- 如果修改了主键的值，就要把数据先删除，后插入
- 比较麻烦的是辅助索引



## logical pointers

- 记录的是逻辑索引，需要进行回表操作
- 优点：如果数据发生了更新，那么只需要修改主键索引的地址（因为二级索引指向的是主键索引的位置）



## physical pointers

- 记录的是物理索引，不需要回表

- 缺点：如果二级索引记录的是数据记录的物理地址，那么当有新的版本数据到来的时候，所有的数据记录都要修改



有一个这种的方法：

- 有一个行id和物理地址的映射表
- 当有新的数据页插入时，只需要修改这个映射表即可
- 以此减少辅助索引更新的问题



index不会保存数据的版本号的

- 但是因为mvcc有快照，所以索引需要保存冗余的数据
- 为什么要存储冗余的数据
  - 比如后续的那个例子，事务1第一次读数据A，而事务B修改了数据A，产生了版本二，此时事务三又在原来的位置插入了的数据A
  - 问题来了，事务3插入数据的时候又形成了新的版本（事务3认为此时没有数据，所以产生的版本号居然和事务A产生的是一样的.....）很明显应该不是同一个版本
  - 所以就需要存储冗余的键值，以维护隔离级别..
- 而存储了多余的键值，所以需要额外的逻辑去维护唯一键值等关系







# deletes

- 需要一些方法来查看数据是否在逻辑上被删除
- 其实这里有点没看懂...



## deleted flag

- 在每个行记录上加上一个列，代表该数据是被删掉了的



## tombstone tuple

- 加一个墓碑，代表从这个版本以前这个版本是被删掉的
- 之后新的版本是重新插入的





- 即数据库索引不需要保存版本信息
- 但是数据库需要保存对应索引冗余的数据（即快照）