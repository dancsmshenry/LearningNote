steal + not force

- steal表示把数据页
- not force表示commit的时候不一定要立刻将数据刷盘



有点理解为什么一定要先logging了，因为log时顺序写，效率高，而磁盘业务的io大多都是随机写



flushedLSN

- 上一次刷到磁盘上的log的编号
- 表示，现在有哪些日志被刷到磁盘上去了
- 如果是100的话，就代表前100号日志都已经落盘了，而后面的就还没有落盘，还在内存中
- 位于内存中



pageLSN

- 最近的一次 对当前数据页的修改的 日志编号
- 位于每一个数据页中
- 记录的是 内存中 当前数据页 最新的修改



recLSN

- 从这个页上一次刷盘之后，第一个对该页的修改的日志编号
- 即比磁盘上的数据页新的第一个版本
- 记录的是内存中页最老的修改（比这个内存页更老的修改都已经落盘了）
- 位于每个数据页中
- 即从recLSN到pageLSN之间的日志修改，都存储在了内存中



lastLSN

- 记录目前事务的最后一条日志
- 针对事务的



MasterRecord

- checkpoint点的LSN
- 即checkpoint日志的序列号





事务的提交

当事务在commit以后，实际上内存中的脏页不会立马被刷到磁盘中，而是会在后续才把数据刷盘到磁盘中

所以，当数据真正刷到磁盘中的时候，log中会添加一个txn-end的标志（对于用户来说是未知的）

即commit仅代表日志进了磁盘，但是实际上数据的修改是没有落盘的





事务终止（回滚）

- prevLSN 加在每一条日志后面（作用：记录当前日志的上一条日志是几号）
  - 因为LSN是所有的事务共同使用的，即存在说15号日志的上一条日志14号日志，是其他事务的日志
  - 即prevLSN是为了找到当前事务当前日志记录的前一条日志是多少号



CLR类型日志

- 如果需要回滚日志，那么回滚过程中就插入一条CLR-00x日志，即撤销掉00x号日志（用于将数据回滚到对应原值）
- 其中的undonext值是指要继续往上撤回的日志LSN是多少
- 注意，TXN-END也可以用来表示日志的回滚结束



回滚的具体操作

- 首先要写一个abort的record在log中
- 然后就要撤销该事务所有的update（反向撤销）
- 每次回滚掉一条日志的时候就要加上一条CLR日志，然后再恢复旧的数据
- 全部回滚了以后，要加上一条txn-end日志
- PS：清理日志是不需要被回滚的





些许思考

- 刚才还在想写日志是顺序io（后续特定时机在刷盘），那么用日志是不是就比原来高效
- 其实这里不好说，因为如果不用日志，那么就是直接刷盘，在执行语句的时候性能会受到影响；对比使用日志进行顺序IO来说，执行语句的时候是顺序IO，性能不错，但是后续还是要刷盘的
- 所以，我想说的其实是日志的目的不应该是为了提高执行语句的时候的性能，更加准确的应该是起到崩溃恢复的作用，起到一种对用户的约定（提供ACID的服务）





fuzzy checkpoints

未优化的checkpoint

- 开始checkpoint的时候，要让所有新的事务停止
- 需要把正在进行的事务做完（如果有些事务要执行非常久，就会浪费时间）



slightly better checkpoints

- 不要让所有正在进行的事务结束，而是让他们停下（即让那些需要被刷盘的数据加锁，让那些进行的事务不能修改被刷盘的数据）
- 即将那些正在进行checkpoint的数据加锁，让事务无法对其进行修改



active transaction table

- 活动事务表：记录了做checkpoint的时候，内存中活动的事务
- 组成：
  - 事务ID（txnID）
  - 事务的状态（txn status）（R：running，C：committing，U：还没提交）
  - lastLSN（事务最近的一条日志）



dirty page table

- 记录了recLSN（第一个让这个页变脏的日志，即上次刷盘之后开始的第一个日志）
- 即记录checkpoint此时内存中的脏页



slightly better checkpoint允许不清空所有的事务，也不刷脏页，而是记录下此时的事务和脏页

缺点：尽管没有清空事务，但是还是暂停了事务





fuzzy checkpoint

- 将checkpoint由时间点变为了时间段
- 记录checkpoint-begin和checkpoint-end
- 在checkpoint-begin以前提交的事务的日志及数据都已经刷盘，而未提交的事务则会被记作脏页放在checkpoint-end后面的dirty-table中



aries算法

analysis阶段

- 数据库宕机后将读入WAL文件，先找到masterrecord，即上一次checkpoint的那个点（如果是fuzzy checkpoint，那就是checkpoint-begin），并对其上下的日志进行分析



redo阶段

- 把应该落到磁盘中，但是还没有落到磁盘中的数据进行回放



undo阶段

- 应该回滚但是还没有回滚的数据进行回滚



分析阶段宕机

- 也没有问题，大不了宕机后在分析，反正分析的时候有没有做其他的处理





redo阶段宕机是否有问题

- 没问题，因为redo阶段的数据都是在内存中进行处理的