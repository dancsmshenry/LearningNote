# 引擎的两种结构

- 哈希表
- 二叉树



# 设计决策

- 数据结构的考虑
  - 如何在内存中布局数据结构、存储什么样的信息，才能支持高效的数据访问
- 并发性
  - 如何使多个线程同时访问数据结构而不会出问题





# 哈希表

- 将键映射到值的无序关联数组
- 使用哈希函数计算给定键到数组中的偏移量，从中可以找到所需的值
- 空间复杂度：O(n)
- 查询的时间复杂度：平均为O（1），最差为O（n）





# 静态哈希表

- 分配一个巨大的数组，每个槽位指向具体的数据
- 要查找一个数据，按元素的数量对键进行mod运算，查找其在数组中的偏移量
- 这里的大前提就是：
  - 要知道所有元素的数量
  - 要有一个完美的哈希函数（使得如果key1不等于key2，那么hash(key1)!=hash(key2)）





# 设计hash需要考虑的因素

- 第一，是哈希函数，如何将一个较大的数值域映射到一个较小的域，同时还要权衡计算速度和元素的碰撞率
- 第二，是哈希方案，如何处理散列后的键冲突
  - 在分配一个较大的哈希表和额外的查找插入键指令中进行权衡





# hash函数的设计准则

- 对于任何输入键，返回该键的整数表示形式
- 我们不希望对DBMS哈希表使用加密哈希函数
- 我们想要的是速度快且碰撞率低的东西





# 几种不同的hash函数

- ![](image/hash functions_01.png)
- ![](image\hash functions_02.png)
- ![](image\hash functions_03.png)





# 解决hash冲突的几种办法



## 静态哈希表

- 已知hash表的容量



### 线性探测法

- 通过线性搜索表中的下一个空闲槽来解决冲突（即如果hash到的位置有数据了，就往下一位探测是否可以放数据）
  - 确定一个元素是否存在，哈希到索引中的一个位置并扫描它
  - 必须将键存储在索引中才能知道何时停止扫描（因为可能数据发生了hash冲突导致往后移了一位）
  - 插入和删除是查找的一般化
- ![](image\linear probe hashing_01.png)
- ![](image\linear probe hashing_02.png)





如果其中一个元素被删除了，那怎么做才不影响后续的查询

- 方法一：墓碑标记法：占着被删除元素的位置，但是不存放数据，如有查询就往后传递
- ![](image\linear probe hashing delete_01.png)
- ![](image\linear probe hashing delete_02.png)
- 方法二：移动数据（把后面的数据往前移动）



如果每一个key可以对应多个value的话，该怎么处理

- ![](image\non-unique keys.png)
- 方法一：单独拿一个链表存放数据
- 方法二：在hash表中存储重复的键值





### robin hood hashing

- 线性探测的变体
- 我的理解
  - 方法的原型是线性探测，只是在发生碰撞的时候调整策略不一样
  - 对于放入的数据每次都记录和最佳位置举例（因为是线性探测，所有必然和正确的位置发生偏移）
  - 即，如果发生了碰撞，就往后移动一位，同时计数+1
  - 如果后面的位置继续发生了碰撞，就比较当前计数的大小，如果小于等于后面位置的计数，就继续往后移动
  - 否则就把数据安插在这里，让原来这个位置的数据往后移动
- ![](image\robin hood hashing_01.png)
- ![](image\robin hood hashing_02.png)
- ![](image\robin hood hashing_03.png)





### cuckoo hashing

- 使用多个hash表和不同的hash函数
- 我的理解：
  - 比如说用两个hash表和两个hash函数
  - 对于一个数据，如果可以放在第一个hash表，就放在第一个hash中；否则放到第二个hash表中
  - 如果两个都不能放，就把其中一个拿出来，先放入当前的数据
  - 然后用另一个hash把拿出来的这个数据再hash一边，放到另一个hash表
  - 一直这样来回hash
- ![](image/cuckoo hashing_01.png)
- ![](image/cuckoo hashing_02.png)
- ![](image/cuckoo hashing_03.png)
- ![](image/cuckoo hashing_04.png)



## 动态哈希表



### chained Hashing（拉链法）

- 为哈希表中的每个槽维护一个桶链表，通过将具有相同散列键的所有元素放入同一个bucket中来解决冲突

- 为了确定一个元素是否存在，哈希到它所在的桶中并扫描它
- 插入和删除是查找的一般化
- ![](image\chained hashing.png)



### extendible hashing

- 多个槽位的指针指向同一个桶链
- https://blog.csdn.net/qq12323qweeqwe/article/details/124576114
- 我理解的
  - 对于每个数据用hash算法算出一个数，然后转换为二进制，放到对应的桶里面
  - 如果桶里面满了的话，就分裂（比如说现在只比较前两位，分裂以后就会比较前三位）
- ![](image/extendible hashing_01.png)
- ![](image/extendible hashing_02.png)





### linear hashing

- 哈希表维护一个指针，用于跟踪下一个要分割的桶
- 当任何一个桶溢出时，将桶在指针所在位置进行分割
- 使用多个哈希值为给定的键找到正确的桶
- 可以使用不同的溢出标准
  - 空间利用率
  - 溢出链的平均长度
- ![](image/linear hashing_01.png)
- ![](image/linear hashing_02.png)



- 在拆分指针的基础上，拆分每个桶，能够到达每个溢出的存储桶



删除

- 找到对应的slot，然后删除元素
- 如果桶里面没有元素，就把桶给删除了