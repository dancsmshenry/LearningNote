### DBMS的前提

- DBMS假定数据库的主要存储位置在非易失性磁盘上
- DBMS的组件管理数据在非易失性存储和易失性存储之间移动





### 分层存储器体系

- ![](image\storage hierarchy.png)
- 内存（memory）:
  - DRAM：动态随机存储器
- 硬盘（disk）：
  - SSD：固态硬盘
  - HDD：机械硬盘
- ![](image\access times.png)





### DBMD的设计目标

- 允许DBMS管理超过可用内存容量的数据库
- 因为对磁盘的读/写开销很大，所以要尽量避免出现大的停顿和性能下降





### 为什么不用OS管理DBMS

- OS对内存页的置换策略可能不适合DBMS的业务需求
- 当有多个读者写入由mmap映射的文件的时候，情况会很糟糕（因为os并不会对文件进行并发控制）



同时，DBMS也有自己的业务需求

- 按照正确的顺序将脏页刷新到磁盘
- 专业的预先处理（比如说提前取出一些缓存数据）
- 缓冲区的替换策略
- 线程/进程的调度



综上，os不适合对数据进行管理





### 问题一：DBMS如何用磁盘上的文件表示数据库

### file storage

文件存储（文件在磁盘上是如何存储的）



#### 背景

- DBMS将数据库作为一个或多个文件存储在磁盘上
- 操作系统对这些文件的内容一无所知



- 页面是一个固定大小的数据块，包含元组，元数据，索引，日志记录
- 每个页面有一个唯一的标识符
- DBMS使用一个间接层来映射页面id到物理位置



#### 页面的概念

- 硬件页面（4KB）
- 操作系统页面（通常4KB）
- 数据库页面（512B-16KB）



#### 存储文件的方式

- 堆文件组织
- 顺序/排序文件组织
- 哈希文件组织



#### 堆文件

- 堆文件是页面的无序集合，其中元组以随机顺序存储
- 所以需要元数据来跟踪存在哪些页面以及哪些页面有空闲空间
- 所以有两种表示堆文件的方法
  - 链表
  - 页目录



##### 链表

- 在文件的开头维护一个头页，存储两个指针
  - 空闲页面列表的头部
  - 数据页列表的头部
- 每个页面都跟踪自己的空闲槽的数量
- ![](image\linked list.png)



##### 页目录（字典）

- 维护跟踪数据库文件中的数据页位置的特殊页
- 记录每个页面的空闲槽位数
- ![](image\page directory.png)





### page layout

页面布局（数据在文件上是如何存储）

- 每个页面都包含一个关于页面内容的元数据头
  - 页面大小
  - 校验和
  - DBMS版本
  - 事务的可见性
  - 压缩信息



#### 存储数据的方式

- tuple-oriented
- 日志结构
- PS：存储的不只是元数据，平常的操作的记录也要保存的



##### tuple-oriented

- 跟踪页面中元组的数目，然后只在末尾追加一个新的元组
- 删除就直接去掉这一行
- ![](image\tuple storage.png)
- 具体的实现方式：每个槽位都放着一个指针，指针指向真正数据存放的位置
- ![](image\slotted pages.png)
- slots数组映射到元素的起始位置偏移量





##### 日志结构

- 系统将日志记录追加到数据库修改的文件中，插入存储整个元组
  - 删除将元组标记为已删除
  - 更新只包含被修改的属性的增量
- ![](image\log structured.png)
- 构建索引以允许它跳转到日志中的位置
- 同时，为了节省空间，需要定期压缩日志







### tuple  layout

元组布局（数据的结构）



#### tuple header

- 每个元组都有一个包含有关它的元数据的头作为前缀
  - 可见性信息（并发控制信息）
  - NULL值的位图



#### tuple data

- 属性通常按照创建表时指定的顺序存储
- 可以在物理上对相关元组进行反规范化(例如：预联接)，并将它们存储在同一个页面中
  - 潜在地减少了常见工作负载模式的I/O
  - 会使更新更昂贵
  - ![](image\denormalize tuple data.png)
- DBMS需要一种方法来跟踪单个元组，每个元组被分配一个唯一的记录标识符
  - 最常见的:page_id +偏移/槽
  - 也可以包含文件的位置信息





### 问题二：DBMS如何管理它的内存并在磁盘上来回移动数据

### 数据表示

- 使用原生cpp的数据类型，通常比任意精度数字块，但是会存在舍入误差的情况
- ![](image\variable precision numbers.png)
- 小数之类的通常存储在一个精确的、可变长度的二进制表示中，并带有额外的元数据
- 类似于VARCHAR，但是不存储string
- Demo：Postgres, SQL Server, Oracle



- 大多数dbms不允许元组超过单个页面的大小，要存储大于一个页面的值，DBMS使用单独的溢出存储页面
- 有些系统允许在外部文件中存储非常大的值，作为BLOB类型处理
  - Oracle: BFILE数据类型
  - 微软:FILESTREAM数据类型





### 系统目录

- DBMS将关于数据库的元数据存储在其内部目录中。

  →表、列、索引、视图

  →用户,权限

  →内部统计数据

  几乎每个数据库管理系统本身都会存储它们的数据库目录。

  将对象抽象封装在元组上。

  →用于“引导”目录表的专用代码





### 存储模型

关系模型没有指定必须将元组的所有属性一起存储在单个页面中

DBMS可以以不同的方式存储元组，这些方式更适合OLTP或OLAP工作负载

OLTP（行存储）

- On-line Transaction Processing

- 在线事务处理
  - 读取/更新与数据库中单个实体相关的少量数据的简单查询



OLAP（列存储）

- On-line Analytical Processing
- 联机分析处理
  - 跨多个实体读取大量数据库的复杂查询



![](image\workload characterization.png)





- DBMS将一个元组的所有属性连续地存储在一个页面中（适合OLTP）
- 在这种情况下，查询往往只对单个实体进行操作
- DBMS将一个元组的所有属性连续地存储在一个页面中
- ![](image\NSM.png)
- 优点
  - 快速插入，更新和删除
  - 适合需要整个元组的查询
- 缺点
  - 不适合扫描表的大部分属性的子集



- DBMS存储一个页面中连续的所有元组的单个属性的值（适合OLAP）
- ![](image\DSM.png)
- 列式存储的两种方式：
  - 一种是固定长度的偏移，每个值对于一个属性来说都是相同的长度
  - 另一种是对于还有每个属性的列，都加上该元组的id
- ![](image\tuple identification.png)
- 优点
  - 减少浪费的I/O量，因为DBMS只读取它需要的数据
  - 更好的查询处理和数据压缩
- 缺点
  - 由于元组拆分/拼接，点查询、插入、更新和删除速度较慢