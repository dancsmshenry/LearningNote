## golang是否需要协程池

- goroutine的初衷就是轻量级的线程，为的就是让你随用随起，结果你又搞个池子来，这不是脱裤子放屁么？你需要的是限制并发，而协程池是一种违背了初衷的方法



- 池化要解决的问题一个是频繁创建的开销，另一个是在等待时占用的资源。goroutine 和普通线程相比，创建和调度都不需要进入内核，也就是创建的开销已经解决了。同时相比系统线程，内存占用也是轻量的。所以池化技术要解决的问题goroutine 都不存在，为什么要创建 goroutine pool 呢？



但是，是否需要协程池还需要看具体的场景

- 比如说，如果对每个client都起一个goroutine，很快机子的内存就会被耗尽的，所以需要用协程池对内存做出限制，也不能说是协程池，应该是goroutine池（gotoutine和传统的协程是有很大的区别的）
- 使用协程池将让多余的请求进入排队状态，等待池中有空闲协程的时候来处理，这是模拟的I/O多路复用机制
- 或者说，面对高并发低延时的情况，如网关，可能是go的调度还是有问题把，所以还是要省着用goroutine



- 额，我感觉我应该能够说一说这个问题。我以前也觉得Go是不需要复用goroutine，毕竟据说“非常轻量级”……但是，其实很多时候话不能说死了。应该是98.72531%的场景下，你不需要goroutine池，剩下不到2%的case，大多数人应该也遇不到，所以说“不需要协程池”，几乎是正确的。

  那剩下不到2%的case是啥呢？——超高并发低延时的case，比如做网关。我们的网关目前单机2W+的QPS，是非常极端的场景了。有人可能网上blog看多了，觉得2W好意思拿出来说，别人都是百万级，C100K。额，具体区别就不多说了，如果认识人，可以问问微博feed流，百度大搜等等高峰期单机有多大的QPS…

  说这个的意思就是，我用Go的生产环境中应对过大流量，所以知道Go的Scheduler还是不够好，Go的协程调度还是挺坑的，感兴趣可以搜搜TiDB的吐槽，他们也是重度用户，极端压力下的goroutine调度，真心让人抓狂。

  所以，这种case下，goroutine要省着用，不然你pprof里大部分时间就花在runtime.findRunableG上了。最简单的例子，假设你每秒new 5W个goroutine，但是每个goroutine至少运行2秒，你系统内的g就会堆积，越来越多，然后scheduler负担越来越重，导致每个goroutine耗时比2秒更长，导致堆积更加严重，然后你的系统就崩溃了。所以，这种时候goroutine一定要省着用。当然你说你可以限流，但是那也得保证goroutine回收的速率不高于生产的速率。

  不过以上case都是极端场景下才会遇到，对于98%几十几百QPS的服务，那肯定就不需要了





- 一般情况下，goroutine在操作系统上只要你的硬件资源够它是可以无限启动的。但是如果出现大规模的启动goroutine的情况会造成大量占用系统资源，我们知道普通的部署一个golang应用的时候操作系统不仅仅会运行golang程序还有其他辅助的程序运行，所以理论上讲工作池的目的就是为了限制golang的启动数量，保证不会出现硬件计算资源溢出的情况



# Golang 开发环境的配置

```shell
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
# 如果出现了问题，就需要使用 unset GO
```

