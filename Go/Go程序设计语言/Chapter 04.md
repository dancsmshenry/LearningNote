# 4.1 数组

数组是具有固定长度且拥有零个或多个相同数据类型元素的序列

数组的长度是**固定**的，因此大多数用的是slice（切片）

```go
//	数组的建立
var arr1 [3]int
var arr2 [3]int = [3]int{1, 2, 3}
arr3 := [3]int{1, 2, 3}

//	返回数组的长度
length := len(arr1)

//	数组的长度由初始化数组的元素个数决定
arr4 := [...]int{1, 2, 3}

//	一种奇怪的定义方式
r := [...]int{99: - 1}	//	定义了一个拥有100个元素的数组r，除了最后一个元素值是-1外，该数组中的其他元素值都是0
```

默认情况下，一个新数组中的元素初始值为元素类型的零值

数组的长度是数组类型的一部分，所以`[3]int`和`[4]int`是两种不同的数组类型

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2 ,3 ,4}	//	错误的，类型不同不能赋值

//	因此，相同类型的数组才可以进行赋值和比较
a := [2]int{1, 2}
b := [...]int{1, 2}
fmt.Println(a == b)	//	类型相同的数组可以比较，不同的话就不行
```

如果把数组当做函数的参数进行传参的话，那么每个传入的参数都会是原数组的一个副本，而不是原始的数组参数

```go
//	如果想要传递原来的数组的话，就需要传递数组指针
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```





# 4.2 Slice

slice表示一个拥有相同类型元素的可变长度的序列，通常写为[]T

slice有三个属性：指针、长度和容量

指针指向数组的第一个可以从slice中访问的元素

长度是指slice中的元素个数

容量的大小通常是从slice的起始元素到底层数组的最后一个元素间元素的个数

内置函数len和cap用来返回slice的长度和容量

```go
//	slice的定义
var arr1 []int
arr2 := make([]int, 1, 1)	//	指定切片长度为1，容量为1
```

**一个底层数组可以对应多个slice**，这些slice可以引用数组的任何位置，彼此之间的元素还可以重叠

```cpp
var arr1 []int = []int{1,2,3,4,5,6,6,7,8}
//	使用操作符s[i:j]可以创建原slice的引用
s1 ：= arr1[1:2]	//	左开右闭，这里等价于原slice的部分引用
```

如果slice的引用超过了被引用对象的容量，即cap(s)，那么会导致程序宕机

但如果slice的引用超出了被引用对象的长度，即len(s)，那么最终slice会比原slice长

**由于slice包含的是数组元素的指针，所以将一个slice传递给函数的时候，可以去函数内部修改底层数组的元素**

```go
//	翻转切片数组
func reverse(s []int) {
    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

slice和数组的声明方式很像，但是slice是没有指定长度的

所以slice无法做比较，不能用==来测试两个slice是否拥有相同的元素

slice唯一允许的比较操作是和nil做比较，比如：

```go
if summer == nil {/*...*/}
//	值为nil的slice没有对应的底层数组，同时长度和容量都是零

//	以下slice的长度都是0
var s []int	//	s == nil
s = nil	//	s == nil
s = []int(nil)	//	s == nil
s = []int{}	//	s != nil
```

因此如果要判断一个slice是否为空，必须要用`len(s) == 0`，而不是`s == nil`

内置函数`make`可以创建一个具有指定元素类型、长度和容量的slice，其中容量参数可以省略

```go
arr1 := make([]int, 1)	//	长度len为1
arr2 := make([]int, 1， 3)	//	长度为1，容量为3
```



append函数

append用来将元素追加到slice的后面，并返回新的slice（好奇怪的用法）

```go
var ints []int
for i := 0; i < 10; i ++ {
    ints = append(ints, i)
}
```

如果slice的容量不够容纳增长的元素，``append`必须创建一个拥有足够容量的新的底层数组来存储新元素，然后将元素从slice x复制到这个新的数组中

同时将新元素y追加到数组后面

slice的扩容机制可以参考一下redis里面sds的扩容机制（前期按倍数扩容，后期按照固定大小扩容）

<br/>

因此，对于任何函数，只要有可能改变slice的长度或容量，抑或是使得slice指向不同的底层数组，都需要更新slice变量

<br/>

append也可以同时给slice添加多个元素
