汇编指令

- push指令，将数据存放到栈中
- rsp存放指向栈顶的指针



- mov指令 将src（源数据）存放到dst（目的地）
- 有两种格式
  - mov %rsp,%rbp（寄存器格式）
  - mov %rdi,-0x20(%rbp)（内存格式）
  - -0x20(%rbp)是指将rbp上的地址减去0x20，得到的才是它语义上指到的地址
  - 还有一种格式mov %0xabcdef99 %eax 将前面的值放到后面的寄存器中



- callq是进行函数调用



register（寄存器）



cpu和内存的数据存放，本质上就是状态机



%rip寄存器存放的就是PC（程序计数器 program count）



linux下默认是小端吗..

union原来使用在向寄存器这样类似的场景的啊



program counter 程序计数器，表示当前执行的指令的地址



cpu的工作方式（https://nju-projectn.github.io/ics-pa-gitbook/ics2020/2.1.html）

- 从内存中取指令（实际上所谓的pc存放的就是当前指令的位置，即指针）
- 读取翻译指令（读取到的指令都是0101的比特串，要让cpu知道比特串是什么，即cpu要知道操作指令和操作数是哪些；所以就有了查找表的概念，通过查表的方式找到操作指令和操作数）
- 执行指令（经过译码之后, CPU就知道当前指令具体要做什么了, 执行阶段就是真正完成指令的工作. 现在TRM只有加法器这一个执行部件, 必要的时候, 只需要往加法器输入两个源操作数, 就能得到执行的结果了. 之后还要把结果写回到目的操作数中, 可能是寄存器, 也可能是内存）
- 更新pc（执行完一条指令之后, CPU就要执行下一条指令. 在这之前, CPU需要更新PC的值, 让PC加上刚才执行完的指令的长度, 即可指向下一条指令的位置）



java或c#的动态数组存在扩容和收缩的情况
