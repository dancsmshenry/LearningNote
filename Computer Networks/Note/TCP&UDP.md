### TCP头部报文

- ![](TCP头部报文.png)
- 序列号：
  - 在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就 「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题
- 确认应答号：
  - 指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数 据都已经被正常接收。⽤来解决不丢包的问题
- ACK：
  - 该位为 1 时，「确认应答」的字段变为有效
  - TCP 规定除了最初建⽴连接时的 SYN 包之外该位必 须设置为 1
- RST：
  - 该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接
- SYN：
  - 该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定
- FIN：
  - 该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段
- 首部长度
  - 原因：因为报文中有选项的部分，长度会超过20字节



### TCP的概念

- 是面向连接，可靠的，基于字节流的传输层通信结构
  - 面向连接：一定是一对一连接
  - 可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端
  - 字节流：：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」



### TCP连接

- ⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝ ⼤⼩称为连接
- 需要三个信息才能达成共识
  - Socket：由 IP 地址和端⼝号组成 
  - 序列号：⽤来解决乱序问题等 
  - 窗⼝⼤⼩：⽤来做流ᰁ控制



### 确定唯一的TCP连接

- 四元组（源地址，源端口，目的地址，目的端口）



### TCP的最大连接数是多少

- 最大连接数 = 客户端IP数 * 客户端的端口数
- 即2的48次方
- 连接数的限制
  - ⾸先主要是⽂件描述符限制，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬
  - 另⼀个是内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的



### UDP头部报文

- ![](UDP头部报文.png)
- 为什么会有包长度
  - 因为为了网络设备硬件设计和处理方便，首部长度需要是4字节的长度（有点类似字节对齐的缘故）



### TCP和UDP的对比

- 连接
  - TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接
  - UDP 是不需要连接，即刻传输数据
- 服务对象
  - TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点
  - UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信
- 可靠性
  - TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不᯿复、按需到达
  - UDP 是尽最⼤努⼒交付，不保证可靠交付数据
- 拥塞控制、流量控制
  - TCP 有拥塞控制和流ᰁ控制机制，保证数据传输的安全性
  - UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率
- ⾸部开销
  - TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」 字段则会变⻓的。 
  - UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩
- 传输⽅式
  - TCP 是流式传输，没有边界，但保证顺序和可靠
  - UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序
- 分⽚不同 
  - TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在**传输层**进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚
  - UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 **IP 层**进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着 再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样 传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU



### TCP三次握手

- ![](TCP三次握手.png)
- 一开始客户端和服务端都是close状态，然后服务端监听某个端口，进入LISTEN状态



第一次握手

- ![](第一次握手.png)
- 客户端->服务端
- 客户端随机初始化序列号，并将SYN标志位置为1
- 不包含应用层数据
- 此后客户端处于SYN-SENT状态



第二次握手

- ![](第二次握手.png)
- 服务端->客户端
- 服务端随机初始化报文的序列号
- 将收到的来自客户端的序列号+1，作为自己的确认应答号
- 并把SYN和ACK都设为1
- 不包含应用层数据
- 此后服务端处于SYN-RCVD状态



第三次握手

- ![](第三次握手.png)
- 客户端->服务端
- 将ACK设为1
- 将收到的来自服务端的序列号+1，作为自己的确认应答号
- 可以携带应用层数据（！！）
- 发送后，客户端处于ESTABLISHED状态；同时，服务端收到报文后，也会处于ESTABLISHED状态



### TCP三次握手的原因

- 1、避免历史连接
  - 三次握⼿的⾸要原因是**为了防⽌旧的重复连接初始化造成混乱**
  - 试想一下场景：
    - 如果第一次报文超时，就会发送第二次报文，但是第一次报文却又先到达服务端，此时服务端发送第二次报文
    - 此时如果是两次握手的话，客户端收到报文后就直接确立连接了
    - 这就不是我们想要的（因为这是历史连接，是过期或超时了的）
    - 但，如果是三次握手才确立连接的话，那么客户端通过上下文发现这是历史或超时了的连接，就直接发送RST报文中止这次连接
  - 所以，最主要原因，就是防止历史连接初始化了连接



- 2、同步双方初始序列号
- PS：序列号的作用
  - 接收方可以去除重复的数据
  - 接收方可以根据数据包的序列号按序接受
  - 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的
- 所以，对于发送和接受的双方，都要确保自己发送的数据都能被对方接受
- 所以，当客户端发送携带「初始序列号」的 SYN 报⽂的时 候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收；
- 那当服务端发送「初始序 列号」给客户端的时候，依然也要得到客户端的应答回应
- 这样一来一回，就是四次握手，而其中的两次可以合并，所以就是三次握手了
- ![](四次握手-》三次握手.png)
- 所以，我可以提炼为，三次握手是为了确保双方的发送和接受能力都没有问题



- 3、避免资源的浪费
  - 试想一个场景：如果只有两次握手的话，那么会发生什么？第二次握手就要确定连接了
  - 但是，如果客户端发送的SYN请求在网络中阻塞，就会重新发送，而这些阻塞的请求后续服务端逐渐收到，服务端就会因此创建很多连接（但是这些连接都是冗余无效的），因此造成了资源不必要的浪费



小结

- 通过三次握⼿**能防⽌历史连接的建⽴**，**能减少双⽅不必要的资源开销**，**能帮助双⽅同步初始化序列号**



### 为什么客户端和服务端的初始序列号 ISN 是不相同的

- 如果⼀个已经失效的连接被重⽤了，但是该旧连接的历史报⽂还残留在⽹络中，如果序列号相同，那么就⽆法分辨出该报⽂是不是历史报⽂，如果历史报⽂被新的连接接收了，则会产⽣数据错乱



### 为啥IP层已经分片数据了，TCP还要分片数据

- ![](MTU和MSS.png)
- （MTU和MSS的关系）
- 如果TCP不分片数据的话，那么如果一个IP分片丢失，整个IP报文的所有分片都得重传（因为IP层没有超时重传等recovery的操作）
- 所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进⾏分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不⽤ IP 分片了



### SYN攻击

- background：

- 假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到 ⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态
- 但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的 ACK 应答
- 久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常⽤户服务
