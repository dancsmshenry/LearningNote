### TCP头部报文

- ![](TCP头部报文.png)
- 序列号：
  - 在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就 「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题
- 确认应答号：
  - 指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数 据都已经被正常接收。⽤来解决不丢包的问题
- ACK：
  - 该位为 1 时，「确认应答」的字段变为有效
  - TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1
- RST：
  - 该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接
- SYN：
  - 该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定
- FIN：
  - 该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段
- 首部长度
  - 原因：因为报文中有选项的部分，长度会超过20字节



### TCP的概念

- 是面向连接，可靠的，基于字节流的传输层通信结构
  - 面向连接：一定是一对一连接
  - 可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端
  - 字节流：：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」



### TCP连接

- ⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝ ⼤⼩称为连接
- 需要三个信息才能达成共识
  - Socket：由 IP 地址和端⼝号组成 
  - 序列号：⽤来解决乱序问题等 
  - 窗⼝⼤⼩：⽤来做流ᰁ控制



### 确定唯一的TCP连接

- 四元组（源地址，源端口，目的地址，目的端口）



### TCP的最大连接数是多少

- 最大连接数 = 客户端IP数 * 客户端的端口数
- 即2的48次方
- 连接数的限制
  - ⾸先主要是⽂件描述符限制，Socket 都是⽂件，所以⾸先要通过 ulimit 配置⽂件描述符的数⽬
  - 另⼀个是内存限制，每个 TCP 连接都要占⽤⼀定内存，操作系统的内存是有限的



### UDP头部报文

- ![](UDP头部报文.png)
- 为什么会有包长度
  - 因为为了网络设备硬件设计和处理方便，首部长度需要是4字节的长度（有点类似字节对齐的缘故）



### TCP和UDP的对比

- 连接
  - TCP 是⾯向连接的传输层协议，传输数据前先要建⽴连接
  - UDP 是不需要连接，即刻传输数据
- 服务对象
  - TCP 是⼀对⼀的两点服务，即⼀条连接只有两个端点
  - UDP ⽀持⼀对⼀、⼀对多、多对多的交互通信
- 可靠性
  - TCP 是可靠交付数据的，数据可以⽆差错、不丢失、不᯿复、按需到达
  - UDP 是尽最⼤努⼒交付，不保证可靠交付数据
- 拥塞控制、流量控制
  - TCP 有拥塞控制和流ᰁ控制机制，保证数据传输的安全性
  - UDP 则没有，即使⽹络⾮常拥堵了，也不会影响 UDP 的发送速率
- ⾸部开销
  - TCP ⾸部⻓度较⻓，会有⼀定的开销，⾸部在没有使⽤「选项」字段时是 20 个字节，如果使⽤了「选项」 字段则会变⻓的。 
  - UDP ⾸部只有 8 个字节，并且是固定不变的，开销较⼩
- 传输⽅式
  - TCP 是流式传输，没有边界，但保证顺序和可靠
  - UDP 是⼀个包⼀个包的发送，是有边界的，但可能会丢包和乱序
- 分⽚不同 
  - TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在**传输层**进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚
  - UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 **IP 层**进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着 再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样 传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU



### TCP三次握手

- ![](TCP三次握手.png)
- 一开始客户端和服务端都是close状态，然后服务端监听某个端口，进入LISTEN状态



第一次握手

- ![](第一次握手.png)
- 客户端->服务端
- 客户端随机初始化序列号，并将SYN标志位置为1
- 不包含应用层数据
- 此后客户端处于SYN-SENT状态



第二次握手

- ![](第二次握手.png)
- 服务端->客户端
- 服务端随机初始化报文的序列号
- 将收到的来自客户端的序列号+1，作为自己的确认应答号
- 并把SYN和ACK都设为1
- 不包含应用层数据
- 此后服务端处于SYN-RCVD状态



第三次握手

- ![](第三次握手.png)
- 客户端->服务端
- 将ACK设为1
- 将收到的来自服务端的序列号+1，作为自己的确认应答号
- 可以携带应用层数据（！！）
- 发送后，客户端处于ESTABLISHED状态；同时，服务端收到报文后，也会处于ESTABLISHED状态



### TCP三次握手的原因

- 1、避免历史连接
  - 三次握⼿的⾸要原因是**为了防⽌旧的重复连接初始化造成混乱**
  - 试想一下场景：
    - 如果第一次报文超时，就会发送第二次报文，但是第一次报文却又先到达服务端，此时服务端发送第二次报文
    - 此时如果是两次握手的话，客户端收到报文后就直接确立连接了
    - 这就不是我们想要的（因为这是历史连接，是过期或超时了的）
    - 但，如果是三次握手才确立连接的话，那么客户端通过上下文发现这是历史或超时了的连接，就直接发送RST报文中止这次连接
  - 所以，最主要原因，就是防止历史连接初始化了连接



- 2、同步双方初始序列号
- PS：序列号的作用
  - 接收方可以去除重复的数据
  - 接收方可以根据数据包的序列号按序接受
  - 可以标识发送出去的数据包中， 哪些是已经被对⽅收到的
- 所以，对于发送和接受的双方，都要确保自己发送的数据都能被对方接受
- 所以，当客户端发送携带「初始序列号」的 SYN 报⽂的时 候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收；
- 那当服务端发送「初始序 列号」给客户端的时候，依然也要得到客户端的应答回应
- 这样一来一回，就是四次握手，而其中的两次可以合并，所以就是三次握手了
- ![](四次握手-》三次握手.png)
- 所以，我可以提炼为，三次握手是为了确保双方的发送和接受能力都没有问题



- 3、避免资源的浪费
  - 试想一个场景：如果只有两次握手的话，那么会发生什么？第二次握手就要确定连接了
  - 但是，如果客户端发送的SYN请求在网络中阻塞，就会重新发送，而这些阻塞的请求后续服务端逐渐收到，服务端就会因此创建很多连接（但是这些连接都是冗余无效的），因此造成了资源不必要的浪费



小结

- 通过三次握⼿**能防止历史连接的建立**，**能减少双方不必要的资源开销**，**能帮助双方同步初始化序列号**



### 为什么客户端和服务端的初始序列号 ISN 是不相同的

- 如果⼀个已经失效的连接被重⽤了，但是该旧连接的历史报⽂还残留在⽹络中，如果序列号相同，那么就⽆法分辨出该报⽂是不是历史报⽂，如果历史报⽂被新的连接接收了，则会产⽣数据错乱



### 为啥IP层已经分片数据了，TCP还要分片数据

- ![](MTU和MSS.png)
- （MTU和MSS的关系）
- 如果TCP不分片数据的话，那么如果一个IP分片丢失，整个IP报文的所有分片都得重传（因为IP层没有超时重传等recovery的操作）
- 所以，为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进⾏分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不⽤ IP 分片了



### SYN攻击

- background：

- 假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到 ⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态
- 但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的 ACK 应答
- 久⽽久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常⽤户服务
- 避免的方法：
  - 1、通过修改 Linux 内核参数，控制队列⼤⼩和当队列满时应做什么处理
  - 2、（后续补上来）
- ![](SYN正常流程.png)



### TCP四次挥手

- ![](TCP四次挥手.png)



四次挥手

- 1、客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，之后客户端进⼊ FIN_WAIT_1 状态
  - 客户端打算不发送信息，关闭连接了，但是要先通知服务端，因为可能服务端后续需要发送一些信息，此时客户端是可以接受信息的
- 2、服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态；客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态
  - 服务端知道了客户端要关闭连接了，所以发送ack报文
- 3、等待服务端处理完数据后，服务端向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态
  - 服务端把信息都发送处理好了之后，就告诉客户端可以彻底关闭了
- 4、客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态；服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭；客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭
  - 客户端知晓后，就关闭，并通知服务端
- PS：
  - 每个方向都有一个ACK和FIN，所以是四次挥手
  - 主动关闭连接的才会有TIME_WAIT状态



### TCP四次挥手的原因

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据
- 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂（因为服务端可能还有数据需要处理和发送）
- 等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接



### TIME_WAIT等待时间是2MSL的原因

- MSL：报文最大生存时间，是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃
- TTL：在IP头中，是 IP 数据报可以经过的最⼤路由数，每经过⼀个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报⽂通知源主机（单位：经过路由跳数）
- MSL要大于等于TTL消耗为0的时间
- 原因：
  - ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包 被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间
  - 可能被动关闭方没有收到断开连接的ack报文，就会触发超时重传报文，被动关闭方重新发送FIN以后，主动关闭方收到，一来一回正好是2个MSL
- 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的



### 为什么需要TIME_WAIT状态

- 1、防止旧连接的数据包
  - ![](为什么需要TIME_WAIT状态(1).png)
  - 如果没有TIME_WAIT或TIME_WAIT太短了的话，例如：之前发送的报文出现了网络延迟，直到下一次三次握手以后才接收到，就会产生数据错乱的问题（如上图）
  - 所以才有TIME_WAIT状态，⾜以让两个⽅向上的数据包都被丢弃，使得原来 连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的
- 2、保证连接正确关闭
  - ![](为什么需要TIME_WAIT状态(2).png)
  - 如果没有TIME_WAIT或TIME_WAIT太短了的话，例如：最后一次ACK报文延迟或丢失了，那么服务端就会一直储在LAST_ACK的状态，那么后续再来一次三次握手的话。服务端就会中断连接的

- 足够长的话就刚好
  - 服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接
  - 服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会发 FIN 关闭连接报文并等待新的 ACK 报文



### TIME_WAIT过多的危害

- 第一是内存资源占用
- 第二是对端口资源的占用，一个TCP连接至少消耗一个本地端口（占满了所有端⼝资源，则会导致⽆法创建新连接）



### 重传机制

#### 超时重传

- 定义：在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅的 ACK 确认应答报⽂，就会重发该数据
- 两种情况：数据包丢失，确认应答丢失
- ![](超时重传.png)
- RTT：表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延
- RTO：超时重传时间
  - RTO太大：网络的空隙时间增大，降低了网络传输效率
  - RTO太小：不必要的重传，会导致网络负荷增大
- Linux下计算RTO
  - 1
- 存在的问题：周期太长（用快速重传来解决）



#### 快速重传

- 工作方式：当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文段
- ![](快速重传.png)
- 存在的问题：重传的是时候，是重传之前的一个，还是重传所有的问题（解决办法SACK）



#### SACK方法

- 选择性确认：需要在TCP头部字段里面加上一个SACK的东西，可以将缓存的地图发送给发送方，这样发送方就可以只重传丢失的数据
- ![](SACK.png)



#### Duplicate SACK

- 使用SACK方法来告诉发送发有哪些数据被重复接收了
- situation1
  - ![](ACK丢包.png)
- situation2
  - ![](网络延时.png)



### 滑动窗口



### 拥塞控制

- 背景：在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是 ⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤
- 目的：避免发送方的数据填满整个网络
- 发生了超时重传，就认为发生了拥塞

- 拥塞窗口
  - 拥塞窗⼝cwnd是发送⽅维护的⼀个的状态变化，它会根据⽹络的拥塞程度动态变化的
  - 此时发送窗口的大小为是swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最小值



#### 慢启动

- ⼀点⼀点的提⾼发送数据包的数量
- 当发送⽅每收到⼀个 ACK，拥塞窗口的大小是指数级增长
- ![](慢启动.png)
- 慢启动门限（ssthresh）：
  - 当 cwnd < ssthresh 时，使⽤慢启动算法
  - 当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」



#### 拥塞避免

- ![](拥塞避免.png)
- 窗口的增长为线性增长
- 触发重传机制后变为拥塞发生算法



#### 拥塞发生

- 发生超时重传的拥塞发生算法
  - ![](拥塞发生(超时重传).png)
  - 将ssthresh设为cwnd/2
  - cwnd重置为1
  - 进入慢启动
- 发生快速重传的拥塞发生算法
  - cwnd=cwnd/2，变为原来的一半
  - ssthresh = cwnd
  - 进入快速恢复算法



#### 快速恢复

- 拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）、
- 重传丢失的数据包
- 如果再收到重复的 ACK，那么 cwnd 增加 1
- 如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进 ⼊拥塞避免状态
- ![](快速恢复.png)

