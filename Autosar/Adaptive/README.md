# Adaptive AUTOSAR方法论
- 尽量做到兼容AP和CP
- 基于面向服务架构（SOA）
- 更详细的manifest定义（这就是ARXML）

<br/>

面向服务的架构（SOA）
- 组织和利用分布式功能的软件架构的**设计方法**
- 将原本的应用程序拆分为了多个不同的功能组件（服务和服务之间会通过中立的接口进行通信；服务之间可以使用some/ip、dds、或者自己组装的tcpudp，进行通信，这里只要两个通信的服务使用的是相同的通信协议即可）
- 接口与协议和语言无关（参考微服务架构的rpc通信）
- 服务之间是松耦合的（需要被发现以后才能够使用）

<br/>

Adaptive运行时环境（ARA）
- 基于SOA的设计方法开发的软件架构
- 使用cpp11/14作为开发语言（可能21以后就会全面使用14进行开发）
- 是基于posix标准的os接口进行开发（比如linux、qnx都是可行的）
- 为应用程序提供一组标准的API
- 相比CP，AP的实现是多个进程（守护进程）和共享库，然后由守护进程对信息进行转发
- ara中多个进程是通过IPC进行通信

<br/>

- QNX是遵循POSIX规范的**类UNIX实时**操作系统，主要面向嵌入式系统，可能是最成功的微内核操作系统之一
- 在汽车领域，qnx是目前最大的操作系统供应商
- 是分布式、嵌入式、可规模拓展的硬实时操作系统
- 仅提供四种服务：进程调度、进程间通信、底层网络通信和中断处理
- 所有程序都使用同一个地址空间，不加保护；应用程序可以自由访问所有空间，效率极高
- 大内核空间结构：kernel等核心模块的地址空间与应用程序隔离

<br/>

开放架构：
- 没有ARXML描述，应用基本上是软件实现（也有部分硬件）

<br/>

开放抽象平台：
- 定义抽象软件组件（将上层的软件抽象为不同的组件部分）
- 还需要定义不同组件的抽象接口是什么

<br/>

开发软件架构：
- 区分非autosar组件（这里是允许存在非autosar组件的部分，不过需要将其标识出来）

<br/>

开发车辆硬件架构：
- 定义ECU硬件拓扑，不同的ECU之间是如何进行通信的

# Adaptive autosar 方法论

todo：需要学习一些关于当前汽车架构发展的知识，比如说什么是 E/E 架构之类的

OEM 会对其需求做出设计，然后输出 SWC design，Service design 以及 Machine design

OEM 的输出，必然是从整体的思路，对 ECU 之间模块的设计，而如果整体的架构采用的是 SOA 的架构

那么每个 ECU 对外提供的服务，都应该是由多个内部服务组成的，而这些内部服务，就需要 tier1 对其进行进一步的细化

三类角色：系统设计者，针对系统设计写出对应的代码者，将代码部署在系统上

为什么 ap 这里会有设计和部署分开的情况

Cp 是将功能给编码，然后烧写到板子上

而 ap 则不需要烧到板子上，只需要将配置修改，生成新的代码，重新编译，就可以接着运行了

（或者说有些配置是写在配置文件上的，只需要修改配置文件，而不需要修改代码，即重新编译读取配置文件即可）

1、应用程序设计（完成设计后，即可得到代码） 2、 3、应用程序部署（ip地址是多少，端口是多少，是选择dds还是someip；会生成 manifest 文件，将 arxml 生成 toml 文件 可读，autosar 没有强制规定是什么格式）

设计 aaswc，设计服务接口，设计与组件交互接口，设计 executable， 设计 process，设计 machine（machine 是一个虚拟的概念，例如说是异构的硬件，或者多核的芯片，或者说一个核的芯片上虚拟化出多个操作系统）

AASWC（组成软件功能的最小单位） CSWC

同一个可执行的二进制文件，可以被多个进程设计，即通过不同的启动参数，从而生成不同的进程





对于 aa 的理解，设计与部署。

设计阶段的主要目的，主要是为了生成代码。

比如说 is 是什么，那么此时生成代码的部分就会有一个头文件，用宏定义了当前 AA 的 is 名字叫什么

当然，从方法论的角度上来说，好像大部分的配置都是要在设计阶段完成。但是，这些值在 AA 的部署阶段，其实都是可以修改的

而部署阶段，则是用户具体使用的配置。例如说更新策略，用户可以在部署时随意的修改 key value pair 的更新策略。比如说在设计阶段是 keep_existing，后续可以换成 over_write 的

相比之下，per 的设计与部署相对就更为灵活，因为它所需要的生成代码更少，无非就是数据的序列化以及几个模板的萃取

而对于 com 中的 dds 的配置：

在设计阶段，就需要指定对应的 method、使用到的内置数据类型和用户自定义的数据类型，以及 com 到 dds 的网络绑定的代码。这些东西都是后续无法修改的（我个人理解就是，这些内容最终都落地到生成代码里面了，所以如果想要修改只能在工具界面，通过修改配置进行修改）

而在部署阶段，用户通信使用的 topic，使用到的通信协议，具体软件的版本号，instancd_specifier，以及 qos，这些从组件原理的代码层面，都是要从配置文件中读取到的。

也就是说，只要是从配置文件中读取的，在设计阶段修改，后续在部署阶段也可以修改。而生成代码的部分，后续在用户的角度，是无法修改的