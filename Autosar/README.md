# AUTOSAR

**AUT**omotive **O**pen **S**ystem **AR**chitecture

ECU：电控单元，汽车专用单片机

Electronic Control Unit

由微处理器（CPU）、存储器（ROM、、RAM）、输入/输出接口（I/O）、模数转换器（A/D）以及整形、驱动等大规模集成电路组成

它的功用：根据 自身存储的程序 对 发动机各传感器输入的各种信息进行运算、处理、判断

然后输出指令，控制有关执行器动作，达到快速、准确、自动控制发动机工作的目的

SOC

https://github.com/GreyZhang/hack_autosar



不管是someip还是dds，这个跟需求有关。最终的是底层协议栈才是关键，不要丢包，数据确定性等等才是重点。

# Adaptive AUTOSAR方法论

- 尽量做到兼容AP和CP
- 基于面向服务架构（SOA）
- 更详细的manifest定义（这就是ARXML）

<br/>

面向服务的架构（SOA）

- 组织和利用分布式功能的软件架构的**设计方法**
- 将原本的应用程序拆分为了多个不同的功能组件（服务和服务之间会通过中立的接口进行通信；服务之间可以使用some/ip、dds、或者自己组装的tcpudp，进行通信，这里只要两个通信的服务使用的是相同的通信协议即可）
- 接口与协议和语言无关（参考微服务架构的rpc通信）
- 服务之间是松耦合的（需要被发现以后才能够使用）

<br/>

Adaptive运行时环境（ARA）

- 基于SOA的设计方法开发的软件架构
- 使用cpp11/14作为开发语言（可能21以后就会全面使用14进行开发）
- 是基于posix标准的os接口进行开发（比如linux、qnx都是可行的）
- 为应用程序提供一组标准的API
- 相比CP，AP的实现是多个进程（守护进程）和共享库，然后由守护进程对信息进行转发
- ara中多个进程是通过IPC进行通信

<br/>

- QNX是遵循POSIX规范的**类UNIX实时**操作系统，主要面向嵌入式系统，可能是最成功的微内核操作系统之一
- 在汽车领域，qnx是目前最大的操作系统供应商
- 是分布式、嵌入式、可规模拓展的硬实时操作系统
- 仅提供四种服务：进程调度、进程间通信、底层网络通信和中断处理
- 所有程序都使用同一个地址空间，不加保护；应用程序可以自由访问所有空间，效率极高
- 大内核空间结构：kernel等核心模块的地址空间与应用程序隔离

<br/>

开放架构：

- 没有ARXML描述，应用基本上是软件实现（也有部分硬件）

<br/>

开放抽象平台：

- 定义抽象软件组件（将上层的软件抽象为不同的组件部分）
- 还需要定义不同组件的抽象接口是什么

<br/>

开发软件架构：

- 区分非autosar组件（这里是允许存在非autosar组件的部分，不过需要将其标识出来）

<br/>

开发车辆硬件架构：

- 定义ECU硬件拓扑，不同的ECU之间是如何进行通信的

# Adaptive autosar 方法论

todo：需要学习一些关于当前汽车架构发展的知识，比如说什么是 E/E 架构之类的

OEM 会对其需求做出设计，然后输出 SWC design，Service design 以及 Machine design

OEM 的输出，必然是从整体的思路，对 ECU 之间模块的设计，而如果整体的架构采用的是 SOA 的架构

那么每个 ECU 对外提供的服务，都应该是由多个内部服务组成的，而这些内部服务，就需要 tier1 对其进行进一步的细化

三类角色：系统设计者，针对系统设计写出对应的代码者，将代码部署在系统上

为什么 ap 这里会有设计和部署分开的情况

Cp 是将功能给编码，然后烧写到板子上

而 ap 则不需要烧到板子上，只需要将配置修改，生成新的代码，重新编译，就可以接着运行了

（或者说有些配置是写在配置文件上的，只需要修改配置文件，而不需要修改代码，即重新编译读取配置文件即可）

1、应用程序设计（完成设计后，即可得到代码） 2、 3、应用程序部署（ip地址是多少，端口是多少，是选择dds还是someip；会生成 manifest 文件，将 arxml 生成 toml 文件 可读，autosar 没有强制规定是什么格式）

设计 aaswc，设计服务接口，设计与组件交互接口，设计 executable， 设计 process，设计 machine（machine 是一个虚拟的概念，例如说是异构的硬件，或者多核的芯片，或者说一个核的芯片上虚拟化出多个操作系统）

AASWC（组成软件功能的最小单位） CSWC

同一个可执行的二进制文件，可以被多个进程设计，即通过不同的启动参数，从而生成不同的进程





对于 aa 的理解，设计与部署。

设计阶段的主要目的，主要是为了生成代码。

比如说 is 是什么，那么此时生成代码的部分就会有一个头文件，用宏定义了当前 AA 的 is 名字叫什么

当然，从方法论的角度上来说，好像大部分的配置都是要在设计阶段完成。但是，这些值在 AA 的部署阶段，其实都是可以修改的

而部署阶段，则是用户具体使用的配置。例如说更新策略，用户可以在部署时随意的修改 key value pair 的更新策略。比如说在设计阶段是 keep_existing，后续可以换成 over_write 的

相比之下，per 的设计与部署相对就更为灵活，因为它所需要的生成代码更少，无非就是数据的序列化以及几个模板的萃取

而对于 com 中的 dds 的配置：

在设计阶段，就需要指定对应的 method、使用到的内置数据类型和用户自定义的数据类型，以及 com 到 dds 的网络绑定的代码。这些东西都是后续无法修改的（我个人理解就是，这些内容最终都落地到生成代码里面了，所以如果想要修改只能在工具界面，通过修改配置进行修改）

而在部署阶段，用户通信使用的 topic，使用到的通信协议，具体软件的版本号，instancd_specifier，以及 qos，这些从组件原理的代码层面，都是要从配置文件中读取到的。

也就是说，只要是从配置文件中读取的，在设计阶段修改，后续在部署阶段也可以修改。而生成代码的部分，后续在用户的角度，是无法修改的

# 服务接口的组成

Method（是由服务器提供的功能**接口**；客户端通过RPC或IPC的方式使用这些方法），主要分为以下两类

- request response
- fire and forget

Event（是某类时间发生时由服务器产生并发送的**数据**）

- 客户端需要订阅才能收到event的数据
- 服务器可一次向多个客户端发送event
- 是没有初始值的

Field（表示实体当前处于某种状态）

- 客户端可向服务器订阅field改变的通知
- 服务器可一次向多个客户端发送event
- field有初始值且在服务有效期间**一直存在**
- field有getter和setter方法

<br/>

<br/>

<br/>

com组件主要是用于实现应用程序之间面向服务的通信

- 我的理解就是用于解决ara上层中，不同app的通信（无论是同一个process还是不同process的）



- com 组件负责建立和管理上层应用之间的通信，包括远程应用和本地应用
- 它作为基础设施，能够建立在不同机器上的，AutoSar ap 应用的通信
- com 的文档，包含的是各个 API 用途规范，其提供的功能，以及 API 与其中各个模型之间的关系
- com 组件分为以下几个部分：
  - 语言绑定 language binding
  - 端到端信息传递的安全保护机制 end-to-end communication protection
  - 网络绑定 communication/network binding
  - 交流管理软件 communication management software



# Network binding

## DDS

### 服务发现模块

- 需要给服务实例分配一个DomainParticipant

- 需要为每一个event中的服务接口中的VariableDataPrototype分配一个DDS topic和DDS DataWriter

- 需要分配一个DDS request topic（请求主题）和DDS reply topic（回复主题），并为之创建相应的DDS datawriter和DDS datareader（我理解，主要是为了实现com组件中event及rpc的概念）

<br/>

- domainparticipant的域id来自manifest，其中


- Publisher和Subscriber对象可以跨服务实例提供的事件和其他资源重用；因此，在封闭的域名参与者（domainparticipant）被销毁之前，不得将其移除。
- subscribe


笔记

- 前端和后端，各有自己的骨架和代理
- 无论是someip还是dds，前端都是一样的（配置文件），解析了这个配置文件后，后面的后端代码是不一样的。
- 前端定义基本的数据类型



理解SOA之前必须要了解RPC的调用过程

- 因为是调用远端的函数，和调用本地函数不同的地方就是，我们其实是不知道这个函数名字是什么（比如说我想要调用cpp client的函数sum，但是我们都知道cpp编译运行时会给函数名加上一些前缀，更有甚者还包括很多同名函数的重载），因此需要在本地存储对端函数的映射id，以便调用（至于这里如何存储，就会涉及到服务的发现注册，看了下互联网的主要实现是有一个中心化的注册中心，客户端定期向这个注册中心获取服务端的信息；而汽车电子这一块主要是利用底层的SPDP和SEDP来实现服务的发现，唉，也就是广播自己，然后每个人都在本地存储新节点的信息，需要用到它的时候再调用）
- 要传入的参数是什么，比如说我们可能向函数传入自定义的结构体，但还是那个问题，不同语言如何对该数据进行读取，就我怎么知道你传过来的数据是啥，也就是说需要对数据的格式进行限定和说明（有点接近protobuf了，但是protobuf更加优秀，它深知网络传输中数据传输的消耗，因此使用特定算法对数据进行序列化，降低传输时的损耗）
- 最后就是网络模型的探讨了，即网络库的实现，以及IO的优化


SOA

- 如何确定服务B是否运行（如何在网络中发现对应的服务）
- 如何确定服务B正确的运行
- 如何发现服务B的位置（是在同一个主机上（IPC），还是不同主机上（DDS，SOME/IP）；比如说我们如何知道服务B的ip、端口以及所用的传输协议）

<br/>

- 这里对rpc的返回内容，需要包含是对哪个进程的返回，是对进程中哪个函数服务的返回，再加上具体的返回值

<br/>

- 如果每一个函数我们都作为一个服务，那么整个系统中服务之间的依赖关系就会变得复杂，不好维护
- 因此才会有我们之前说的，多个event、method都挂靠在同一个服务下

<br/>

# COM 组件

服务之间是松耦合的，需要被发现才能够使用；服务是可重用的

接口和协议的实现与语言无关

服务接口的组成：method event field

服务接口的组成：majorversion minorversion，主版本更新表示不兼容的升级；此版本更新表示向后兼容的升级

对于 event，客户端需要订阅才能够收到 event；服务器可以一次向多个 client 发送 event

Event 没有初始值，而 field 有初始值

采用面向服务的通信架构，可以在进程内，同一个 machine 的进程间以及不同 machine 的进程间

使用了 proxy/skeleton 模式

## Com 的组成

E2E 通信保护（在传输的数据前加上E2E的头保护，保证数据的可靠传输）

Com api 的 c++11 的绑定

## 其他

当服务暂时失效时，客户端不需要释放 proxy 实例

等到实例恢复后，proxy自动恢复连接

## 网络绑定

some/ip 服务发现，payload 数据的序列化

Ipc 通信协议，进程间通信

Dds 发布订阅体系，以数据为中心

S2S 信号和服务之间相互转换，实现 ap 和 cp 之间的通信

Com 组件支持多重网络的动态部署

## 动态部署

InstanceIdentifier：对于某个服务，针对某个具体的网络绑定层做出实例化部署

InstanceSpecifier：对于某个服务，在多个网络绑定层做出部署，或者是一个服务在同一个网络绑定下同时部署多个实例

## Comdeamon

Com 的一个平台级应用程序，支持 some/ip 以及 ipc 的绑定，处理 some/ip-sd 的消息传输，路由 some/ip 消息给感兴趣的应用程序

- autosar adaptive -> ara::com -> dds
- autosar adaptive和autosar classic的区别，是什么原因导致了adaptive的诞生，二者的应用分别在哪些方面，至少需要了解二者的架构上的组成
- ara，了解ara的**主要**组件有啥，这些组件的作用是什么，然后需要着重了解ara::com的架构，务必要理解proxy/skeleton模式（这模式不懂，后续很难深入下去理解com如何进行网络绑定）
- 因为后续需要做的是网络绑定，因此对于网络绑定的几种方法（IPC，SOME/IP，DDS）都要有一定程度的了解，并且深入理解DDS
- 对于DDS，我认为需要划分为两个部分，一个是上层的DDS架构，即DCPS；另一个是下层的传输协议RTPS，并且涉及服务发现的部分
  - 比如说DCPS，这里要明白DCPS划分的五个部分、理解QoS的不同策略
  - 再者就是RTPS，要了解报文的组成，服务发现的协议以及在RTPS层中角色与DCPS中对象的映射

<br/>

- 其实，can总线的广播机制，本质上也是一种发布订阅模型，只不过它做的比较简陋，信息的每次发布都是通过广播的机制传达到所有的总线上
- 有一点，对于com的架构不太了解，到底什么是proxy/skeleton模式、导致后续dds和com模块进行映射的时候，一直搞不明白





# cp

# Classic AUTOSAR方法论

- 指导汽车领域ECU软件开发的流程


- 通过虚拟功能总线（VFB）提供SWC之间通信的抽象描述
- 提供标准的数据交换格式：ARXML

<br/>

- SWC：功能性软件组件，一般包含某些特定的实时运行的调节算法和可运行实体
- 一个上层的应用，可以拆分为不同的SWC

<br/>

- ECU：电子控制单元，汽车专用微机控制器，也叫汽车专用单片机
  - 由微处理器（CPU）、存储器（ROM、、RAM）、输入/输出接口（I/O）、模数转换器（A/D）以及整形、驱动等大规模集成电路组成
- 为了实现ECU软件的可移植和可重用，严格区分了应用程序与基础软件；同时也提供了标准化的接口（RTE）

<br/>

- CP的软件架构有以下特点：
  - 高实时性（相比linux的抢占式系统，具有一定的实时性）

  - 基于信号通信（CAN总线；不过随着some/ip的引入，也具备了面向服务的通信的能力）
  - 任务共享地址空间（我理解就是代码都跑在一个同一个OS里面，所有大家都共用一个地址空间）
  - 静态配置&部署（生成的都是.c和.h文件）



# CAN简介

CAN (controller area network)，是指控制器局域网络，是一种能实现分布式**实时控制**的**串行**通信网络

不同于电脑的单处理器，整车内的所有ECU都包含自己的独立处理器，不同的 ECU 之间可以通过 CAN 总线进行通信



<br/>



# CAN的特点

CAN总线没有固定地址，每个节点以统一形式的ID作为标识

节点消息在未被接受时不会被淹没，而是按照优先级等待处理，数据在发送失败时会自动重发

速度相对比较慢： 低速CAN大概是125kb/s，高速CAN是50kb/s

性能稳定

CAN总线将汽车内部各电控单元之间连接成一个局域网络，实现信息共享

多主机：安全敏感的应用对通信系统的可靠性要求极高，将总线能够正常工作归结到单一节点是非常危险的，因此需要对总线的接入进行去中心化，每个节点都要有接入总线的能力

每个节点都能往总线上发送消息，通信是时间驱动的，只有当新的消息传说时，CAN总线才会忙碌(因此非常适合实时应用)寻址机制：CAN总线不设置节点的地址，而是给每个节点一个消息的标识符来区别消息

优点：当前节点不需要了解其他节点的状况，只需要关注总线上的消息（有新的需要的数据就速，没有就不管）



<br/>



# CAN的组成

**ECU节点**，CAN总线和CAN网关ECU： 电子控制单元，一个普通的家用轿车往往有28+的ECU，这些ECU共同组成了汽车电子控制系统

- 通过监控各种输入数据和汽车的运行状态，并按照预先设定好的程序处理传感器数据，最终再把各个参数下发给相关的执行单元
- 是汽车的控制核心，相当于汽车的电脑，需要包含处理器、存储器、I0接口及大规模集成电路

<br/>

**CAN总线**，采用差分信号进行传输，其物理层传输介质由两条双绞线组成，一条是CAN HIGH，一条是CAN LOW，分别代表高电平和低电平

- 当没有数据收发的时候，两条线的电平都为2.5V，称为隐性电平
- 当两条线的电压差小于0.5V时，为隐性，代表逻辑1
- 当两条线的电压差大于0.5V时，为显性，代表逻辑0
- 当受到电磁干扰的时候，会同时影响两条线的电压，但是对他们二者的差值影响不大，所以CAN总线的抗干扰能力很强
- CAN总线分为几个不同的部分： 动力总成总线，底盘控制总线，车身控制总线，娱乐系统总线和诊断控制总线

<br/>

**CAN网关**，是CAN网络的核心，负责控制整车上所有总线上各类信号的处理和转发

- CAN网关接收任何CAN总线发送过来的不同传输速率的网络信号，将这些信号按照一定标准处理后广播道整车网络中

- 比如说某个ECU订阅了某个信号，则该ECU负责解析信号并执行对应的控制处理程序(PS： 感觉CAN也是发布订阅模型，但是它不是以 以太网 为基础的......
  cbr/>



<br/>

# CAN总线的通信原理

多路载波侦听：网络上所有节点都接入在同一根总线上，且数据的发送是广播式的，网络上各人节点在发送数据的时候都需要提前检测总线上是否有数据传输，如果有数据传输，就暂时不发送数据;如果没有，就立即发送

冲突检测：节点在发送数据区的时候，需要不停的检测发送的数据，确定是否与其他节点数据发送冲突，高的报文先发送

非破坏性仲裁机制，通过数据ID仲裁，ID数值越小，报文优先级越高

发送低优先级报文的节点退出仲裁后，在下次总线空闲时自动重发报文，如果有冲突，则保证优先级

高优先级的报文不能终端低优先级报文的发送
<br/>
CAN控制器具有根据ID过滤报文的功能，即只接受某些ID的报文，节点会对接受到的报文进行过滤



can总线的数据传输

- can总线的数据传输原理
  - 一个用户（控制单元）向网络中“说出”数据，而其他用户“收听”到这些数据。
  - 一些控制单元认为这些数据对它有用，它就接收并且应用这些数据，而其他控制单元也许不会理会这些数据
- 也就是说数据总线中，数据的传输是没有指定的接受者，每个单元都需要接受所有的数据
- 网上说的数据传输的五个步骤：
  - 提供数据控制单元向CAN控制器提供数据用于传输
  - 发出数据CAN收发器从CAN控制器处接收数据，将其转化为电信号发出。这些数据以数据列的形式进行传输，数据列是由一长串二进制（高电平与低电平）数字组成的
  - 接收数据所有与CAN数据总线一起构成网络的控制单元成为接收器
  - 检查数据控制单元对接收到的数据进行检查，看是否是其功能所需
  - 认可数据如果所接收的数据是重要的，它将被认可及处理，反之将被忽略
- 所以，SOA服务通信最大的特点就是以太网
  - 因为每个用户在以太网中都有自己的身份（服务地址+端口），那么数据只需要传达给指定的人，而不用每个用户都将数据接受处理