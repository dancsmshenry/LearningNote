理解SOA之前必须要了解RPC的调用过程
- 因为是调用远端的函数，和调用本地函数不同的地方就是，我们其实是不知道这个函数名字是什么（比如说我想要调用cpp client的函数sum，但是我们都知道cpp编译运行时会给函数名加上一些前缀，更有甚者还包括很多同名函数的重载），因此需要在本地存储对端函数的映射id，以便调用（至于这里如何存储，就会涉及到服务的发现注册，看了下互联网的主要实现是有一个中心化的注册中心，客户端定期向这个注册中心获取服务端的信息；而汽车电子这一块主要是利用底层的SPDP和SEDP来实现服务的发现，唉，也就是广播自己，然后每个人都在本地存储新节点的信息，需要用到它的时候再调用）
- 要传入的参数是什么，比如说我们可能向函数传入自定义的结构体，但还是那个问题，不同语言如何对该数据进行读取，就我怎么知道你传过来的数据是啥，也就是说需要对数据的格式进行限定和说明（有点接近protobuf了，但是protobuf更加优秀，它深知网络传输中数据传输的消耗，因此使用特定算法对数据进行序列化，降低传输时的损耗）
- 最后就是网络模型的探讨了，即网络库的实现，以及IO的优化


SOA
- 如何确定服务B是否运行（如何在网络中发现对应的服务）
- 如何确定服务B正确的运行
- 如何发现服务B的位置（是在同一个主机上（IPC），还是不同主机上（DDS，SOME/IP）；比如说我们如何知道服务B的ip、端口以及所用的传输协议）

<br/>

- 这里对rpc的返回内容，需要包含是对哪个进程的返回，是对进程中哪个函数服务的返回，再加上具体的返回值

<br/>

- 如果每一个函数我们都作为一个服务，那么整个系统中服务之间的依赖关系就会变得复杂，不好维护
- 因此才会有我们之前说的，多个event、method都挂靠在同一个服务下

<br/>

can总线的数据传输
- can总线的数据传输原理
  - 一个用户（控制单元）向网络中“说出”数据，而其他用户“收听”到这些数据。
  - 一些控制单元认为这些数据对它有用，它就接收并且应用这些数据，而其他控制单元也许不会理会这些数据
- 也就是说数据总线中，数据的传输是没有指定的接受者，每个单元都需要接受所有的数据
- 网上说的数据传输的五个步骤：
  - 提供数据控制单元向CAN控制器提供数据用于传输
  - 发出数据CAN收发器从CAN控制器处接收数据，将其转化为电信号发出。这些数据以数据列的形式进行传输，数据列是由一长串二进制（高电平与低电平）数字组成的
  - 接收数据所有与CAN数据总线一起构成网络的控制单元成为接收器
  - 检查数据控制单元对接收到的数据进行检查，看是否是其功能所需
  - 认可数据如果所接收的数据是重要的，它将被认可及处理，反之将被忽略
- 所以，SOA服务通信最大的特点就是以太网
  - 因为每个用户在以太网中都有自己的身份（服务地址+端口），那么数据只需要传达给指定的人，而不用每个用户都将数据接受处理