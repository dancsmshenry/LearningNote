## 第2章 变量和基本类型

### 2.1基本内置类型

- 基本算术类型

  | 类型      | 含义                   |
  | --------- | ---------------------- |
  | bool      | 布尔类型               |
  | char      | 字符                   |
  | short     | 短整型                 |
  | int       | 整型                   |
  | long      | 长整型（最小尺寸32位） |
  | long long | 长整型（最小尺寸64位） |
  | float     | 单精度浮点数           |
  | double    | 双精度浮点数           |

- 带符号类型和无符号类型
  - 类型`int、short、long和long long`都是带符号的，通过在这些类型名前添加unsigned就可以得到无符号类型
  - 而字符型则被分为`char、signed char和unsigned char`
  - 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数
- 类型转换
  - 浮点数和整数：
    - 浮点数->整数，结果仅保留浮点数中小数点之前的部分
    - 整数->浮点数，小数部分记为0
  - 布尔类型：
    - 非布尔类型->布尔类型
- 字面值常量
  - 字符和字符串字面值
    - 用单引号括起来的一个字符为char型字面值，双引号括起来的零个或多个字符为字符串字面值
  - 转义序列
    - 在c++语言中有特殊含义的字符是不能直接使用的，在这些情况下需要用到转义序列
    - 转义序列均以反斜杠开始，如`\n`表示换行，`\"`表示双引号，`\'`表示单引号
  - 指定字面值类型
    - 通过前缀或后缀可以改变整型、浮点型和字符型字面值的默认类型
    - 如对于整型，前缀`ll`可以表示`long long`，前缀`l`可以表示`long`



### 2.2变量

- 命名规范
  - 需要由字母、数字和下划线组成，同时对大小写敏感
  - 变量名一般用小写字母，类名一般用大写字母开头
- 变量声明和定义的关系
  - **声明**使得名字为程序所知，**定义**负责创建于名字关联的实体
  - 变量能且只能被定义一次，但是可以被多次声明

```c++
extern int i;//是声明i而不是定义i
int j;//声明并定义了j
```

- 初始值
  - 当对象在创建时候获得了一个特定的值，这个对象就被初始化了
  - 初始化不是赋值，赋值是指把对象的当前值擦除，而以一个新值代替
- 初始化的几种方式

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```



### 2.3复合类型

- 引用
  - 引用即为对象起了另外一个名字
  - 引用通常是将声明写成`&d`的形式来定义引用类型，其中d是声明的变量名
  - 因为引用本身不是一个对象，所以不能定义引用的引用
  - 引用类型的初始值必须是一个对象，且类型要与原对象相同

```c++
int a = 1024;
int &a1 = a;//a1是a的一个引用
cout << a1 << endl;//1024
a ++ ;
cout << a1 << endl;//1025，可以看出引用的本质
```

- 指针
  - 指针本身是一个对象，允许对指针赋值或拷贝，所以可以指向不同的对象（但是指针类型要与指向的对象的类型相同）
  - 指针的含义是存放着某个对象的地址
  - 指针无须再定义时赋值
  - 通常是将声明符写成`*d`的形式，其中d是变量名，如果一条语句中定义了几个指针变量，每个变量前面都要有`*`

```c++
int a = 2047;
int *a1;//定义一个指向int型对象的指针

a1 = &a;//a1存放a的地址，也可以说a1是指向a的指针
//&是取地址符，用于获取对象的具体地址
//注意：&在定义的类型的后买你是声明的一部分，而在表达式中是取地址符

cout << *a1 << endl;//2047
//*是解引用符号，用于获取指针所指向的对象的值
//注意：*在定义中的类型的后面是声明的一部分，而在表达式中的是解引用符

*a1 = 0;//通过对*a1进行赋值，从而改变a的值


int *p1 = 0;
int *p2 = nullptr;
//上面两条语句都表示空指针（需要首先#include <cstdlib>）

int *pi;
int zero = 0;
p1 = zero;//虽然zero=0，但还是不可以把int变量直接赋给指针


void *pv = &obj;//这里定义的是一个特殊的指针类型，obj可以指向任意类型的对象，即pv可以存放任意类型指针


int ival = 1024;
int *pi = &ival;
int **ppi = &pi;//可以定义指向指针的指针

int i = 42;
int *p;
int * &r = p;//r是一个对指针p的引用
```



### 2.4`const`限定符

- `const`是指把一个变量变为常量

- 与define的区别
  - `const`常量有数据类型，而define定义宏常量没有数据类型
  - define宏是在预处理阶段展开，`const`常量则是编译运行阶段使用
  - define宏仅仅是展开，有几个地方使用则展开几次，不分配内存；`const`常量会在内存中分配地址（可以是堆中也可以是栈中）
  - define定义的常量在内存中有若干个拷贝，`const`定义的常量在程序运行过程中只有一份拷贝，甚至不为普通`const`常量分配存储空间，而是将它们保存在符号表中，相当于没有了读内存的操作，使得效率也很高



### 2.5 处理类型

- 类型别名

  - 是某种类型的同义词，使用类型别名可以使复杂的类型名字变得简洁明了

  ```c++
  typeof double wages;//typeof命名
  using SH = short;//用using命名，简称别名声明
  ```

  - 和define的区别：
    - #define是 C 中定义的语法, typedef 是 C++ 中定义的语法, 二者在 C++ 中可以通用
    - 但 #define 成了预编译指令, typedef 当成语句处理

- `auto`类型说明符
  - 有时声明变量的时候很难知道表达式的类型，就可以用`auto`来让编辑器替我们分析所属类型
  - 所声明的变量一定有初始值
  - 可以同时声明多个变量，但数据类型一定要相同

```c++
int i = 1;
auto j = i * 2047;//即j的类型就是int
```

- `decltype`类型指示符
  - 希望从表达式的类型推断处要定义的变量的类型，但是不想用该表达式的值初始化变量

```c++
decltype(f()) sum = x;//sum的类型就是函数f的返回类型
```



### 2.6自定义数据类型

- 定义一个结构体

  ```c++
  struct Sales_data{
    	string bookNo;
      unsigned units_sold = 0;
      double revence = 0.0;
  };
  ```

- 使用结构体中的

  ```c++
  Sales_data data1, data2;
  cin >> data1.bookNo >> data1.units_sold;
  ```

  

# 第三章 字符串、向量和数组

### 3.1命名空间的`using`声明

- 使用某个命名空间：例如 `using std::cin`表示使用命名空间`std`中的名字`cin`。
- 头文件中不应该包含`using`声明
  - 这是因为头文件的内容会拷贝到所有引用它的文件中，可能会引起名字的冲突

### 3.2标准库类型`string`

- `string`表示可变长的字符序列
- 注意要用头文件`#include <string>`

- 定义和初始化string对象

  - | 方式                  | 解释                                                    |
    | --------------------- | ------------------------------------------------------- |
    | `string s1`           | 默认初始化，`s1`是个空字符串                            |
    | `string s2(s1)`       | `s2`是`s1`的副本                                        |
    | `string s2 = s1`      | 等价于`s2(s1)`，`s2`是`s1`的副本                        |
    | `string s3("value")`  | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
    | `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本          |
    | `string s4(n, 'c')`   | 把`s4`初始化为由连续`n`个字符`c`组成的串                |

  - 拷贝初始化：使用等号`=`将一个已有的对象拷贝到正在创建的对象

  - 直接初始化：通过括号给对象赋值

- `string`的操作：

  - | 操作                 | 解释                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | `os << s`            | 将`s`写到输出流`os`当中，返回`os`                            |
    | `is >> s`            | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is`        |
    | `getline(is, s)`     | 从`is`中读取一行赋给`s`，返回`is`                            |
    | `s.empty()`          | `s`为空返回`true`，否则返回`false`                           |
    | `s.size()`           | 返回`s`中字符的个数                                          |
    | `s[n]`               | 返回`s`中第`n`个字符的引用，位置`n`从0计起                   |
    | `s1+s2`              | 返回`s1`和`s2`连接后的结果                                   |
    | `s1=s2`              | 用`s2`的副本代替`s1`中原来的字符                             |
    | `s1==s2`             | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
    | `s1!=s2`             | 同上                                                         |
    | `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感         |

  - 执行读操作`>>`：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止

  - `getline`：读取一整行，**包括空白符**

- 处理string对象中的字符
  - `cctype`头文件中定义了一组标准函数：

  - | 函数          | 解释                                                         |
    | ------------- | ------------------------------------------------------------ |
    | `isalnum(c)`  | 当`c`是字母或数字时为真                                      |
    | `isalpha(c)`  | 当`c`是字母时为真                                            |
    | `iscntrl(c)`  | 当`c`是控制字符时为真                                        |
    | `isdigit(c)`  | 当`c`是数字时为真                                            |
    | `isgraph(c)`  | 当`c`不是空格但可以打印时为真                                |
    | `islower(c)`  | 当`c`是小写字母时为真                                        |
    | `isprint(c)`  | 当`c`是可打印字符时为真                                      |
    | `ispunct(c)`  | 当`c`是标点符号时为真                                        |
    | `isspace(c)`  | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
    | `isupper(c)`  | 当`c`是大写字母时为真                                        |
    | `isxdigit(c)` | 当`c`是十六进制数字时为真                                    |
    | `tolower(c)`  | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c`         |
    | `toupper(c)`  | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c`         |

- 遍历字符串：
  - 使用 `for (auto c: str)`，或者 `for (auto &c: str)`使用引用直接改变字符串中的字符



### 3.3标准库类型`vector`

- vector是一个容器，也是一个类模板
- 注意头文件`#include <vector>` 然后 `using std::vector`
- 容器：包含其他对象。
- 类模板：本身不是类，但可以**实例化instantiation**出一个类。 `vector`是一个模板， `vector<int>`是一个类型
- 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`

- 初始化`vector`对象的方法

  - | 方法                        | 解释                                                         |
    | --------------------------- | ------------------------------------------------------------ |
    | `vector<T> v1`              | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
    | `vector<T> v2(v1)`          | `v2`中包含有`v1`所有元素的副本                               |
    | `vector<T> v2 = v1`         | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本                 |
    | `vector<T> v3(n, val)`      | `v3`包含了n个重复的元素，每个元素的值都是`val`               |
    | `vector<T> v4(n)`           | `v4`包含了n个重复地执行了值初始化的对象                      |
    | `vector<T> v5{a, b, c...}`  | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值       |
    | `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}`                                       |

- 列表初始化： `vector<string> v{"a", "an", "the"};`

- `v.push_back(e)` 在尾部增加元素

- 其他`vector`的操作：

- | 操作               | 解释                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | `v.emtpy()`        | 如果`v`不含有任何元素，返回真；否则返回假                    |
  | `v.size()`         | 返回`v`中元素的个数                                          |
  | `v.push_back(t)`   | 向`v`的尾端添加一个值为`t`的元素                             |
  | `v[n]`             | 返回`v`中第`n`个位置上元素的**引用**                         |
  | `v1 = v2`          | 用`v2`中的元素拷贝替换`v1`中的元素                           |
  | `v1 = {a,b,c...}`  | 用列表中元素的拷贝替换`v1`中的元素                           |
  | `v1 == v2`         | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
  | `v1 != v2`         | 同上                                                         |
  | `<`,`<=`,`>`, `>=` | 以字典顺序进行比较                                           |

- 范围`for`语句内不应该改变其遍历序列的大小。
- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素（所以才有`push_back`）

### 3.4迭代器介绍

- 所有标准库容器都可以使用迭代器
- 类似于指针类型，迭代器也提供了对对象的间接访问

- `auto b = v.begin();`返回指向第一个元素的迭代器。
- `auto e = v.end();`返回指向最后一个元素的下一个（哨兵，尾后,one past the end）的迭代器（off the end）
- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器
- 使用解引用符`*`访问迭代器指向的元素
- **容器**：可以包含其他对象；但所有的对象必须类型相同
- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素
- **const_iterator**：只能读取容器内元素不能改变
- **箭头运算符**： 解引用 + 成员访问，`it->mem`等价于 `(*it).mem`
- **谨记**：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

- 标准容器迭代器的运算符:

  - | 运算符           | 解释                                   |
    | ---------------- | -------------------------------------- |
    | `*iter`          | 返回迭代器`iter`所指向的**元素的引用** |
    | `iter->mem`      | 等价于`(*iter).mem`                    |
    | `++iter`         | 令`iter`指示容器中的下一个元素         |
    | `--iter`         | 令`iter`指示容器中的上一个元素         |
    | `iter1 == iter2` | 判断两个迭代器是否相等                 |

- 迭代器运算

  - | 运算符               | 解释                                                         |
    | -------------------- | ------------------------------------------------------------ |
    | `iter + n`           | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
    | `iter - n`           | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
    | `iter1 += n`         | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1`      |
    | `iter1 -= n`         | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1`      |
    | `iter1 - iter2`      | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
    | `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器                             |



### 3.5数组

- vector的低配版，长度固定

- 初始化：`char input_buffer[buffer_size];`，长度必须是`const`表达式，或者不写
- 数组不允许直接赋值给另一个数组
- 数组的访问
  - 数组下标的类型：`size_t` 。
  - 字符数组的特殊性：结尾处有一个空字符，如 `char a[] = "hello";` 。
- 用数组初始化 `vector`： `int a[] = {1,2,3,4,5}; vector<int> v(begin(a), end(a));` 

- 与指针的关系
  - 使用数组时，编译器一般会把它转换成指针
  - 标准库类型限定使用的下标必须是无符号类型，而内置的下标可以处理负值
  - **指针访问数组**：在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针

- C风格字符串
  - 从C继承来的字符串
  - 用空字符结束（`\0`）
  - 对大多数应用来说，使用标准库 `string`比使用C风格字符串更安全、更高效
  - 获取 `string` 中的 `cstring` ： `const char *str = s.c_str();` 
  - C标准库String函数，定义在`<cstring>` 中：

| 函数             | 介绍                                                         |
| ---------------- | ------------------------------------------------------------ |
| `strlen(p)`      | 返回`p`的长度，空字符不计算在内                              |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`                               |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`                                   |

### 3.6多维数组

- 多维数组的初始化： `int ia[3][4] = {{0,1,2,3}, ...}`
- 使用范围for语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型

- 动态数组
  - 使用 `new`和 `delete`表达和c中`malloc`和`free`类似的功能，即在堆（自由存储区）中分配存储空间
  - 定义： `int *pia = new int[10];` 10可以被一个变量替代
  - 释放： `delete [] pia;`，注意不要忘记`[]`