#### 13.1 拷贝、赋值与销毁

- 一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁
  - 拷贝构造函数
  - 拷贝赋值运算符
  - 移动构造函数
  - 移动赋值运算符
  - 析构函数
- 拷贝构造函数
  - 如果一个构造函数的第一个参数时自身类型的引用，且任何额外参数都有默认值，则此构造函数为拷贝构造函数
    - 如果不是引用，是传值的话，那就会无限的循环调用自身
  - 拷贝构造函数是系统会自动提供
  - 合成拷贝构造函数
  - 拷贝初始化和直接初始化
    - 拷贝初始化调用的情况
      - 将一个对象作为实参传递给一个非引用类型的形参
      - 从一个返回类型为非引用类型的函数返回一个对象
      - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
  - 参数和返回值
  - 拷贝初始化的限制
    - 防止隐式调用拷贝构造函数explicit
  - 编辑器可以绕过拷贝构造函数
    - 编辑器的优化
- 拷贝赋值运算符
  - 如果类未定义自己的拷贝赋值运算符，编辑器会为它合成一个
  - 重载赋值运算符
    - 赋值运算符通常返回一个指向其左侧运算对象的引用
  - 合成拷贝赋值运算符
- 析构函数
  - 释放对象使用的资源，并销毁对象的非static数据成员
  - 是一个类的成员函数，名字由波浪号类名构成，没有返回值，也不接受参数
  - 析构函数完成什么工作
    - 成员销毁时发生什么完全依赖于成员的类型，销毁类类型的成员需要执行成员自己的析构函数
    - 隐式销毁一个内置指针类型的成员不会delete它所指向的对象
  - 什么时候会调用析构函数
    - 变量在离开其作用域时被销毁
    - 当一个对象被销毁时，其成员被销毁
    - 容器被销毁时，其元素被销毁
    - 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
    - 对于临时对象，当创建它的完整表达式结束时被销毁
    - ps：当指向一个对象的引用或指针离开作用域时，析构函数不会执行
  - 合成析构函数
- 三/五法则
  - 需要析构函数的类也需要拷贝和赋值操作
    - 我的理解：你需要自己去析构对象，就表明编译器默认的析构你是用不了的，有些操作是要自己去释放的
    - 那也就代表着拷贝对象和赋值对象也是一样需要人工操作的
    - 可以参考：深拷贝和浅拷贝
    - 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数
  - 需要拷贝操作的类也需要赋值操作，反之亦然
    - 我的理解：拷贝和赋值不可以认为几乎时一样的操作吗
- 使用=default
  - 可以通过将拷贝控制成员定义为=default来显式要求编辑器生成合成的版本
- 阻止拷贝
  - 定义删除的函数
    - 可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来组织拷贝
    - 删除的函数是这样一种函数，虽然声明了它们，但是不能以任何方式使用它们
    - 在函数的参数列表后面加上=delete来指出
  - 析构函数不能是删除的成员
    - 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针
  - 合成的拷贝控制成员可能是删除的
    - 如果一个类有数据成员是不能默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的
  - private拷贝控制
    - 其实，如果不想拷贝函数被调用，就可以把它设为私有的就行了



#### 13.2 拷贝控制和资源管理

- 行为像值的类
  - 简述：拷贝、析构、拷贝复制运算符的时候要注意深拷贝和浅拷贝
  - 类值拷贝赋值运算符
    - 组合了析构函数和构造函数的操作
    - 赋值运算符的几点：
      - 如果将一个对象赋予它自身，赋值运算符必须能正确工作
      - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作
- 定义行为像指针的类
  - 注意：拷贝的应该是指针的指向
  - 引用计数



#### 13.3 交换操作

- 类里面的swap函数
- 编写我们自己的swap函数
  - 与拷贝控制成员不同，swap并不是必要的，但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段
- swap函数应该调用swap，而不是std::swap
  - 这里涉及using的问题
- 在赋值运算符中使用swap



#### 13.4 拷贝控制示例



#### 13.5 动态内存管理类



#### 13.6 对象移动

