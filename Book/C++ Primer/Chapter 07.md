##### 7.1 定义抽象数据类型

- 类的基本思想是数据抽象和封装

- 数据抽象是一种依赖于接口和实现分离的编程技术

- 定义成员函数

- 引入this

  - 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象

- 引入const成员函数

  - 紧跟在参数列表后面的const表示this是一个指向常量的指针，像这样使用const的成员函数被称为常量成员函数
  - 即不能修改该对象的属性

- 构造函数

  - 类通过一个或几个特殊的成员函数来控制其对象的初始化过程

  - 默认构造函数（无需任何实参）

    - 合成的默认构造函数

  - 构造函数不能被写为const

  - 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数

  - 如果需要编译器生成默认构造函数

    - ```c++
      Sales_data() = default;
      ```

  - 构造函数初始值列表

  - 在类的外部定义构造函数

  - 拷贝，赋值和析构函数

  - 



##### 7.2 访问控制与封装

- 访问说明符：public,private,protected
- class默认的访问权限是private，struct默认的访问权限是public
- 友元：类允许其他类或者函数访问它的非公有成员
  - 友元声明只能出现在类定义的内部



##### 7.3 类的其他特性

- 定义在类内的成员函数都是自动的inline

- 可变数据成员

  - 写了一个函数是const的常函数，但是有些数据是需要在这个函数里面改变的

  - 那就把这个数据设为可变数据

  - ```c++
    mutable int a;//mutable表示该数据是一个可变数据
    ```

- 类的成员函数

  - 如果提供了构造函数，那么编译器就不会提供默认的构造函数了

  - 如果需要编译器提供默认的构造函数，就要声明出来

  - ```c++
    Screen() = default;//告诉编译器为我们提供默认构造函数
    ```

- 定义一个类型成员

  - ```c++
    typedef std::string::size_type pos;//使用类型别名等价地声明一个类型名字
    using pps = std::string;//同理
    ```

  - 类定义的类型名字和其他成员一样存在访问权限的限制

- 返回*this的成员函数

  - 如果要链式编程的话，就必须以引用的形式返回对象
  - 将this对象作为左值返回

- 从const成员函数返回*this

  - 如果返回的是const Sales_data&的话，那么就不能够链式编程了，因为返回对象是const

- 基于const的重载

  - 可以用const来重载函数

- 类类型

  - 即使两个类的成员列表完全一致，它们也是不同的类型

- 类的声明

  - 也叫做前向声明
  - 在它声明之后定义之前是一个不完全类型

- 类之间的友元关系

  - 把一个类声明为自己的友元类

  - ```c++
    class Screen{
        
    };
    
    class Window_mgr{
        friend class Screen;
    }
    ```

  - 友元关系是不具备传递性的，每个类负责控制自己的友元类和友元函数

- 令成员函数作为友元

  - ```c++
    class Screen{
        friend void Window_mgr::clear(int);
    }
    ```

- 函数重载和友元

  - ```c++
    extern int& storeOn(string, int);
    extern double& storeOn(int);
    
    class Screen{
      friend int& storeOn()  
    }
    ```



##### 7.4 类的作用域

- 作用域和定义在类外部的成员

  - 函数成员可以声明在类内，定义在类外

  - ```c++
    void Window_mgr::clear(int i){
        
    }
    ```

- 名字查找：

  - 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明
  - 如果没有找到，继续查找外层作用域
  - 如果最终没有找到匹配的声明，则程序报错

- 对于定义在类内部的函数

  - 首先，编译成员的声明
  - 知道类全部可见后才编译函数体

- 用于类成员声明的名字查找

- 类型名要特殊处理

  - 已经在类外定义了的类型名就不能在类内重新定义

- 成员定义中的普通块作用域的名字查找

  - 首先，在成员函数内查找该名字的声明，和前面一样，只有在函数使用之前出现的声明才被考虑
  - 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑
  - 如果类内也没找到该名字的声明，在成员函数定义之前的作用域继续查找
  - 尽管类的成员被隐藏了，但我们仍可以通过加上类的名字或显著地使用this指针来强制访问类成员

- 类作用域之后，在外围的作用域中查找



##### 7.5 构造函数再探

- 构造函数初始化列表
  - 如果成员是const，引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初始值
  - 即用列表初始化成员，可以显式地初始化引用和const成员
  
- 成员初始化的顺序

  - 事实上，在编译器内部，并不是说按照代码的顺序初始化 初始化列表的，所以要尽量避免使用某些成员初始化其他成员

- 默认实参和构造函数

  - 构造函数也是接受默认实参的
  - 如果一个构造函数为所有参数提供了默认实参，则它实际上也定义了默认构造函数

- 委托构造函数

  - 就是在构造函数写实参的地方，调用构造函数

- 默认构造函数的作用

  - 如果定义了其他构造函数，那么最好也提供一个默认构造函数
  - 即如果有 有参构造函数了，那么就不会提供默认构造函数了

- 使用默认构造函数

  - 如果想要定义一个使用默认构造函数进行初始化对象，正确的方法是去掉对象名之后的空括号对

- 隐式的类类型转换

  - 只允许一步类类型转换
  - 能够通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则
  - 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种函数称为转换构造函数

- 类类型转换不是总有效的

  - 有时候编译器的隐式转换会给代码意想不到的影响

- 抑制构造函数定义的隐式转换

  - 通过关键字explicit来组织系统不自觉的隐式转换
  - 关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于指向隐式转换

- explicit构造函数只能用于直接初始化

  - ```c++
    Sales_data item1(null_book);//正确，可以直接初始化
    Sales_data item2 = null_book;//错误，这里涉及隐式转换，nonono
    ```

- 为转换显式地使用构造函数

  - 可以用类型等对数据进行强制转换

    - ```c++
      Sales_data(null_book);
      static_cast<Sales_data>(cin);
      ```

- 标准库中含有显示构造函数的类

- 聚合类

  - 所有成员都是public

  - 没有任何的构造函数

  - 没有类内初始值

  - 没有基类，没有虚函数

  - 可以用花括号来初始化

  - ```c++
    struct Data{
        int ival;
        string a;
    }
    
    Data vall = {1, "Anna"};//初始化的顺序一定要和类内声明的顺序一样
    ```

- 字面值常量类

  - null
  - https://blog.csdn.net/mbl114/article/details/111602832



##### 7.6 类的静态成员

- 声明静态成员
  - 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据
  - 静态成员函数也不与任何对象绑定在一起，它们不包含this指针，不能声明为const
- 使用类的静态成员
  - ：：访问
  - 类对象访问
  - 成员函数可以直接使用静态成员
- 定义静态成员
  - 类外定义的时候，不能重复static关键字
  - 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名，static关键词只能出现在类内
- 静态成员能用于某些场景，而普通成员不能
  - 可以使用静态成员作为默认实参，非静态数据成员不能作为默认实参（其本身就是对象的一部分）
- 静态成员的类内初始化
  - null

