# 目录

- 快速排序的实现（递归和非递归的版本，非递归的需要用到栈）

- 分析快速排序的时间空间复杂度（最极端的时间复杂度，最快要多少，最慢要多少，时间复杂度的推导）

- 快速排序的优化

  - 每次哨兵的选择，选第一个，中间，最后一个的中位数

  - ```html
    - 首先快排是不稳定[排序]()，因为它是通过交换元素来实现的，接着说了快排实现原理，这里就不详细展开了，然后说了快排适用于完全乱序的序列，不适用与基本有序或基本逆序的序列，最后我主动说了优化方法； 
    - 我之前看过侯捷老师的《STL源码剖析》，`stl`里面其实对快排做了一些优化，比如在选择哨兵的时候使用三数取中法，即取序列第一个元素、中间元素以及最后一个元素，再取这三个元素的中位数作为哨兵，这样可以避免取到边缘值而导致每次分割不均匀的情况； 
    - 第二种优化方法，因为在递归分割序列时，序列的长度会越来越短，又因为短序列[排序]()中插入[排序]()效率最高，所以可以设置一个阈值，当序列长度分割到阈值时切换到插入[排序]()，提高效率； 
    - 第三种优化，当序列中存在大量相同元素，或者全是相同元素时，使用快排仍然会得到最低效率，这时可以采用聚集相等元素的方法，每次选择哨兵后，将与哨兵相同的元素放到序列中间，下次分割时中间这些值不参与分割； 
    - 其实还有第四种优化方法，我当时忘记了，没说。第四种优化，当递归层数过深的时候改用堆[排序]()，虽然第一个优化方法避免了取到边缘哨兵，但还是有可能取到较边缘的哨兵，最坏的情况会导致递归层数过深，从而降低快排效率，所以每次递归要判断递归层数，达到一定深度就改用堆[排序]()，这是`stl`源码里实现的方法。之所以要用堆[排序]()，我猜想可能是因为快排和归并都是基于递归的[排序]()，此时递归深度已经太深，肯定不能再用了，而对于较长的序列使用插入[排序]()效率也不是太高，所以选择了堆[排序]()。 
    - 最后的最后分析了快排的时间复杂度最好情况为`O(NlogN)`，最坏为`O(N^2)`，空间复杂度最好的情况为`O(logN)`，因为递归时函数压栈需要空间，最坏情况为`O(N)`，一个快排呱呱呱说十分钟感觉问题不大。
    ```

  - 