- [线性表](#线性表)
- [查找](#查找)







##### 线性表

- 定义：
  - 是具有相同特性的数据元素的一个有限序列
  - 由`n(n≥0)`个数据元素（结点）a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>组成的有限序列
- 关键概念：
  - 对于序列中的第一个元素，称为**线性起点**（起始节点）；最后一个元素称为**线性终点**（终端结点）
  - 对于序列中的元素，前一个元素称为它的**直接前趋**，后一个元素称为它的**直接后继**
  - **下标**：是元素的序号，表示元素在表中的位置
  - 其中数据元素的个数**n**定义为表的长度，即**表长**
  - `n=0`时称为**空表**
- 线性表的顺序存储表示
  - 又称顺序存储结构或顺序映像
  - 顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构
  - 简而言之，逻辑上相邻，物理上也相邻
  - 线性表的第一个数据元素a<sub>1</sub>的存储位置，称作线性表的起始位置或基地址
  - 线性表顺序存储结构占用一片连续的存储空间，知道某个元素的存储位置就可以计算其他元素的存储位置
    - 依次存储，地址连续，中间没有空出存储单元
  - 所有数据元素的存储位置均可由第一个数据元素的存储位置得到：LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + ( i - 1 ) * t
    - 假设每个元素需占`l`个存储元素
  - 顺序表的特点：
    - 以物理位置相邻表示逻辑关系，任一元素均可随机存取
    - 进行插入存储和删除操作的时候，需要移动大量的元素，存储空间不灵活
- 线性表的链式存储结构
  - 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻
  - 访问时只能通过头指针进入链表，并通过每个节点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点花费的时间不等（顺序存储法）
  - 又称为非顺序映像或链式映像
  - 逻辑次序和物理次序不一定相同
  - 链表：n个结点由指针链组成一个链表
    - 它是线性表的链式存储映像，称为线性表的链式存储结构
  - 结点：数据元素的存储映像
    - 结点包括指针域和数据域
      - 指针域：存储直接后继结点的存储位置
      - 数据域：存储元素数值数据
  - 单链表是由头指针唯一确定，单链表可以用头指针的名字命名
  - 单链表（线性链表）：结点只有一个指针域的链表
  - 双链表：结点有两个指针域的链表
  - 循环链表：首尾相连的链表
  - 头指针：指向链表中第一个结点的指针
  - 首元节点：是指链表中存储第一个数据元素a<sub>1</sub>的结点
  - 头结点：是在链表的首元结点之前附设的一个结点（所以分为带头节点和不带头节点的链表）
    - 好处：便于首元节点的操作。因为这样首元节点前面也会有一个结点，那和后面结点的操作都是一样
    - 便于空表和非空表的统一处理：无论链表是否为空，头指针都是指向头节点的非空指针，处理统一
    - 头结点的数据域可以存放线性表的长度等元素，但是该结点不记作链表的总长度
  - 空链表：无头节点的时候，头指针为空；有头节点的时候，头节点的指针域为空
  - 单链表的查找、插入、删除算法时间空间效率分析
    - 查找
      - 只能逐个逐个的查找，时间复杂度为o（n）
    - 插入和删除
      - 一般情况是o（n）
      - 但是如果不知道要插入或是删除的具体位置，那么就要一个一个查找，就要o（n）
  - 头插法
    - 从一个空表开始，重复读入数据
    - 生成新的结点，将读入数据存放到新结点的数据域中
    - 从最后一个结点开始，依次将各结点插入到链表的前端
  - 尾插法
    - 从一个空表L开始，将新结点逐个插入到链表的尾部，尾指针r指向链表的尾结点
    - 初始时，r同L均指向头结点，每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点
- 循环链表
  - 是一种头尾相接的链表（即：表中最后一个结点的指针域指向头结点，整个链表形成一个环）
  - 优点：从表中任一结点出发均可找到表中其他结点
  - 由于循环链表中没有null指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p->next是否为空，而是判断它们是否等于头指针 
  - 头结点表示单循环链表，找第一个点的时间复杂度为o(1)，找an的时间复杂度为o(n)
    - 所以为了方便操作，表的操作常常都是在表尾位置进行，即知道尾指针就知道头指针，就既知道尾指针又知道头指针
- 双向链表
  - 在单链表的每个结点里再增加一个指向其直接前驱的指针point，这样链表中就形成了有两个方向不同的链
  - 原因：单链表找后继结点方便，但是找前继结点非常麻烦
  - 双向链表中的循环链表
    - 让头结点的前驱指针指向链表的最后一个结点
    - 让最后一个结点的后继指针指向头结点
  - 双向表的对称性
    - p->prior->next=p=p->next->prior



|                                 | 查找表头结点（首元节点）  | 查找表尾节点                           | 查找结点*P的前驱结点                        |
| ------------------------------- | ------------------------- | -------------------------------------- | ------------------------------------------- |
| 带头结点的单链表L               | L->next，时间复杂度O（1） | 从L->next依次向后遍历,时间复杂度O（n） | 通过p->next无法找到其前驱                   |
| 带头结点仅设头指针L的循环单链表 | L->next，时间复杂度O（1） | 从L->next依次向后遍历,时间复杂度O（n） | 通过p->next可以找到其前驱，时间复杂度O（n） |
| 带头结点仅设尾指针R的循环单链表 | R->next，时间复杂度O（1） | R，时间复杂度O（1）                    | 通过p->next可以找到其前驱，时间复杂度O（n） |
| 带头结点的双向循环链表L         | L->next，时间复杂度O（1） | L->prior，时间复杂度O（1）             | p->prior，时间复杂度O（1）                  |



- 链式存储结构的优点
  - 结点空间可以动态申请和释放
  - 数据元素的逻辑次序靠结点的指针来表示，插入和删除时不需要移动数据元素
- 链式存储结构的缺点
  - 存储密度小，每个结点的指针域需额外占用存储空间，当每个结点的数据域所占字节不多时，指针域所占存储空间的比重显得很大
    - 存储密度是指结点数据本身所占的存储量和整个结点结构中所占的存储量之比，即：结点数据本身占用的空间/结点占用的空间总量
  - 是非随机存取结构，对任一结点的操作都要从头指针依指针链查找到该结点，算法复杂度增加



##### 查找

- 查找表：
  - 是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用方便的结构
- 查找：
  - 根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）
- 关键字：
  - 用于标识一个数据元素（或记录）的某个数据项的值
  - 主关键字：可唯一地标识一个记录的关键字是主关键字
  - 次关键字：反之，用以识别若干记录的关键字是次关键字
- 若查找表中存在这样一个记录，则称“查找记录”
  - 查找结果给出整个记录的信息，或指示该记录在查找表中的位置
  - 否则称查找不成功
    - 返回结果为“空记录”或“空指针”
- 查找的目的：
  - 查询某个“特定的”数据元素是否在查找表中
  - 检索某个“特定的”数据元素的各种元素
  - 在查找表中插入一个数据元素
  - 删除查找表中的某个数据元素
- 查找表分为两类：
  - 静态查找表
    - 仅作“查询”（检索）操作的查找表
  - 动态查找表：
    - 作“插入”和“删除”操作的查找表
- 评价查找算法的指标
  - 关键词的平均比较次数，也称平均查找长度ASL（Average Search Length）
    - asl = pi*ci再求和（关键字比较次数的期望值）
      - n表示记录的个数
      - pi：查找第i个记录的概率
      - ci：找到第i个记录所需的比较次数
- 为了提高查找效率，在集合中的数据元素之间人为地加上某种确定的约束关系
- 线性表的查找：
  - 顺序查找（线性查找）
    - 应用范围：	
      - 顺序表或线性链表表示的静态查找表
      - 表内元素之间无序
    - 时间复杂度：O（n）
    - 空间复杂度：O(1)
    - 优点：
      - 算法简单，逻辑次序无要求，且不同存储结构均适用
    - 缺点：
      - ASL太长，时间效率太低
  - 折半查找（二分或对分查找）
    - 每次将待查记录所在区间缩小一半
    - 用判定树判断查找性能
    - 挖坑（二分查找的性能分析过程）
    - 优点：效率比顺序查找高，o(log2n)
    - 缺点：只适用于有序表，且限于顺序存储结构表（对线性链表无效）
  - 分块查找
    - 将表分成几块，且表或者有序或者无序，或者分块有序
      - 若i<j，则第j块中所有记录的关键字均大于第i块中的最大关键字
      - 建立索引表，每个结点含有最大关键字域和指向本块第一个结点的指针，且关键字有序
    - 查找过程：先确定待查记录所在块（顺序或折半查找），再在块内查找（顺序查找）
    - 查找性能分析（挖坑，太无聊了）
    - 优点：插入和删除比较容易，无需进行大量移动
    - 缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算