- [冒泡排序](#冒泡排序)
- [插入排序](#插入排序)
- [归并排序](#归并排序)
- [快速排序](#快速排序)
- [选择排序](#选择排序)
- [希尔排序](#希尔排序)
- [基数排序](#基数排序)
- [堆排序](#堆排序)






##### 冒泡排序

- 定义：冒泡排序又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端
- 时间复杂度：`O(n^2)`
- 空间复杂度：`O(n)`
- 思路：

  - 1、比较相邻的元素，如果前一个比后一个大，就交换他们两个
  - 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这步做完后，最后的元素会是最大的数
  - 3、针对所有的元素重复以上的步骤，除了最后一个
  - 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
  - 注意：如果数组本身就是有序的话，那么直接使用冒泡排序就会降低效率，所以可以设置一个哨兵，即对于首次的排列，如果出现了元素的交换，就将哨兵设为真，那么就证明数组本身不是有序的，那么就可以进行遍历；否则数组就是有序的，就不需要排序了
- 稳定性：稳定排序







##### 插入排序

- 定义：插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间

- 时间复杂度：`O(n^2)`

- 空间复杂度：`O(n)`

- 思路：

  - 从第一个元素开始，该元素可以认为已经被排序
  - 取出下一个元素，在已经排序的元素序列中从后向前扫描，如果该元素（已排序）大于新元素，将该元素移到下一位置
  - 重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置
  - 将新元素插入到该位置后
  - 一直重复前面三个步骤

- 稳定性：稳定排序








##### 归并排序

- 定义：归并排序，是创建在归并操作上的一种有效的排序算法。归并操作也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作

- 时间复杂度：`O(nlogn)`

- 空间复杂度：`O(n)`

- 思路：

  - 对于传入的数组，将数组分成两部分，然后分别对左右两边进行归并排序
  - 因为是先对两边进行排序，所以已知左右两边都是已经排序好的
  - 那么创建两个指针，分别指向数组的最左边和中间，进行比较大小，小的就传入新的数组
  - 注意：要看这两个指针最终是否指到中间和末尾，如果没有知道，就把剩余的数字全部传入新的数组
  - 反复重复上述的过程

- 稳定性：稳定排序








##### 快速排序

- 定义：快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列

- 时间复杂度：`O(nlogn)`，最坏的情况是`O(n^2)`

- 空间复杂度：使用的空间是`O(n)`，但是需要考虑到递归调用，所以有最优的时候空间复杂度为`O(nlogn)`，最差的有`O(n^2logn)`

- 思路：

  - 挑选基准值：从数列中挑出一个元素，作为当前的基准值
  - 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成
  - 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序

- 稳定性：非稳定排序








##### 选择排序

- 定义：选择排序是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动

- 时间复杂度：`O(n^2)`

- 空间复杂度：`O(n)`

- 思路：

  - 每一次对数组进行一次遍历，找到当前数组中的最大值，然后和数组的最后`i`位进行交换
  - 重复上面步骤`n`次

- 稳定性：非稳定排序








##### 希尔排序

- 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本，希尔排序是非稳定排序算法

- 时间复杂度：`O(n^(3/2))`，也和步长的计算方法有关系

- 空间复杂度：`O(n)`

- 思路：

  - 设置每一次排序的步长，可以认为每相隔一定步长的数字属于一个数组，接着对这个数组进行插入排序
  - 对于每一个步长，都进行上述操作，然后再更新步长
  - 最终步长会被更新至1，此时进行一次排序后变排序完成（合理性：因为对于每一个步长的数组都已经排序过了，那么整体就会呈现一个较为有序的状态，那么最后按照步长为1的情况进行排序就是全部有序的了）

- 稳定性：非稳定排序









##### 基数排序

- 定义：基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数

- 时间复杂度：`O(k*n)`，`k`是表示数字的位数，`n`是表示元素的个数

- 空间复杂度：`O(k + n)`

- 思路：

  - 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列

- 稳定性：稳定排序








##### 堆排序

- 定义：堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点

- 时间复杂度：`O(nlogn)`

- 空间复杂度：`O(n)`

- 思路：

  - 对于传入的数组，先是构造一个大根堆，大根堆的最大值是最前面的一个元素

  - 然后变量`i`从后往前循环，每一次把最后面的元素和根节点进行交换，在对0到`i-1`个元素构造一个新的大根堆

    这样保证了后面的元素是从大到小的

  - 依次重复上述步骤

  - 补：大根堆的构造方法：

    - 每次新插入的数据都与其父结点进行比较，如果插入的数比父结点大，则与父结点交换，否则一直向上交换，直到小于等于父结点，或者来到了顶端

- 稳定性：非稳定排序



记录一些比较无聊但有趣的排序方法

- bogosort

  - ```c++
    #include <iostream>
    #include <cstdlib>
    
    using namespace std;
    
    int Check(int *arr, int n)
    {
    	for (int i = 0; i < n - 1; i++) 
    		if (arr[i] > arr[i + 1]) return 1;
    	
    	return 0;
    }
    
    void RandSwap(int *arr, int n)
    {
    	int r, i, mid;
    	for (i = 0; i < n; i++)
    	{
    		r = rand() % n;
    		mid = arr[i];
    		arr[i] = arr[r];
    		arr[r] = mid;
    	} 
    }
    
    int main()
    {
    	int n, i;
    	int arr[100000];
    	cin >> n;
    	for (i = 0; i < n; i++) cin >> arr[i];
    	
    	while (Check(arr, n) == 1) RandSwap(arr, n);
    	
    	for (i = 0; i < n; i++) cout << arr[i] << " ";
    	return 0;
    }
    ```

- 鸡尾酒排序

  - ```c++
    #include <iostream>
    
    using namespace std;
    
    const int N = 1e6 + 10;
    
    int n;
    int arr[N];
    
    void cocktail_sort(int arr[], int len)
    {
        int i, left = 0, right = len - 1;
        int temp;
        while (left < right)
        {
            for (i = left; i < right; i++)
                if (arr[i] > arr[i + 1])
                {
                    temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                }
            right--;
            for (i = right; i > left; i--)
                if (arr[i - 1] > arr[i])
                {
                    temp = arr[i];
                    arr[i] = arr[i - 1];
                    arr[i - 1] = temp;
                }
            left++;
        }
    }
    
    int main()
    {
        cin >> n;
        for (int i = 0; i < n; i++)
            cin >> arr[i];
    
        cocktail_sort(arr, n);
    
        for (int i = 0; i < n; i++)
            cout << arr[i] << " ";
        return 0;
    }
    ```

  - 
