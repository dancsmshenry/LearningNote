#include <iostream>

using namespace std;

const int N = 1e4 + 10, M = 1e5 + 10;

int n, m;
char p[N], s[M]; //s是源字符串，p是模式字符串，这里的数组都是从1开始的
int ne[N];       //next数组

int main()
{
    cin >> n >> (p + 1) >> m >> (s + 1); //加一是后面有/0

    //求解next数组过程
    //next数组的意义：在以当前的点为结尾的字符串子串当中，使得子串的前缀与后缀相等的字符串的最大长度
    //ne[1] = 0;
    for (int i = 2, j = 0; i <= n; i++)
    {
        //i表示当前要计算的结点的坐标
        //j表示的是以 前一个点 作为结尾的子串的前缀等于后缀的字符串的最大长度
        while (j && p[i] != p[j + 1])
        {
            //对于一个新的next[i]，要想快速得到它的值最好的办法就是先看它next[i - 1]的值，即j值

            //如果j = 0就会有两种情况：

            //要么是ne[1]，那么就没必要找前缀等于后缀了（因为本身就是第一个，前缀就等于后缀）

            //要么就是前一个数也找不到前缀等于后缀的情况，那就直接看当前的值是否和第一个值相同（此时j + 1就表示第一个值）
            //这里会有一个疑问，就是当前面的一个数找不到前缀等于后缀的情况，为什么后面一个数就只能找第一个匹配呢？
            //可以这样思考：把当前一个数比作是尾巴，以前一个数为结尾的子串中能和头部匹配的部分是头部
            //匹配是讲究头尾都要配对的
            //如果当前是0的话，就表示连头部都没有了，那尾巴即使能匹配又能怎样呢？

            //而如果j > 0，说明前面是有“头部”和“头部”互相匹配的

            //那么此时再看p[i] 和 p[j + 1]的比较，一个是当前需要匹配的值，另一个是“头部”之后的一个值
            //如果二者相同，那么就是说即存在“头部”和“尾部”都匹配的情况

            //如果不相同，那就说明需要找新的“头部”去匹配
            //如何找新的头部呢，如果是正常的思路，那就是一个一个去往前面遍历匹配，但效率低下
            //先看一下已知的条件：有两个“头部”是相等的，但是加上了一个新的值（尾部）又不相等了
            //那既然要和最前面的数据相匹配，最好的办法就是找到此时“头部”的“头部”，挖坑.....
            j = ne[j];
        }
        if (p[i] == p[j + 1])
        {
            //如果当前的p[1,j + 1] = p[i - j + 1, i]，即前缀等于后缀且长度是最大的
            //那么j = j + 1，表示当前的前缀（或后缀）字符串的最大长度
            //接下来就赋值给ne[i]
            //否则不相等的话，就证明无法找到前缀等于后缀的情况，那ne[i]就等于0
            j++;
        }
        ne[i] = j;
    }

    //kmp匹配过程
    for (int i = 1, j = 0; i <= m; i++)
    {
        //j表示当前对模式字符串中的已经匹配成功的字符的数量
        //i表示当前对源字符串中的第几个字符进行匹配
        while (j && s[i] != p[j + 1])
        {
            //对于s[i] 和 p[j + 1]的比较，如果相同，就把j的数值加一
            //表示的是当前能够匹配到第j + 1项
            //如果不相同，那就把当前匹配的部分往后倒退ne[j]，因为ne[j]表示的就是后缀与前缀相等的部分
            //即使倒退了，也能继续匹配得上
            j = ne[j]; //结束条件，j已经退无可退，s[i] == p[j + 1]
        }
        if (s[i] == p[j + 1])
        {
            j++; //如果当前的数值相等，就j = j + 1;
        }
        if (j == n) //说明此时s字符串的第i位与p字符串的最后一位相同，即已经找到了模式字符串在源字符串的其中一个位置了
        {
            printf("%d ", i - n); //输出是从哪里开始匹配上的
            j = ne[j];            //然后再往后回退，重新再匹配
        }
    }

    return 0;
}