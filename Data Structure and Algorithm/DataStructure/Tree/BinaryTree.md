# 二叉树

- 出现的原因：
  - 结构最简单，规律性强
  - 可以证明，所有树都能转为唯一对应的二叉树，不失一般性
- 定义：是n(n>=0)个结点的有限集，它或者是空集（n=0），或者由一个根节点及两颗互不相交的分别称作这个根的左子树和右子树的二叉树组成
- 特点：
  - 每个结点最多有两个孩子
  - 子树是有左右之分的，次序不能颠倒（即为有序树）
    - 所以即使只有一颗子树，都要区分是左子树还是右子树
    - 对比树，树只有一个孩子的时候无需分辨是左还是右
    - 所以二叉树和树是两种不同的概念，但是树的基本术语对二叉树都是适用的
  - 二叉树是空集合，根可以有空的左子树或空的右子树
  - 二叉树的编号方式：从上到下，从左到右
- 性质：
  - 在二叉树的第i层上至多有2<sup>i-1</sup>个结点（i>=1）
    - 在第i层至少有1个结点
  - 深度为k的二叉树至多有2<sup>k</sup>-1个结点（k>=1）
    - 深度为k至少有k个结点
  - 对任何一颗二叉树T，如果其叶子数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>=n<sub>2</sub>+1
- 两种特殊的二叉树
  - **满二叉树**
    - 定义：一颗深度为k且有2<sup>k</sup>-1个结点的二叉树
    - 特点：
      - 每一层的结点数都是最大结点数（即每一层都满了）
      - 在顺序存储下能够复原
      - 叶子节点全部在最底层
      - 在同样深度的二叉树中**结点个数最多**，**叶子结点个数最多**
  - **完全二叉树**
    - 定义：深度为k的具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中的编号为1-n的结点一一对应
    - 特点：
      - 在满二叉树中，从最后一个结点开始，**连续**去掉**任意**个结点，即是一颗完全二叉树
      - 叶子只可能分布在层次最大的两层上
      - 对任一结点，如果其右子树的最大层次为i,则其左子树的最大层次必为i或i+1
      - 满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树
    - 性质：
      - 具有n个结点的完全二叉树的深度为**$\lfloor$log<sub>2</sub>n$\rfloor$+1**
      - 对于一颗完全二叉树来说，从上到下，从左到右编号，则对于任一一个结点i，有：
        - 若i=1，则为二叉树的根
        - 若i>1，则其双亲的结点为$\lfloor$$i/2\rfloor$
        - 若2i>n，则结点i为叶子结点，无左孩子；否则，其左孩子是结点2i
        - 若2i+1>n，则结点i无右孩子；否则，其右孩子是结点2i+1
    - 特殊的完全二叉树
      - 败者树
      - 胜者树







# 二叉树的遍历

- 定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而仅被访问一次
- 目的：得到树中所有结点的一个线性排列
- 用途：是树结构的插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心
- 类型：
  - 先序遍历（**根左右**）
    - 先访问根节点，再先序遍历左子树，最后先序遍历右子树
  - 中序遍历（**左根右**）
    - 先中序遍历左子树，再访问根节点，最后中序遍历右子树
  - 后序遍历（**左右根**）
    - 先后序遍历左子树，再后序遍历右子树，最后访问根节点
  - 拓展（对于一个算术表达式）
    - 先序遍历：表达式的前缀表示（波兰式）
    - 后序遍历：表达式的后缀表示（逆波兰式）
- 二叉树与遍历的关系：
  - 若二叉树中各结点的值均不相同，则二叉树结点的先序遍历、中序遍历和后序遍历都是唯一的
  - 由二叉树的先序遍历和后序遍历，或后序遍历和中序遍历可以确定唯一一颗二叉树

- 先序遍历+中序遍历，中序遍历+后序遍历都可以恢复原本的树







# 二叉树的存储结构

- 顺序存储结构
  - 将满二叉树的结点层次编号，依次存放二叉树中的数据元素（如果是空的就不放）
  - 缺点：
    - 如果是只有右单支树，会浪费空间
    - 结点间关系蕴含在其存储位置中，浪费空间，适于存储满二叉树和完全二叉树
- 链式存储结构
  - 二叉链表
    - 有两个指针域，分别指向结点的左孩子和右孩子
    - 在n个结点的二叉链表中，有n+1个空指针域
  - 三叉链表

