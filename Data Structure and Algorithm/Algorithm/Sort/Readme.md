
# 冒泡排序

- 定义：冒泡排序又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端
- 时间复杂度：`O(n^2)`
- 空间复杂度：`O(n)`
- 思路：

  - 1、比较相邻的元素，如果前一个比后一个大，就交换他们两个
  - 2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这步做完后，最后的元素会是最大的数
  - 3、针对所有的元素重复以上的步骤，除了最后一个
  - 4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
  - 注意：如果数组本身就是有序的话，那么直接使用冒泡排序就会降低效率，所以可以设置一个哨兵，即对于首次的排列，如果出现了元素的交换，就将哨兵设为真，那么就证明数组本身不是有序的，那么就可以进行遍历；否则数组就是有序的，就不需要排序了
- 稳定性：稳定排序







# 插入排序

- 定义：插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间

- 时间复杂度：`O(n^2)`

- 空间复杂度：`O(n)`

- 思路：

  - 从第一个元素开始，该元素可以认为已经被排序
  - 取出下一个元素，在已经排序的元素序列中从后向前扫描，如果该元素（已排序）大于新元素，将该元素移到下一位置
  - 重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置
  - 将新元素插入到该位置后
  - 一直重复前面三个步骤

- 稳定性：稳定排序








# 归并排序

- 定义：归并排序，是创建在归并操作上的一种有效的排序算法。归并操作也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作

- 时间复杂度：`O(nlogn)`

- 空间复杂度：`O(n)`

- 思路：

  - 对于传入的数组，将数组分成两部分，然后分别对左右两边进行归并排序
  - 因为是先对两边进行排序，所以已知左右两边都是已经排序好的
  - 那么创建两个指针，分别指向数组的最左边和中间，进行比较大小，小的就传入新的数组
  - 注意：要看这两个指针最终是否指到中间和末尾，如果没有知道，就把剩余的数字全部传入新的数组
  - 反复重复上述的过程

- 稳定性：稳定排序








# 快速排序

- 定义：快速排序使用分治法策略来把一个序列分为较小和较大的2个子序列，然后递归地排序两个子序列

- 时间复杂度：`O(nlogn)`，最坏的情况是`O(n^2)`

- 空间复杂度：使用的空间是`O(n)`，但是需要考虑到递归调用，所以有最优的时候空间复杂度为`O(nlogn)`，最差的有`O(n^2)`

- 思路：

  - 挑选基准值：从数列中挑出一个元素，作为当前的基准值
  - 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成
  - 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序

- 稳定性：非稳定排序

- 拓展：

  - ```cpp
    void quick_sort(int *arr, int left, int right)
    {
    	if (left >= right) return;
    	
    	int temp = arr[left], i = left - 1, j = right + 1;
    	while (i < j)
    	{
    		do i ++ ; while (arr[i] < temp);
    		do j -- ; while (arr[j] > temp);
    		if (i < j) swap(arr[i], arr[j]);
    	}
    		
    	quick_sort(arr, left, j);
    	quick_sort(arr, j + 1, right);
        /**
        记录一下对递归的一个思考，这里为什么不能写i，要写j + 1
        因为上面出来的是i < j ，而总和具体的内容
        可以发现，总共就两种情况：i == j，i == j + 1
        可能乍一看，感觉无论写i还是j+1都是一样的
        但是实际上完全不一样
        因为如果是i == j + 1的情况，那么，无所谓，因为我这种方法是以左一作为标准的，那么新的数组以j + 1为新的基准即可
        但，如果i == j，那么就会出现说，
        先看i是如何等于j的，是因为多余右边的数来说，都大于第j个数
        如果再以第j个数为标准，
        因为右边的数又是大于这个标准的，所以此时i和j又会相等，接着又是这样
        造成了无穷的循环
        **/
    }
    ```








# 选择排序

- 定义：选择排序是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动

- 时间复杂度：`O(n^2)`

- 空间复杂度：`O(n)`

- 思路：

  - 每一次对数组进行一次遍历，找到当前数组中的最大值，然后和数组的最后`i`位进行交换
  - 重复上面步骤`n`次

- 稳定性：非稳定排序








# 希尔排序

- 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本，希尔排序是非稳定排序算法

- 时间复杂度：`O(n^(3/2))`，也和步长的计算方法有关系

- 空间复杂度：`O(n)`

- 思路：

  - 设置每一次排序的步长，可以认为每相隔一定步长的数字属于一个数组，接着对这个数组进行插入排序
  - 对于每一个步长，都进行上述操作，然后再更新步长
  - 最终步长会被更新至1，此时进行一次排序后变排序完成（合理性：因为对于每一个步长的数组都已经排序过了，那么整体就会呈现一个较为有序的状态，那么最后按照步长为1的情况进行排序就是全部有序的了）

- 稳定性：非稳定排序





# 计数排序





# 基数排序

- 定义：基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数

- 时间复杂度：`O(k*n)`，`k`是表示数字的位数，`n`是表示元素的个数

- 空间复杂度：`O(k + n)`

- 思路：

  - 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列

- 稳定性：稳定排序








# 堆排序

- 是一种尚未搞明白的排序手法，极其神秘






记录一些比较无聊但有趣的排序方法

- bogosort

  - ```c++
    #include <iostream>
    #include <cstdlib>
    
    using namespace std;
    
    int Check(int *arr, int n)
    {
    	for (int i = 0; i < n - 1; i++) 
    		if (arr[i] > arr[i + 1]) return 1;
    	
    	return 0;
    }
    
    void RandSwap(int *arr, int n)
    {
    	int r, i, mid;
    	for (i = 0; i < n; i++)
    	{
    		r = rand() % n;
    		mid = arr[i];
    		arr[i] = arr[r];
    		arr[r] = mid;
    	} 
    }
    
    int main()
    {
    	int n, i;
    	int arr[100000];
    	cin >> n;
    	for (i = 0; i < n; i++) cin >> arr[i];
    	
    	while (Check(arr, n) == 1) RandSwap(arr, n);
    	
    	for (i = 0; i < n; i++) cout << arr[i] << " ";
    	return 0;
    }
    ```

- 鸡尾酒排序

  - ```c++
    #include <iostream>
    
    using namespace std;
    
    const int N = 1e6 + 10;
    
    int n;
    int arr[N];
    
    void cocktail_sort(int arr[], int len)
    {
        int i, left = 0, right = len - 1;
        int temp;
        while (left < right)
        {
            for (i = left; i < right; i++)
                if (arr[i] > arr[i + 1])
                {
                    temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                }
            right--;
            for (i = right; i > left; i--)
                if (arr[i - 1] > arr[i])
                {
                    temp = arr[i];
                    arr[i] = arr[i - 1];
                    arr[i - 1] = temp;
                }
            left++;
        }
    }
    
    int main()
    {
        cin >> n;
        for (int i = 0; i < n; i++)
            cin >> arr[i];
    
        cocktail_sort(arr, n);
    
        for (int i = 0; i < n; i++)
            cout << arr[i] << " ";
        return 0;
    }
    ```

- 桶排序

  - 就是把数据根据一定的特征放到对应的桶里面，再在桶里面单独排序
