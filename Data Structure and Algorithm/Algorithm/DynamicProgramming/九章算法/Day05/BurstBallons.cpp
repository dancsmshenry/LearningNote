#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/**
 * 这种问题，可以用这种思维去思考
 * 对于最后一个气球，它的左边和右边其实是互不影响的
 * 所以可以分批处理
 * 
 * 消去型问题，要从最后一个单位进行思考，观察它最后一个子问题的特殊之处
 * 
 * 接上：
 * 所以就可以这样想：既然最后的子问题变为了左半边和右半边各自最大能够获得多少的金币
 * 那么就建立数组f[i][j]来记录从i到j，扎破这些气球能够获得多少的金币
 * 
 * f[i][j] = max{f[i][k] + f[k][j] + a[i] * a[k] * a[j]}
 * k是最中间的那个最后一次扎破的气球
 * 所以循环是以k进行循环的
 * 
 * 区间型的动态规划，循环都是要以i-j的差的大小从小到大的顺序去算得
 **/ 

int main(){
    vector<int> b = {4, 1, 5, 10};

    int n = b.size();
    if (n == 0){
        cout << 0;
    }
    int a[n + 2];
    //最左边和最右边都要是1才行
    a[0] = 1;
    a[n + 1] = 1;
    for (int i = 1; i <= n; i ++ ){
        //数组移位
        a[i] = b[i - 1];
    }

    //init
    int f[n + 2][n + 2];
    for (int i = 0; i <= n; i ++ ){
        //因为要除去左右两个数字的话，得到的金币就是0
        //要涉及两个以上得数字，删掉才能获得金币
        f[i][i + 1] = 0;
    }

    //dp
    for (int len = 3; len <= n + 2; len ++ ){
        //所以这里要求i和j之间的距离要大于2才行
        for (int i = 0; i <= n + 2 - len ; i ++ ){
            int j = i + len - 1;
            f[i][j] = 0;//现设为0，然后再比较
            for (int k = i + 1; k < j; k ++ ){
                //k要在i-j之间才行
                f[i][j] = max(f[i][j], f[i][k] + f[k][j] + a[i] * a[k] * a[j]);
            }
        }
    }

    //最后返回的要是0-n+1之间的大小才行
    cout << f[0][n + 1];
}