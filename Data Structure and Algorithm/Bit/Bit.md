## 位运算基础

- `^`为异或运算，只有两个数字不相同的时候才会为1，相同的话就为0
  - 性质：
    - 交换律：`a ^ b ^ c = a ^ c ^ b`
    - `a ^ a = 0`
    - 结合律
  - 用途：
    - 翻转指定数字的位置：如果要翻转一个数字的指定位置，那么就设一个新的数字，在这个位置设为1，其余不翻转的位置为0
- `|`为或运算，只有当两个数字都是0的时候才会为0，其余的情况都为1
  - 用途：
    - 将指定位置变为1：如果要将指定位置变为1，那么就设一个新的数字，在这个位置设为1，其余不翻转的位置为0
- `&`为和运算，只有当两个数字都是1的时候才为1，其余的情况都为0
  - 用途：
    - 判断奇偶性，即`(x & 1) == 0`判断
    - 数字清零，即`x & 0`
    - 获得数字的最低非0位，即`a & (-a)`（注意，这里的负数的求法是全部位先求反位，然后再加一）
- `~`为非运算，取值和原值相反
- `>>`为右移运算符，是指首先将数字转换为二进制数字，然后全体向右边移一位，本质是数字本身除以2
- `<<`为左移运算符，是指首先将数字转换为二进制数字，然后全体向左边移一位，本质是数字本身乘以2



## 例题讲解

#### 只出现一次的数字

- 题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

  说明：

  你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

- 思路：数组中只有一个元素出现了一次，其余的元素都出现了两次，需要找到那个出现了一次的元素。那么就可以利用位运算的性质（`a ^ a =0`），将所有的元素进行一次异或的运算，最终剩下来的元素就是只出现了一次的元素

- ```c++
  int singleNumber(int* nums, int numsSize)
  {
      int i, one = 0;
  
      for(i = 0; i < numsSize; i++)
      {
          one = one ^ nums[i];
      }
  
      return one;
  }
  ```



#### 只出现一次的数字II

- 题目：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

  说明：

  你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

- 思路：数组中只有一个元素出现了一次，其余的元素都出现了三次。那么先换一种思路来想，把数字转换为二进制后，对于二进制中的每一位来说，它是1的次数应该是3的倍数吧，如果不是那就证明只出现一次的那个数在这里是有1的，如果是那就证明指出现役的的那个数在这里是0。得到每一位后再相加即可

- ```c++
  class Solution 
  {
      public:
          int singleNumber(vector<int>& nums) 
          {
              int result = 0;
              
              for (int i = 0; i < 32; i ++ )
              {
                  long number = 0;
                  for (int j = 0; j < nums.size(); j ++ ) number += (nums[j] >> i) & 1;
                  result += (number % 3) << i;
              }
  
              return result;
          }
  };
  ```



#### 只出现一次的数字III

- 题目：给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

  进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

- 思路：有两个元素只出现了一次，其余的元素都出现了两次。具体的思路见代码注释

- ```c++
  class Solution {
  public:
      vector<int> singleNumber(vector<int>& nums) {
          int ret = 0;
  
          for (int n : nums) ret ^= n;//这里对所有的元素进行异或运算，最终得到的元素就是那两个出现一次元素的异或值
          int div = ret & (-ret);
          //这里是重点，这一步是先找该异或值的最后一位1是在哪个位置，因为要以这个1为界限，数字中这个位置为1的放在一边，为0的放在另外一边（原理：这里出现1，就表明两个数字的这个位是不同的，而又已知所有元素都出现了两次（异或的性质），所以这样放置数字，到最后剩下来的就是那两个数了）
  
          int a = 0, b = 0;
          for (int n : nums)
              if (div & n) a ^= n;
              else b ^= n;
          
          return vector<int>{a, b};
      }
  };
  ```



#### 丢失的数字

- 给定一个包含 [0, n] 中 n 个数的数组`nums` ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

  进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

- 思路：这道题目一眼望去有很多种做法，这里介绍两种方法，一种比较麻烦，另外一种比较简单

  - 方法一：既然是`[0,n]`之间的数字，而且只少了一个数字，那么就可以用`[0,n]`的总和减去当前的总和，获得的数字就是丢失的那个数字

    - ```c++
      int missingNumber(int* nums, int numsSize)
      {
          int i, sum = 0;
          for(i = 0; i < numsSize; i++)
          sum = nums[i] + sum; 
          return numsSize * (numsSize + 1) / 2 - sum;
      }
      ```

  - 方法二：从异或的角度来思考，对于当前的数字，每个数字都出现了一次，只有一个数字没有出现过，范围是`[0,n]`。那么如果我对当前的有缺失的数组和全部数字都有的数组进行一次异或的操作，那么是不是就一位置，原先没出现过的数字出现了一次，而其他数字都出现了两次，而根据异或的性质，两个相同的数字相互抵消，那么剩下的那个数字就是没出现过的了

    - ```c++
      class Solution {
      public:
          int missingNumber(vector<int>& nums) {
              int missing = nums.length;
              for (int i = 0; i < nums.length; i++) {
                  missing ^= i ^ nums[i];
              }
              return missing;
          }
      };
      ```



#### 交换数字

- 编写一个函数，不用临时变量，直接交换`numbers = [a, b]`中`a`与`b`的值

- 思路：

  - 第一种方法：不用临时变量，就是用第一个变量储存两个的差值（`a-b`），然后第二个变量变为差值加上本身（`a - b + b`），到这一步的时候第二个变量就变为了第一个变量，最后再将第一个变量减去第一个变量的差值（`a - (a - b)`），这样第二个变量就到第一个变量那里了

    但是这种方法会出现加法溢出的现象，如果有条件可以用~~高精度加减法~~

  - ```c
    /**
     * Note: The returned array must be malloced, assume caller calls free().
     */
    int* swapNumbers(int* numbers, int numbersSize, int* returnSize)
    {
        * returnSize = numbersSize;
    
        numbers[0] = numbers[0] - numbers[1];
        numbers[1] = numbers[0] + numbers[1];
        numbers[0] = numbers[1] - numbers[0];
        
        return numbers;
    }
    ```

  - 第二种方法：位运算，这种方法就不会出现溢出的情况。利用的就是`a ^ a = 0`性质

  - ```c++
    class Solution {
    public:
        vector&lt;int&gt; swapNumbers(vector&lt;int&gt;&amp; numbers) {
            numbers[0]=numbers[0]^numbers[1];
            numbers[1]=numbers[0]^numbers[1];
            numbers[0]=numbers[0]^numbers[1];
            return numbers;
        }
    };
    ```